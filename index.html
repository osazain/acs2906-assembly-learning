<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACS2906 Assembly Language Learning App - Complete Edition</title>
    <style>
        /* ============================================
           COMPLETE CSS STYLES
           ============================================ */
        :root {
            --primary: #4a90d9;
            --primary-dark: #357abd;
            --secondary: #5cb85c;
            --accent: #f0ad4e;
            --danger: #d9534f;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --bg: #1a1a2e;
            --card-bg: #16213e;
            --text: #e0e0e0;
            --text-muted: #888;
            --border: #0f3460;
            --success: #27ae60;
            --warning: #f39c12;
            --info: #3498db;
            --reg-ax: #FF6B6B;
            --reg-bx: #4ECDC4;
            --reg-cx: #45B7D1;
            --reg-dx: #96CEB4;
            --reg-si: #FFE66D;
            --reg-di: #FFE66D;
            --reg-bp: #FF6B9D;
            --reg-sp: #FF6B9D;
            --reg-cs: #C7CEEA;
            --reg-ds: #C7CEEA;
            --reg-ss: #C7CEEA;
            --reg-es: #C7CEEA;
            --flag-set: #27ae60;
            --flag-unset: #555;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Navigation */
        nav {
            background: var(--card-bg);
            border-bottom: 2px solid var(--border);
            padding: 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            max-width: 1400px;
            margin: 0 auto;
        }

        .nav-tab {
            padding: 15px 20px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

        .nav-tab:hover {
            color: var(--text);
            background: rgba(74, 144, 217, 0.1);
        }

        .nav-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        /* Main Content */
        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1, h2, h3, h4 {
            color: var(--primary);
            margin-bottom: 15px;
        }

        h1 { font-size: 2rem; }
        h2 { font-size: 1.5rem; }
        h3 { font-size: 1.25rem; }

        /* Cards */
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--dark);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }

        /* Lecture Section Styles */
        .lecture-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .lecture-btn {
            padding: 10px 20px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lecture-btn:hover, .lecture-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        .lecture-content {
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 10px;
        }

        .lecture-content::-webkit-scrollbar {
            width: 8px;
        }

        .lecture-content::-webkit-scrollbar-track {
            background: var(--bg);
        }

        .lecture-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .page-content {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .page-number {
            background: var(--primary);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .content-tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 10px;
            margin-right: 5px;
        }

        .tag-code { background: #e74c3c; }
        .tag-math { background: #9b59b6; }
        .tag-def { background: #3498db; }
        .tag-exam { background: #f39c12; }

        /* Calculator Styles */
        .calc-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .calc-panel {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
        }

        .calc-title {
            color: var(--primary);
            font-size: 1.1rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .calc-input-group {
            margin-bottom: 15px;
        }

        .calc-label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-muted);
            font-size: 12px;
        }

        .calc-input {
            width: 100%;
            padding: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text);
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .calc-output {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
        }

        .calc-explanation {
            background: rgba(74, 144, 217, 0.1);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            margin-top: 10px;
            font-size: 13px;
        }

        .base-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .base-tab {
            padding: 8px 15px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            cursor: pointer;
            border-radius: 5px;
            font-size: 12px;
        }

        .base-tab.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        /* Simulator Styles */
        .simulator-container {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
        }

        .sim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .sim-main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 900px) {
            .sim-main {
                grid-template-columns: 1fr;
            }
        }

        .reg-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-muted);
        }

        .gp-registers {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .reg-card {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reg-card:hover {
            border-color: var(--primary);
        }

        .reg-card.selected {
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(240, 173, 78, 0.3);
        }

        .reg-name {
            font-weight: bold;
            font-size: 14px;
        }

        .reg-value {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: var(--primary);
        }

        .reg-binary {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .reg-8bit-row {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }

        .reg-8bit {
            flex: 1;
            background: rgba(255,255,255,0.05);
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
        }

        .reg-8bit:hover {
            background: rgba(255,255,255,0.1);
        }

        .index-regs, .segment-regs, .special-regs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .simple-reg {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            text-align: center;
        }

        .simple-reg:hover {
            border-color: var(--primary);
        }

        .flags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .flag-item {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--bg);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .flag-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--flag-unset);
        }

        .flag-indicator.set {
            background: var(--flag-set);
            box-shadow: 0 0 8px var(--flag-set);
        }

        .op-panel {
            background: var(--bg);
            border-radius: 8px;
            padding: 15px;
        }

        .op-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .op-btn {
            padding: 10px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .op-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .op-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .imm-input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .imm-input {
            flex: 1;
            padding: 10px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text);
            font-family: monospace;
        }

        .code-panel {
            background: var(--bg);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .code-display {
            font-family: 'Courier New', monospace;
            background: #0d1117;
            padding: 15px;
            border-radius: 5px;
            min-height: 150px;
            white-space: pre-wrap;
            color: #c9d1d9;
            line-height: 1.8;
        }

        .code-line {
            display: flex;
        }

        .line-num {
            color: #484f58;
            width: 30px;
            text-align: right;
            margin-right: 15px;
            user-select: none;
        }

        .line-content {
            flex: 1;
        }

        .mnemonic { color: #ff7b72; }
        .register { color: #79c0ff; }
        .immediate { color: #a5d6ff; }
        .comment { color: #8b949e; }
        .directive { color: #d2a8ff; }

        .example-select {
            margin-bottom: 15px;
        }

        /* Flashcard Styles */
        .flashcard-container {
            max-width: 600px;
            margin: 0 auto;
        }

        .flashcard-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-badge {
            background: var(--card-bg);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
        }

        .flashcard {
            background: var(--card-bg);
            border: 2px solid var(--border);
            border-radius: 15px;
            min-height: 300px;
            perspective: 1000px;
            cursor: pointer;
            position: relative;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .card-front {
            z-index: 2;
        }

        .card-back {
            transform: rotateY(180deg);
            background: var(--bg);
        }

        .card-category {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--primary);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 11px;
        }

        .card-question {
            font-size: 1.3rem;
            line-height: 1.6;
        }

        .card-answer {
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .flashcard-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .fc-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .fc-btn-know { background: var(--success); color: white; }
        .fc-btn-dont { background: var(--danger); color: white; }
        .fc-btn-shuffle { background: var(--accent); color: var(--dark); }

        /* Games Section Styles */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .game-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .game-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .game-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .game-desc {
            color: var(--text-muted);
            font-size: 13px;
            margin-bottom: 15px;
        }

        .game-container {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
        }

        .game-header-compact {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .btn-back {
            padding: 8px 15px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
        }

        .game-stats-bar {
            display: flex;
            gap: 10px;
        }

        .stat-box {
            background: var(--bg);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
        }

        .difficulty-selector-enhanced {
            background: var(--bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .diff-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .diff-btn {
            padding: 8px 20px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
        }

        .diff-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        .answers-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .answer-btn {
            padding: 15px;
            background: var(--bg);
            border: 2px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .answer-btn:hover {
            border-color: var(--primary);
            background: rgba(74, 144, 217, 0.1);
        }

        .answer-btn.correct {
            background: var(--success);
            border-color: var(--success);
        }

        .answer-btn.wrong {
            background: var(--danger);
            border-color: var(--danger);
        }

        .timer-bar {
            background: var(--bg);
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            margin-bottom: 20px;
        }

        .timer-progress {
            background: linear-gradient(90deg, var(--success), var(--accent));
            height: 100%;
            width: 100%;
            transition: width 1s linear;
        }

        .timer-progress.urgent {
            background: var(--danger);
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
        }

        .hidden { display: none !important; }

        /* Test Styles */
        .test-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .test-progress {
            background: var(--bg);
            height: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .test-progress-bar {
            background: var(--primary);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .options-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-btn {
            text-align: left;
            padding: 15px 20px;
            background: var(--bg);
            border: 2px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-btn:hover {
            border-color: var(--primary);
        }

        .option-btn.selected {
            background: var(--primary);
            border-color: var(--primary);
        }

        .option-btn.correct {
            background: var(--success);
            border-color: var(--success);
        }

        .option-btn.incorrect {
            background: var(--danger);
            border-color: var(--danger);
        }

        .explanation-box {
            background: rgba(74, 144, 217, 0.1);
            border-left: 4px solid var(--primary);
            padding: 15px 20px;
            margin-top: 20px;
            border-radius: 0 8px 8px 0;
        }

        .test-results {
            text-align: center;
            padding: 40px;
        }

        .score-circle {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin: 20px auto;
            border: 5px solid var(--primary);
        }

        .score-value {
            font-size: 3rem;
            font-weight: bold;
            color: var(--primary);
        }

        .score-label {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Keypad for Hex Hunter */
        .keypad {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-width: 300px;
            margin: 20px auto;
        }

        .keypad-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .key {
            width: 60px;
            height: 50px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }

        .key:hover {
            background: var(--primary);
        }

        .key.hex {
            background: rgba(155, 89, 182, 0.2);
        }

        .key.control {
            background: var(--card-bg);
        }

        .key.enter {
            background: var(--success);
            width: 80px;
        }

        /* ============================================
           INTERACTIVE LEARNING DEVICES STYLES
           ============================================ */
        
        /* Inline Quiz Styles */
        .inline-quiz {
            background: linear-gradient(135deg, rgba(74, 144, 217, 0.1), rgba(155, 89, 182, 0.1));
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            position: relative;
        }
        
        .inline-quiz-title {
            color: var(--primary);
            font-weight: bold;
            margin-bottom: 15px;
            padding-left: 10px;
        }
        
        .inline-quiz-question {
            font-size: 1.05rem;
            margin-bottom: 15px;
            color: var(--text);
        }
        
        .inline-quiz-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .inline-quiz-option {
            padding: 12px 15px;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            color: var(--text);
        }
        
        .inline-quiz-option:hover {
            border-color: var(--primary);
            background: rgba(74, 144, 217, 0.1);
        }
        
        .inline-quiz-option.correct {
            background: rgba(39, 174, 96, 0.2);
            border-color: var(--success);
        }
        
        .inline-quiz-option.incorrect {
            background: rgba(217, 83, 79, 0.2);
            border-color: var(--danger);
        }
        
        .inline-quiz-option.disabled {
            pointer-events: none;
            opacity: 0.7;
        }
        
        .inline-quiz-feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        
        .inline-quiz-feedback.correct {
            display: block;
            background: rgba(39, 174, 96, 0.15);
            border-left: 4px solid var(--success);
        }
        
        .inline-quiz-feedback.incorrect {
            display: block;
            background: rgba(217, 83, 79, 0.15);
            border-left: 4px solid var(--danger);
        }
        
        /* Formula Explorer Styles */
        .formula-explorer {
            background: var(--card-bg);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .formula-explorer-title {
            color: var(--accent);
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .formula-visualizer {
            background: var(--bg);
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }
        
        .bit-breakdown {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            justify-content: center;
            margin: 15px 0;
        }
        
        .bit-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: rgba(74, 144, 217, 0.2);
            border-radius: 4px;
            min-width: 60px;
        }
        
        .bit-group.sign { background: rgba(231, 76, 60, 0.3); }
        .bit-group.exponent { background: rgba(46, 204, 113, 0.3); }
        .bit-group.mantissa { background: rgba(155, 89, 182, 0.3); }
        
        .bit-group-label {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 5px;
        }
        
        .bit-value {
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
        }
        
        /* Practice Generator Styles */
        .practice-generator {
            background: linear-gradient(135deg, rgba(92, 184, 92, 0.1), rgba(240, 173, 78, 0.1));
            border: 2px solid var(--secondary);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .practice-generator-title {
            color: var(--secondary);
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .practice-problem {
            background: var(--bg);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 15px 0;
        }
        
        .practice-problem-text {
            font-size: 1.3rem;
            font-family: 'Courier New', monospace;
            color: var(--primary);
            margin-bottom: 15px;
        }
        
        .practice-input {
            padding: 12px 20px;
            background: var(--card-bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-family: monospace;
            font-size: 16px;
            text-align: center;
            width: 200px;
        }
        
        .practice-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .practice-feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        
        .practice-feedback.show {
            display: block;
        }
        
        .practice-feedback.correct {
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid var(--success);
        }
        
        .practice-feedback.incorrect {
            background: rgba(217, 83, 79, 0.2);
            border: 1px solid var(--danger);
        }
        
        /* Quick Reference Card Styles */
        .quick-ref-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .quick-ref-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .quick-ref-card.expanded {
            border-color: var(--primary);
            background: rgba(74, 144, 217, 0.05);
        }
        
        .quick-ref-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .quick-ref-title {
            font-weight: bold;
            color: var(--primary);
        }
        
        .quick-ref-toggle {
            color: var(--text-muted);
            font-size: 12px;
        }
        
        .quick-ref-content {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }
        
        .quick-ref-content.show {
            display: block;
        }
        
        .ref-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .ref-item {
            background: var(--bg);
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
        }
        
        .ref-item-name {
            font-weight: bold;
            color: var(--accent);
        }
        
        .ref-item-desc {
            color: var(--text-muted);
            margin-top: 4px;
        }
        
        /* Step-by-Step Visualizer */
        .step-visualizer {
            background: var(--bg);
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .step-item {
            display: flex;
            align-items: flex-start;
            margin: 10px 0;
            padding: 12px;
            background: var(--card-bg);
            border-radius: 8px;
            border-left: 3px solid var(--border);
            transition: all 0.3s;
        }
        
        .step-item.active {
            border-left-color: var(--primary);
            background: rgba(74, 144, 217, 0.1);
        }
        
        .step-number {
            background: var(--primary);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex: 1;
        }
        
        /* Timer Display */
        .timer-display {
            background: var(--card-bg);
            border: 2px solid var(--danger);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
        }
        
        .timer-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--danger);
        }
        
        .timer-label {
            font-size: 10px;
            color: var(--text-muted);
        }
        
        /* Formula Cheat Sheet */
        .cheat-sheet {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .cheat-sheet-title {
            color: var(--accent);
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }
        
        .cheat-formula {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid var(--primary);
        }
        
        .cheat-formula-name {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .cheat-formula-math {
            font-family: 'Courier New', monospace;
            color: var(--text);
            font-size: 14px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .nav-tabs {
                overflow-x: auto;
                flex-wrap: nowrap;
            }

            .sim-main {
                grid-template-columns: 1fr;
            }

            .gp-registers {
                grid-template-columns: 1fr;
            }

            .op-buttons {
                grid-template-columns: repeat(2, 1fr);
            }

            .answers-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <nav>
        <div class="nav-tabs">
            <button class="nav-tab active" data-section="lectures">üìö Lectures</button>
            <button class="nav-tab" data-section="calculator">üßÆ Calculator</button>
            <button class="nav-tab" data-section="simulator">üîß Simulator</button>
            <button class="nav-tab" data-section="flashcards">üé¥ Flashcards</button>
            <button class="nav-tab" data-section="games">üéÆ Games</button>
            <button class="nav-tab" data-section="tests">üìù Tests</button>
        </div>
        <div style="margin-left: auto; padding: 10px 20px; font-size: 12px; color: var(--text-muted);">by <span style="color: var(--primary);">OsaZain</span></div>
    </nav>

    <main>
        <!-- LECTURES SECTION -->
        <section id="lectures" class="active">
            <div class="card">
                <div class="card-header">
                    <h2>üìö ACS2906 Assembly Learning Guide <span style="font-size: 14px; color: var(--primary); font-weight: normal;">by OsaZain</span></h2><p style="color: var(--text-muted); margin-top: 5px;">Beginner-friendly explanations, formulas & examples</p>
                </div>
                <div class="lecture-nav" id="lecture-nav">
                    <button class="lecture-btn active" data-lecture="0">üìò L1: Computer Systems</button>
                    <button class="lecture-btn" data-lecture="1">üìó L2: Data Representation</button>
                    <button class="lecture-btn" data-lecture="2">üìô L3: Floating Point</button>
                    <button class="lecture-btn" data-lecture="3">üìï L4: Assembly Basics</button>
                    <button class="lecture-btn" data-lecture="4">üìì L5: I/O & Addressing</button>
                </div>
                <div class="lecture-content" id="lecture-content">
                    <!-- Lecture content populated by JavaScript -->
                </div>
            </div>
        </section>

        <!-- CALCULATOR SECTION -->
        <section id="calculator">
            <h2>üßÆ Assembly Calculators</h2>
            <div class="calc-grid">
                <!-- Base Converter -->
                <div class="calc-panel">
                    <div class="calc-title">üî¢ Base Converter (Dec/Bin/Hex/Oct)</div>
                    <div class="base-tabs">
                        <button class="base-tab active" data-base="dec">Decimal</button>
                        <button class="base-tab" data-base="bin">Binary</button>
                        <button class="base-tab" data-base="hex">Hex</button>
                        <button class="base-tab" data-base="oct">Octal</button>
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Input Value:</label>
                        <input type="text" class="calc-input" id="base-input" placeholder="Enter value...">
                        <button class="btn btn-primary" id="base-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="base-output">
                        <div>Decimal: <span id="out-dec">-</span></div>
                        <div>Binary: <span id="out-bin">-</span></div>
                        <div>Hexadecimal: <span id="out-hex">-</span></div>
                        <div>Octal: <span id="out-oct">-</span></div>
                    </div>
                    <div class="calc-explanation" id="base-explanation">
                        Enter a number to see conversions with detailed explanations.
                    </div>
                </div>

                <!-- IEEE 754 Converter -->
                <div class="calc-panel">
                    <div class="calc-title">üî¨ IEEE 754 Floating Point</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Decimal Number:</label>
                        <input type="text" class="calc-input" id="ieee-input" placeholder="e.g., 3.14159">
                        <button class="btn btn-primary" id="ieee-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="ieee-output">
                        <div>Sign: <span id="ieee-sign">-</span></div>
                        <div>Exponent: <span id="ieee-exp">-</span></div>
                        <div>Mantissa: <span id="ieee-mant">-</span></div>
                        <div>32-bit Hex: <span id="ieee-hex">-</span></div>
                        <div>Binary: <span id="ieee-bin">-</span></div>
                    </div>
                    <div class="calc-explanation" id="ieee-explanation">
                        Enter a decimal number to see its IEEE 754 single-precision representation.
                    </div>
                </div>

                <!-- Two's Complement -->
                <div class="calc-panel">
                    <div class="calc-title">‚ûï‚ûñ Two's Complement</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Decimal Number (can be negative):</label>
                        <input type="text" class="calc-input" id="twos-input" placeholder="e.g., -42">
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Bit Width:</label>
                        <select class="calc-input" id="twos-bits">
                            <option value="8">8-bit</option>
                            <option value="16" selected>16-bit</option>
                            <option value="32">32-bit</option>
                        </select>
                        <button class="btn btn-primary" id="twos-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="twos-output">
                        <div>Binary: <span id="twos-bin">-</span></div>
                        <div>Hexadecimal: <span id="twos-hex">-</span></div>
                        <div>Decimal: <span id="twos-dec">-</span></div>
                    </div>
                    <div class="calc-explanation" id="twos-explanation">
                        Two's complement representation for signed integers.
                    </div>
                </div>

                <!-- ASCII Converter -->
                <div class="calc-panel">
                    <div class="calc-title">üî§ ASCII Converter</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Text:</label>
                        <input type="text" class="calc-input" id="ascii-text" placeholder="Enter text...">
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Or ASCII Codes (space separated):</label>
                        <input type="text" class="calc-input" id="ascii-codes" placeholder="e.g., 65 66 67">
                        <button class="btn btn-primary" id="ascii-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="ascii-output">
                        <div>Hex: <span id="ascii-hex">-</span></div>
                        <div>Decimal: <span id="ascii-dec">-</span></div>
                        <div>Binary: <span id="ascii-bin">-</span></div>
                    </div>
                    <div class="calc-explanation" id="ascii-explanation">
                        Convert between text and ASCII representations.
                    </div>
                </div>

                <!-- Bitwise Operations -->
                <div class="calc-panel">
                    <div class="calc-title">‚öôÔ∏è Bitwise Operations</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Operand A (hex):</label>
                        <input type="text" class="calc-input" id="bit-a" placeholder="0xFF00">
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Operand B (hex):</label>
                        <input type="text" class="calc-input" id="bit-b" placeholder="0x0F0F">
                        <button class="btn btn-primary" id="bit-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="bit-output">
                        <div>AND: <span id="bit-and">-</span></div>
                        <div>OR: <span id="bit-or">-</span></div>
                        <div>XOR: <span id="bit-xor">-</span></div>
                        <div>NOT A: <span id="bit-not">-</span></div>
                        <div>A &lt;&lt; 1: <span id="bit-shl">-</span></div>
                        <div>A &gt;&gt; 1: <span id="bit-shr">-</span></div>
                    </div>
                    <div class="calc-explanation" id="bit-explanation">
                        Bitwise operations commonly used in assembly programming.
                    </div>
                </div>

                <!-- Address Calculator -->
                <div class="calc-panel">
                    <div class="calc-title">üìç Memory Address Calculator</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Segment (hex):</label>
                        <input type="text" class="calc-input" id="addr-seg" placeholder="0x0000">
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Offset (hex):</label>
                        <input type="text" class="calc-input" id="addr-off" placeholder="0x0000">
                        <button class="btn btn-primary" id="addr-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="addr-output">
                        <div>Physical Address: <span id="addr-physical">-</span></div>
                        <div>Calculation: <span id="addr-calc">-</span></div>
                    </div>
                    <div class="calc-explanation">
                        x86 real-mode addressing: Physical = Segment √ó 16 + Offset
                    </div>
                </div>
            </div>
        </section>

        <!-- SIMULATOR SECTION -->
        <section id="simulator">
            <div class="simulator-container">
                <div class="sim-header">
                    <h2>üîß 8086 CPU Simulator</h2>
                    <div>
                        <button class="btn btn-secondary" id="sim-reset">üîÑ Reset</button>
                        <button class="btn btn-secondary" id="sim-undo">‚Ü©Ô∏è Undo</button>
                        <select class="example-select" id="example-select">
                            <option value="">-- Load Example --</option>
                            <option value="hello">Hello World Setup</option>
                            <option value="add">Addition Example</option>
                            <option value="loop">Loop Counter</option>
                            <option value="string">String Operation</option>
                            <option value="stack">Stack Operations</option>
                            <option value="flags">Flags Demo</option>
                        </select>
                    </div>
                </div>
                <div class="sim-main">
                    <div class="reg-section">
                        <h3>üìä General Purpose Registers</h3>
                        <div class="gp-registers">
                            <div class="reg-card" data-reg="AX" style="--reg-color: var(--reg-ax)">
                                <div class="reg-name">AX</div>
                                <div class="reg-value" id="sim-ax">0000h</div>
                                <div class="reg-binary" id="sim-ax-bin">00000000 00000000</div>
                                <div class="reg-8bit-row">
                                    <div class="reg-8bit" data-half="AH">AH: <span id="sim-ah">00h</span></div>
                                    <div class="reg-8bit" data-half="AL">AL: <span id="sim-al">00h</span></div>
                                </div>
                            </div>
                            <div class="reg-card" data-reg="BX" style="--reg-color: var(--reg-bx)">
                                <div class="reg-name">BX</div>
                                <div class="reg-value" id="sim-bx">0000h</div>
                                <div class="reg-binary" id="sim-bx-bin">00000000 00000000</div>
                                <div class="reg-8bit-row">
                                    <div class="reg-8bit" data-half="BH">BH: <span id="sim-bh">00h</span></div>
                                    <div class="reg-8bit" data-half="BL">BL: <span id="sim-bl">00h</span></div>
                                </div>
                            </div>
                            <div class="reg-card" data-reg="CX" style="--reg-color: var(--reg-cx)">
                                <div class="reg-name">CX</div>
                                <div class="reg-value" id="sim-cx">0000h</div>
                                <div class="reg-binary" id="sim-cx-bin">00000000 00000000</div>
                                <div class="reg-8bit-row">
                                    <div class="reg-8bit" data-half="CH">CH: <span id="sim-ch">00h</span></div>
                                    <div class="reg-8bit" data-half="CL">CL: <span id="sim-cl">00h</span></div>
                                </div>
                            </div>
                            <div class="reg-card" data-reg="DX" style="--reg-color: var(--reg-dx)">
                                <div class="reg-name">DX</div>
                                <div class="reg-value" id="sim-dx">0000h</div>
                                <div class="reg-binary" id="sim-dx-bin">00000000 00000000</div>
                                <div class="reg-8bit-row">
                                    <div class="reg-8bit" data-half="DH">DH: <span id="sim-dh">00h</span></div>
                                    <div class="reg-8bit" data-half="DL">DL: <span id="sim-dl">00h</span></div>
                                </div>
                            </div>
                        </div>

                        <h3>üìç Index & Pointer Registers</h3>
                        <div class="index-regs">
                            <div class="simple-reg" data-reg="SI">
                                <div class="reg-name">SI</div>
                                <div class="reg-value" id="sim-si">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="DI">
                                <div class="reg-name">DI</div>
                                <div class="reg-value" id="sim-di">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="BP">
                                <div class="reg-name">BP</div>
                                <div class="reg-value" id="sim-bp">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="SP">
                                <div class="reg-name">SP</div>
                                <div class="reg-value" id="sim-sp">FFFEh</div>
                            </div>
                        </div>

                        <h3>üóÇÔ∏è Segment Registers</h3>
                        <div class="segment-regs">
                            <div class="simple-reg" data-reg="CS">
                                <div class="reg-name">CS</div>
                                <div class="reg-value" id="sim-cs">F000h</div>
                            </div>
                            <div class="simple-reg" data-reg="DS">
                                <div class="reg-name">DS</div>
                                <div class="reg-value" id="sim-ds">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="SS">
                                <div class="reg-name">SS</div>
                                <div class="reg-value" id="sim-ss">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="ES">
                                <div class="reg-name">ES</div>
                                <div class="reg-value" id="sim-es">0000h</div>
                            </div>
                        </div>

                        <h3>‚ö° Special Registers</h3>
                        <div class="special-regs">
                            <div class="simple-reg" data-reg="IP">
                                <div class="reg-name">IP</div>
                                <div class="reg-value" id="sim-ip">0000h</div>
                            </div>
                        </div>

                        <h3>üè≥Ô∏è Flags Register</h3>
                        <div class="flags-container">
                            <div class="flag-item" data-flag="CF"><div class="flag-indicator" id="flag-cf"></div>CF</div>
                            <div class="flag-item" data-flag="PF"><div class="flag-indicator" id="flag-pf"></div>PF</div>
                            <div class="flag-item" data-flag="AF"><div class="flag-indicator" id="flag-af"></div>AF</div>
                            <div class="flag-item" data-flag="ZF"><div class="flag-indicator" id="flag-zf"></div>ZF</div>
                            <div class="flag-item" data-flag="SF"><div class="flag-indicator" id="flag-sf"></div>SF</div>
                            <div class="flag-item" data-flag="TF"><div class="flag-indicator" id="flag-tf"></div>TF</div>
                            <div class="flag-item" data-flag="IF"><div class="flag-indicator" id="flag-if"></div>IF</div>
                            <div class="flag-item" data-flag="DF"><div class="flag-indicator" id="flag-df"></div>DF</div>
                            <div class="flag-item" data-flag="OF"><div class="flag-indicator" id="flag-of"></div>OF</div>
                        </div>
                        <div style="margin-top: 10px; font-family: monospace; font-size: 12px;">
                            FLAGS: <span id="sim-flags">0002h</span> | Binary: <span id="sim-flags-bin">00000000 00000010</span>
                        </div>
                    </div>

                    <div class="op-panel">
                        <h3>üî® Operations</h3>
                        <div style="margin-bottom: 15px; padding: 10px; background: var(--bg); border-radius: 5px;">
                            Selected: <strong id="selected-reg" style="color: var(--accent);">None</strong>
                        </div>
                        <div class="op-buttons">
                            <button class="op-btn" data-op="MOV">MOV</button>
                            <button class="op-btn" data-op="ADD">ADD</button>
                            <button class="op-btn" data-op="SUB">SUB</button>
                            <button class="op-btn" data-op="INC">INC</button>
                            <button class="op-btn" data-op="DEC">DEC</button>
                            <button class="op-btn" data-op="AND">AND</button>
                            <button class="op-btn" data-op="OR">OR</button>
                            <button class="op-btn" data-op="XOR">XOR</button>
                            <button class="op-btn" data-op="NOT">NOT</button>
                            <button class="op-btn" data-op="SHL">SHL</button>
                            <button class="op-btn" data-op="SHR">SHR</button>
                            <button class="op-btn" data-op="SET">SET</button>
                        </div>
                        <div class="imm-input-row">
                            <input type="text" class="imm-input" id="imm-value" placeholder="Immediate value (hex)">
                            <button class="btn btn-primary" id="exec-op">Execute</button>
                        </div>
                        <div style="margin-top: 15px; padding: 10px; background: var(--bg); border-radius: 5px; font-family: monospace; font-size: 12px;" id="last-op">
                            Last operation: None
                        </div>
                    </div>
                </div>

                <div class="code-panel">
                    <h3>üìÑ Assembly Code</h3>
                    <div class="code-display" id="code-display">
                        <div class="code-line"><span class="line-num">1</span><span class="line-content"><span class="directive">.MODEL</span> <span class="register">SMALL</span></span></div>
                        <div class="code-line"><span class="line-num">2</span><span class="line-content"><span class="directive">.STACK</span> <span class="immediate">100h</span></span></div>
                        <div class="code-line"><span class="line-num">3</span><span class="line-content"></span></div>
                        <div class="code-line"><span class="line-num">4</span><span class="line-content"><span class="directive">.DATA</span></span></div>
                        <div class="code-line"><span class="line-num">5</span><span class="line-content">    <span class="comment">; Data definitions here</span></span></div>
                        <div class="code-line"><span class="line-num">6</span><span class="line-content"></span></div>
                        <div class="code-line"><span class="line-num">7</span><span class="line-content"><span class="directive">.CODE</span></span></div>
                        <div class="code-line"><span class="line-num">8</span><span class="line-content"><span class="directive">MAIN</span> <span class="directive">PROC</span></span></div>
                        <div class="code-line"><span class="line-num">9</span><span class="line-content">    <span class="comment">; Your code here</span></span></div>
                        <div class="code-line"><span class="line-num">10</span><span class="line-content">    <span class="mnemonic">MOV</span> <span class="register">AX</span>, <span class="immediate">@DATA</span></span></div>
                        <div class="code-line"><span class="line-num">11</span><span class="line-content">    <span class="mnemonic">MOV</span> <span class="register">DS</span>, <span class="register">AX</span></span></div>
                        <div class="code-line"><span class="line-num">12</span><span class="line-content">    </span></div>
                        <div class="code-line"><span class="line-num">13</span><span class="line-content">    <span class="mnemonic">MOV</span> <span class="register">AH</span>, <span class="immediate">4Ch</span></span></div>
                        <div class="code-line"><span class="line-num">14</span><span class="line-content">    <span class="mnemonic">INT</span> <span class="immediate">21h</span></span></div>
                        <div class="code-line"><span class="line-num">15</span><span class="line-content"><span class="directive">MAIN</span> <span class="directive">ENDP</span></span></div>
                        <div class="code-line"><span class="line-num">16</span><span class="line-content">    <span class="directive">END</span> <span class="register">MAIN</span></span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- FLASHCARDS SECTION -->
        <section id="flashcards">
            <div class="flashcard-container">
                <h2 style="text-align: center;">üé¥ Study Flashcards</h2>
                <div class="flashcard-stats">
                    <div class="stat-badge">Card <span id="fc-current">1</span> / <span id="fc-total">50</span></div>
                    <div class="stat-badge">Known: <span id="fc-known">0</span></div>
                    <div class="stat-badge">Review: <span id="fc-review">0</span></div>
                </div>
                <div class="flashcard" id="flashcard">
                    <div class="card-face card-front">
                        <div class="card-category" id="fc-category">Registers</div>
                        <div class="card-question" id="fc-question">What is the AX register used for?</div>
                        <div style="margin-top: 30px; color: var(--text-muted); font-size: 12px;">
                            Click to flip
                        </div>
                    </div>
                    <div class="card-face card-back">
                        <div class="card-answer" id="fc-answer">
                            AX is the Accumulator register used for arithmetic operations, I/O operations, and interrupt calls. It can be accessed as two 8-bit registers: AH (high) and AL (low).
                        </div>
                    </div>
                </div>
                <div class="flashcard-controls">
                    <button class="fc-btn fc-btn-dont" id="fc-dont">ü§î Don't Know</button>
                    <button class="fc-btn fc-btn-shuffle" id="fc-shuffle">üîÄ Shuffle</button>
                    <button class="fc-btn fc-btn-know" id="fc-know">‚úÖ Know It</button>
                </div>
            </div>
        </section>

        <!-- GAMES SECTION -->
        <section id="games">
            <div id="games-menu">
                <h2>üéÆ Learning Games</h2>
                <div class="games-grid">
                    <div class="game-card" data-game="registerRacer">
                        <div class="game-icon">üèéÔ∏è</div>
                        <div class="game-title">Register Racer</div>
                        <div class="game-desc">Race against time to identify the correct register for each operation!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="hexHunter">
                        <div class="game-icon">üî¢</div>
                        <div class="game-title">Hex Hunter</div>
                        <div class="game-desc">Convert between decimal, hexadecimal, and binary as fast as you can!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="flagMaster">
                        <div class="game-icon">üèÅ</div>
                        <div class="game-title">Flag Master</div>
                        <div class="game-desc">Master the x86 flags by predicting their state after operations!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="opcodeHero">
                        <div class="game-icon">ü¶∏</div>
                        <div class="game-title">Opcode Hero</div>
                        <div class="game-desc">Identify assembly instructions and their effects!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="memoryMatch">
                        <div class="game-icon">üß†</div>
                        <div class="game-title">Memory Match</div>
                        <div class="game-desc">Match addressing modes with their descriptions!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="stackAttack">
                        <div class="game-icon">üìö</div>
                        <div class="game-title">Stack Attack</div>
                        <div class="game-desc">Track stack operations and predict SP/BP values!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                </div>
            </div>
            <div id="game-container" style="display: none;"></div>
        </section>

        <!-- TESTS SECTION -->
        <section id="tests">
            <div class="test-container">
                <h2>üìù Practice Tests</h2>
                <div id="test-start">
                    <div class="card" style="text-align: center; padding: 40px;">
                        <h3>Test Your Assembly Knowledge</h3>
                        <p style="margin: 20px 0; color: var(--text-muted);">
                            20 questions covering all lectures with detailed explanations
                        </p>
                        <button class="btn btn-primary" id="start-test" style="font-size: 18px; padding: 15px 40px;">
                            Start Test
                        </button>
                    </div>
                </div>
                <div id="test-active" style="display: none;">
                    <div class="test-progress">
                        <div class="test-progress-bar" id="test-progress"></div>
                    </div>
                    <div class="question-card">
                        <div class="question-text" id="test-question"></div>
                        <div class="options-list" id="test-options"></div>
                        <div class="explanation-box" id="test-explanation" style="display: none;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                        <button class="btn btn-secondary" id="test-prev" disabled>Previous</button>
                        <button class="btn btn-primary" id="test-next">Next Question</button>
                    </div>
                </div>
                <div id="test-results" style="display: none;">
                    <div class="card test-results">
                        <h2>Test Complete!</h2>
                        <div class="score-circle">
                            <div class="score-value" id="test-score">0%</div>
                            <div class="score-label">Score</div>
                        </div>
                        <p id="test-message"></p>
                        <div style="margin-top: 30px;">
                            <button class="btn btn-primary" id="retake-test">Retake Test</button>
                            <button class="btn btn-secondary" id="review-answers">Review Answers</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>


    <!-- FOOTER -->
    <footer style="background: var(--card-bg); border-top: 2px solid var(--border); padding: 20px; text-align: center; margin-top: 40px;">
        <div style="max-width: 1400px; margin: 0 auto;">
            <span style="color: var(--text-muted); font-size: 13px;">Created by <strong style="color: var(--primary);">OsaZain</strong> for ACS2906 Assembly Language</span>
            <span style="color: var(--text-muted); font-size: 12px; display: block; margin-top: 5px;">University of Winnipeg</span>
        </div>
    </footer>

    <script>
/**
 * Complete Lecture Content for ACS2906 Assembly Language Course
 * University of Winnipeg - Computer Architecture and System Software
 * 
 * Auto-extracted from PDFs on 2026-02-08 21:17:46
 * Total Pages: 328
 * 
 * This file contains the complete content of all 5 lecture PDFs including:
 * - All text content from every page
 * - Structured page-by-page breakdown
 * - Code examples and assembly instructions
 * - Identified sections and topics
 * - Content type classifications (code, exam_focus, definitions, etc.)
 */


// ============================================
// REWRITTEN LECTURE CONTENT - Beginner Friendly
// by OsaZain
// ============================================

/**
 * COMPLETE REWRITTEN LECTURES - Beginner Friendly
 * ACS2906 Assembly Language - University of Winnipeg
 * Created by OsaZain
 */

// ============================================================================
// LECTURE 1: COMPUTER SYSTEMS OVERVIEW
// ============================================================================
const lecture1Content = {
  title: "Lecture 1: Computer Systems Overview",
  description: "Understanding how computers work from the ground up - bits, numbers, and the compilation process.",
  
  sections: [
    {
      id: "bits-context",
      title: "Information is Bits + Context",
      icon: "üíæ",
      explanation: `Everything in a computer is stored as bits (0s and 1s). But bits alone don't mean anything - they need context to be understood.

Think of it like this: The bits "01000001" could be:
- The number 65 (if interpreted as an integer)
- The letter 'A' (if interpreted as ASCII)
- Part of an image pixel (if interpreted as image data)

The same bits mean different things depending on HOW we read them.`,
      analogy: "It's like the number 12/03/2024 - it could be March 12th (US format) or December 3rd (European format). The digits are the same, but the context (format) changes the meaning.",
      whyItMatters: "Understanding this helps you debug programs when data looks wrong - you might be interpreting it with the wrong context!",
      examples: [
        { bits: "01000001", context: "Integer", meaning: "65" },
        { bits: "01000001", context: "ASCII", meaning: "'A'" },
        { bits: "01000001", context: "Instruction", meaning: "INC ECX" }
      ]
    },
    {
      id: "number-systems",
      title: "Understanding Number Systems",
      icon: "üî¢",
      explanation: `Humans use decimal (base 10) because we have 10 fingers. Computers use binary (base 2) because they have electronic switches that are either ON (1) or OFF (0).

DECIMAL (Base 10): Uses digits 0-9
- 7392 means: 7√ó1000 + 3√ó100 + 9√ó10 + 2√ó1

BINARY (Base 2): Uses digits 0-1
- 1011 means: 1√ó8 + 0√ó4 + 1√ó2 + 1√ó1 = 11 in decimal

HEXADECIMAL (Base 16): Uses digits 0-9 and letters A-F
- Each hex digit represents exactly 4 binary digits (1 nibble)
- FF means: 15√ó16 + 15√ó1 = 255 in decimal`,
      
      whyBinary: `Computers use binary because:
1. Easy to store: Just needs two states (high/low voltage, on/off)
2. Easy to transmit: Two signal levels instead of ten
3. Reliable: Less chance of error than distinguishing 10 levels
4. Simple logic: AND, OR, NOT gates work naturally with binary`,
      
      conversionMethods: {
        decToBinary: {
          title: "Decimal ‚Üí Binary",
          method: "Repeated Division by 2",
          steps: [
            "Divide the number by 2",
            "Write down the remainder (0 or 1)",
            "Divide the quotient by 2",
            "Repeat until quotient is 0",
            "Read the remainders from BOTTOM to TOP"
          ],
          example: `Convert 219 to binary:
219 √∑ 2 = 109 remainder 1
109 √∑ 2 = 54  remainder 1
54  √∑ 2 = 27  remainder 0
27  √∑ 2 = 13  remainder 1
13  √∑ 2 = 6   remainder 1
6   √∑ 2 = 3   remainder 0
3   √∑ 2 = 1   remainder 1
1   √∑ 2 = 0   remainder 1

Reading from bottom: 11011011`,
          result: "219 = 11011011‚ÇÇ"
        },
        
        binaryToHex: {
          title: "Binary ‚Üí Hexadecimal",
          method: "Group by 4 bits",
          steps: [
            "Start from the RIGHT (least significant bit)",
            "Group bits into sets of 4",
            "If needed, pad with leading zeros on the left",
            "Convert each group to its hex digit"
          ],
          example: `Convert 11011011 to hex:
1101 1011 (grouped)

1101 = 8+4+0+1 = 13 = D
1011 = 8+0+2+1 = 11 = B

Result: 0xDB`,
          reference: {
            "0000": "0", "0001": "1", "0010": "2", "0011": "3",
            "0100": "4", "0101": "5", "0110": "6", "0111": "7",
            "1000": "8", "1001": "9", "1010": "A", "1011": "B",
            "1100": "C", "1101": "D", "1110": "E", "1111": "F"
          }
        },
        
        decToHex: {
          title: "Decimal ‚Üí Hexadecimal",
          method: "Repeated Division by 16",
          steps: [
            "Divide the number by 16",
            "Write down the remainder (0-15, where 10=A, 11=B, etc.)",
            "Divide the quotient by 16",
            "Repeat until quotient is 0",
            "Read remainders from BOTTOM to TOP"
          ],
          example: `Convert 219 to hex:
219 √∑ 16 = 13 remainder 11 (B)
13  √∑ 16 = 0  remainder 13 (D)

Reading from bottom: 0xDB`,
          formula: "219 = 13√ó16 + 11 = 0xDB"
        }
      },
      
      commonMistakes: [
        "Reading binary remainders top-to-bottom instead of bottom-to-top",
        "Forgetting that hex digits A-F represent 10-15",
        "Not padding binary groups to 4 bits when converting to hex",
        "Confusing 0x prefix (hex) with 0 prefix (octal in some languages)"
      ],
      
      practiceProblems: [
        { q: "Convert 42 to binary", a: "101010", work: "42√∑2=21r0, 21√∑2=10r1, 10√∑2=5r0, 5√∑2=2r1, 2√∑2=1r0, 1√∑2=0r1 ‚Üí 101010" },
        { q: "Convert 255 to hex", a: "0xFF", work: "255√∑16=15r15(F), 15√∑16=0r15(F) ‚Üí 0xFF" },
        { q: "Convert 1010 1100 to hex", a: "0xAC", work: "1010=A, 1100=C ‚Üí 0xAC" }
      ]
    },
    {
      id: "ascii",
      title: "ASCII - Text Representation",
      icon: "üî§",
      explanation: `ASCII (American Standard Code for Information Interchange) assigns a number to each character.

Key ASCII codes to remember:
- '0'-'9' = 0x30-0x39 (48-57 decimal)
- 'A'-'Z' = 0x41-0x5A (65-90 decimal)  
- 'a'-'z' = 0x61-0x7A (97-122 decimal)
- Space = 0x20 (32 decimal)
- Newline (LF) = 0x0A (10 decimal)
- Carriage Return (CR) = 0x0D (13 decimal)`,
      
      importantForAssembly: `When displaying numbers in DOS:
- You must ADD 30h to convert a digit to its ASCII character
- Example: To display the number 5, load 35h (or 5+30h) into DL`,
      
      examples: [
        { char: "'0'", hex: "0x30", dec: "48", bin: "00110000" },
        { char: "'A'", hex: "0x41", dec: "65", bin: "01000001" },
        { char: "'a'", hex: "0x61", dec: "97", bin: "01100001" }
      ]
    },
    {
      id: "compilation",
      title: "Program Compilation Process",
      icon: "‚öôÔ∏è",
      explanation: `When you write a C program, it goes through several stages before becoming an executable:

1. PREPROCESSOR
   - Handles #include, #define
   - Removes comments
   - Produces expanded source code

2. COMPILER  
   - Translates C code to Assembly
   - Optimizes the code
   - Produces .s file (assembly)

3. ASSEMBLER
   - Translates Assembly to Machine Code
   - Produces .o file (object file)
   - Contains binary instructions

4. LINKER
   - Combines multiple object files
   - Links with libraries
   - Produces final executable`,
      
      visualDiagram: `
Source Code (.c)
      ‚Üì
Preprocessor
      ‚Üì
Expanded Source
      ‚Üì
Compiler
      ‚Üì
Assembly Code (.s)
      ‚Üì
Assembler
      ‚Üì
Object Code (.o)
      ‚Üì
Linker + Libraries
      ‚Üì
Executable (.exe)
      `,
      
      whyItMatters: "Understanding this helps you debug issues. If you get linker errors, the problem is in step 4. If you get compiler errors, the problem is in step 2."
    }
  ]
};

// ============================================================================
// LECTURE 2: DATA REPRESENTATION
// ============================================================================
// ============================================================================
// LECTURE 2: DATA REPRESENTATION - COMPREHENSIVE
// ============================================================================
const lecture2Content = {
  title: "Lecture 2: Data Representation & Integer Arithmetic",
  description: "Binary representations, signed/unsigned integers, two's complement, bit operations, shifts, byte ordering, and floating point introduction.",
  
  sections: [
    {
      id: "number-systems-review",
      title: "Number Systems Review",
      icon: "üî¢",
      explanation: `Computers store all information as bits. Understanding number systems is essential for low-level programming.

DECIMAL (Base 10): Uses digits 0-9
‚Ä¢ 7392 = 7√ó10¬≥ + 3√ó10¬≤ + 9√ó10¬π + 2√ó10‚Å∞

BINARY (Base 2): Uses digits 0-1
‚Ä¢ 1011‚ÇÇ = 1√ó2¬≥ + 0√ó2¬≤ + 1√ó2¬π + 1√ó2‚Å∞ = 11‚ÇÅ‚ÇÄ

HEXADECIMAL (Base 16): Uses 0-9, A-F
‚Ä¢ Each hex digit = 4 binary digits (1 nibble)
‚Ä¢ FF‚ÇÅ‚ÇÜ = 15√ó16 + 15 = 255‚ÇÅ‚ÇÄ
‚Ä¢ Convention: prefix with 0x (e.g., 0xFF)`,
      
      whyBinary: `Why Computers Use Binary:
1. Easy to store: Two states (high/low voltage)
2. Reliable transmission: Two signal levels vs. ten
3. Simple logic: AND, OR, NOT gates work naturally
4. Electronic implementation is straightforward`,

      conversionMethods: {
        decToBinary: {
          title: "Decimal ‚Üí Binary: Repeated Division by 2",
          steps: [
            "Divide number by 2",
            "Record remainder (0 or 1)",
            "Repeat with quotient until 0",
            "Read remainders BOTTOM to TOP"
          ],
          example: `Convert 219 to binary:
219 √∑ 2 = 109 remainder 1
109 √∑ 2 = 54  remainder 1
54  √∑ 2 = 27  remainder 0
27  √∑ 2 = 13  remainder 1
13  √∑ 2 = 6   remainder 1
6   √∑ 2 = 3   remainder 0
3   √∑ 2 = 1   remainder 1
1   √∑ 2 = 0   remainder 1

Result: 11011011‚ÇÇ`,
          formula: "219 = 128+64+16+8+2+1 = 11011011‚ÇÇ"
        },
        
        binaryToHex: {
          title: "Binary ‚Üí Hex: Group by 4 bits",
          steps: [
            "Start from RIGHT (least significant)",
            "Group into sets of 4 bits",
            "Pad with leading zeros if needed",
            "Convert each group to hex digit"
          ],
          example: `Convert 11011011 to hex:
1101 1011

1101‚ÇÇ = 8+4+0+1 = 13 = D‚ÇÅ‚ÇÜ
1011‚ÇÇ = 8+0+2+1 = 11 = B‚ÇÅ‚ÇÜ

Result: 0xDB`,
          reference: {
            "0000": "0", "0001": "1", "0010": "2", "0011": "3",
            "0100": "4", "0101": "5", "0110": "6", "0111": "7",
            "1000": "8", "1001": "9", "1010": "A", "1011": "B",
            "1100": "C", "1101": "D", "1110": "E", "1111": "F"
          }
        },
        
        decToHex: {
          title: "Decimal ‚Üí Hex: Repeated Division by 16",
          steps: [
            "Divide number by 16",
            "Record remainder (0-15, A=10, B=11, etc.)",
            "Repeat with quotient until 0",
            "Read remainders BOTTOM to TOP"
          ],
          example: `Convert 312236 to hex:
312236 √∑ 16 = 19514 remainder 12 (C)
19514  √∑ 16 = 1219  remainder 10 (A)
1219   √∑ 16 = 76    remainder 3
76     √∑ 16 = 4     remainder 12 (C)
4      √∑ 16 = 0     remainder 4

Reading from bottom: 0x4C3AC`,
          verification: "4√ó16‚Å¥ + 12√ó16¬≥ + 3√ó16¬≤ + 10√ó16 + 12 = 312236"
        }
      },
      
      commonMistakes: [
        "Reading binary remainders top-to-bottom (must be bottom-to-top!)",
        "Forgetting that hex digits A-F represent 10-15",
        "Not padding binary to groups of 4 when converting to hex",
        "Confusing 0x prefix (hex) with 0 prefix (octal in some languages)"
      ],
      
      examTip: "Exam Tip: Practice conversions quickly. You'll need them for interpreting register values and memory dumps!"
    },
    
    {
      id: "memory-units",
      title: "Memory Units & Organization",
      icon: "üíæ",
      explanation: `Understanding memory units is crucial for working with computer systems:

BIT: Single binary digit (0 or 1)
NIBBLE: 4 bits (one hex digit)
BYTE: 8 bits = 2 nibbles (smallest addressable unit)
WORD: 16 bits (2 bytes) on x86
DOUBLE WORD: 32 bits (4 bytes)

Larger units (powers of 2):
‚Ä¢ 1 KB (Kilobyte) = 1024 bytes = 2¬π‚Å∞ bytes
‚Ä¢ 1 MB (Megabyte) = 1024 KB = 2¬≤‚Å∞ bytes
‚Ä¢ 1 GB (Gigabyte) = 1024 MB = 2¬≥‚Å∞ bytes
‚Ä¢ 1 TB (Terabyte) = 1024 GB = 2‚Å¥‚Å∞ bytes`,

      memoryOrganization: {
        title: "Memory Addressing",
        explanation: `Memory is organized as a linear array of bytes. Each byte has a unique address.

‚Ä¢ 32-bit address bus can address 2¬≥¬≤ bytes = 4 GB
‚Ä¢ 64-bit address bus can address 2‚Å∂‚Å¥ bytes ‚âà 18 exabytes

Objects are stored contiguously, and the object's address is the address of its first byte.`,
        example: `Example: Word at address 0x100
Address:  0x100   0x101
Value:    0x34    0x12    (for value 0x1234 in little-endian)

Addresses of successive words differ by:
‚Ä¢ 4 bytes on 32-bit systems
‚Ä¢ 8 bytes on 64-bit systems`
      },

      dataTypes: {
        title: "C/C++ Data Type Sizes",
        types: [
          { type: "char", size: "1 byte", range: "-128 to 127 or 0 to 255" },
          { type: "short", size: "2 bytes", range: "-32,768 to 32,767" },
          { type: "int", size: "4 bytes", range: "-2,147,483,648 to 2,147,483,647" },
          { type: "long", size: "4 or 8 bytes", range: "System dependent" },
          { type: "float", size: "4 bytes", notes: "IEEE 754 single precision" },
          { type: "double", size: "8 bytes", notes: "IEEE 754 double precision" }
        ],
        examTip: "Important: Same bit pattern can represent different values depending on type (int vs float)!"
      }
    },

    {
      id: "byte-ordering",
      title: "Byte Ordering: Big-Endian vs Little-Endian",
      icon: "üìä",
      explanation: `When storing multi-byte values, the order of bytes matters. There are two conventions:

BIG-ENDIAN (Network Order, used by some RISC processors):
‚Ä¢ Most Significant Byte at lowest address
‚Ä¢ Like normal reading: left (big) to right
‚Ä¢ Example: 0x01234567 stored as [01][23][45][67]

LITTLE-ENDIAN (x86 Architecture):
‚Ä¢ Least Significant Byte at lowest address
‚Ä¢ Like reading backwards
‚Ä¢ Example: 0x01234567 stored as [67][45][23][01]

x86 uses LITTLE-ENDIAN!`,
      
      visualExample: {
        title: "Visual Example: Storing 0x01234567 at address 0x100",
        bigEndian: `
Address:  0x100  0x101  0x102  0x103
Value:     0x01   0x23   0x45   0x67
          (MSB)................(LSB)
        `,
        littleEndian: `
Address:  0x100  0x101  0x102  0x103
Value:     0x67   0x45   0x23   0x01
          (LSB)................(MSB)
        `
      },
      
      stringRepresentation: {
        title: "String Representation",
        explanation: `Strings are sequences of characters terminated by a null byte (0x00).

ASCII encoding:
‚Ä¢ Characters '0'-'9': 0x30-0x39 (48-57)
‚Ä¢ Characters 'A'-'Z': 0x41-0x5A (65-90)
‚Ä¢ Characters 'a'-'z': 0x61-0x7A (97-122)

Example: "Hello" is stored as:
0x48 0x65 0x6C 0x6C 0x6F 0x00
  H    e    l    l    o   NUL

Note: ASCII strings look the same on both endian systems because each character is one byte.`,
        examTip: "Exam Tip: For x86, always remember: LOW BYTE at LOW ADDRESS"
      },

      whyItMatters: `Network protocols use Big Endian, but x86 uses Little Endian. When sending data over a network from an x86 machine, you must convert (byte swap)!

Assembly example showing little-endian:
  MOV word ptr [0x100], 0x1234
After execution:
  Memory at 0x100: 0x34
  Memory at 0x101: 0x12`
    },

    {
      id: "boolean-logic",
      title: "Bit-Level Operations (Boolean Logic)",
      icon: "üîß",
      explanation: `Boolean logic, developed by George Boole, is the foundation of bit manipulation in computers.

Boolean Operations:
‚Ä¢ NOT ~p: True if p is false (complement)
‚Ä¢ AND p & q: True only if BOTH p and q are true
‚Ä¢ OR p | q: True if EITHER p or q is true  
‚Ä¢ XOR p ^ q: True if ONLY ONE of p or q is true

These operations are applied BIT-WISE to entire integers.`,

      operations: {
        AND: {
          symbol: "&",
          description: "Result bit is 1 ONLY if both bits are 1",
          useCase: "Masking - extract/isolate specific bits",
          truthTable: "0&0=0, 0&1=0, 1&0=0, 1&1=1",
          example: `0x69 & 0x55 = 0x41
  0110 1001 (0x69)
& 0101 0101 (0x55)
= 0100 0001 (0x41)`,
          assembly: "AND AL, 0Fh  ; Mask to get low nibble",
          tip: "(X & 1) returns the lowest bit of X - use for even/odd check!"
        },
        
        OR: {
          symbol: "|",
          description: "Result bit is 1 if EITHER bit is 1",
          useCase: "Setting bits - turn specific bits ON",
          truthTable: "0|0=0, 0|1=1, 1|0=1, 1|1=1",
          example: `0x69 | 0x55 = 0x7D
  0110 1001 (0x69)
| 0101 0101 (0x55)
= 0111 1101 (0x7D)`,
          assembly: "OR AL, 30h  ; Convert digit to ASCII",
          tip: "Setting bit: OR with a mask that has 1s where you want to set"
        },
        
        XOR: {
          symbol: "^",
          description: "Result bit is 1 if bits are DIFFERENT",
          useCase: "Toggling bits, zeroing registers efficiently",
          truthTable: "0^0=0, 0^1=1, 1^0=1, 1^1=0",
          example: `0xFF ^ 0x0F = 0xF0
  1111 1111 (0xFF)
^ 0000 1111 (0x0F)
= 1111 0000 (0xF0)`,
          special: "XOR EAX, EAX  ; Clears EAX to 0 (faster than MOV EAX, 0!)",
          tip: "XOR with 0x20 toggles case: 'A'(0x41) ^ 0x20 = 'a'(0x61)"
        },
        
        NOT: {
          symbol: "~",
          description: "Invert all bits (0 becomes 1, 1 becomes 0)",
          useCase: "One's complement, bit inversion",
          example: `~0x41 = 0xBE (in 8-bit)
  0100 0001 (0x41)
~ 1011 1110 (0xBE)`,
          assembly: "NOT AL  ; Invert all bits in AL",
          note: "In C/C++/Java: NOT is ~, but in logical contexts ! is used"
        }
      },
      
      commonPatterns: {
        title: "Common Bit Patterns for Assembly Programming",
        list: [
          { pattern: "AND with 0x0F", effect: "Extract low nibble (4 bits)", example: "0x3A & 0x0F = 0x0A" },
          { pattern: "AND with 0xF0", effect: "Extract high nibble", example: "0x3A & 0xF0 = 0x30" },
          { pattern: "OR with 0x30", effect: "Convert digit to ASCII", example: "0x05 | 0x30 = 0x35 ('5')" },
          { pattern: "XOR with 0x20", effect: "Toggle case (a‚ÜîA)", example: "0x41('A') ^ 0x20 = 0x61('a')" },
          { pattern: "AND with 1", effect: "Check if odd/even", example: "X & 1 = 0 if even, 1 if odd" }
        ]
      },

      logicalVsBitwise: {
        title: "Logical vs Bitwise Operators (C/C++/Java)",
        bitwise: "&, |, ^, ~ - operate on each bit individually",
        logical: "&&, ||, ! - treat entire value as true (non-zero) or false (zero)",
        example: `int a = 5, b = 10;
(a < b) && (a < 15) = true (1)

Bitwise: 0x69 & 0x55 = 0x41
Logical: 0x69 && 0x55 = 1 (both non-zero)`,
        examTip: "In assembly, we use bitwise operations. Logical operators are for high-level control flow."
      }
    },

    {
      id: "shift-operations",
      title: "Shift Operations",
      icon: "‚ÜîÔ∏è",
      explanation: `Shift operations move bits left or right. They're efficient alternatives to multiplication and division by powers of 2.

Three types of shifts:
1. Left Shift (SHL / <<) - multiply by powers of 2
2. Right Logical Shift (SHR) - divide unsigned by powers of 2
3. Right Arithmetic Shift (SAR) - divide signed by powers of 2`,
      
      leftShift: {
        title: "Shift Left (SHL / <<)",
        description: "Move all bits left, fill right with zeros. Bit shifted out goes to Carry Flag.",
        formula: "x << n = x √ó 2‚Åø",
        example: `5 << 3 = 40
  0000 0101 (5)
<< 3
  0010 1000 (40)

Because: 5 √ó 2¬≥ = 5 √ó 8 = 40`,
        flags: "CF = last bit shifted out, ZF set if result zero, SF = MSB of result",
        assembly: "SHL AX, 3  ; Multiply AX by 8",
        overflow: "If significant bit shifted out, overflow occurs!"
      },
      
      rightShiftLogical: {
        title: "Right Logical Shift (SHR)",
        description: "Move all bits right, fill left with ZEROS. Used for UNSIGNED numbers.",
        formula: "x SHR n = x √∑ 2‚Åø (unsigned, rounds toward 0)",
        example: `40 SHR 3 = 5
  0010 1000 (40)
>> 3
  0000 0101 (5)

Because: 40 √∑ 2¬≥ = 40 √∑ 8 = 5`,
        warning: "‚ö†Ô∏è WARNING: For signed numbers, use SAR to preserve sign bit!",
        assembly: "SHR AX, 1  ; Divide unsigned AX by 2"
      },
      
      rightShiftArithmetic: {
        title: "Right Arithmetic Shift (SAR)",
        description: "Move all bits right, fill left with SIGN BIT (copy MSB). Used for SIGNED numbers.",
        formula: "x SAR n = x √∑ 2‚Åø (signed, rounds toward -‚àû)",
        example: `-20 SAR 2 = -5
  1110 1100 (-20 in 8-bit)
SAR 2
  1111 1011 (-5)

Notice: Sign bit (1) is copied to the left!`,
        problem: "Problem: Integer division should round toward 0, but SAR rounds toward -‚àû",
        solution: "For negative numbers, add bias (2‚Åø - 1) before shifting",
        biasedExample: `-5 / 2: Should be -2 (not -3)
Without bias: 1011 SAR 1 = 1101 (-3) ‚úó
With bias: (1011 + 0001) SAR 1 = 1100 (-4)? 
Wait: -5 = 1011, bias = 2¬π-1 = 1
(1011 + 0001) = 1100, SAR 1 = 1110 (-2) ‚úì`,
        assembly: "SAR AX, 1  ; Divide signed AX by 2"
      },

      comparisonTable: {
        title: "Shift Operations Summary",
        headers: ["Operation", "Fill Direction", "Use For", "Example"],
        rows: [
          ["SHL/<<", "Right with 0s", "Multiply (√ó2‚Åø)", "5 << 2 = 20"],
          ["SHR", "Left with 0s", "Unsigned √∑ 2‚Åø", "20 >> 2 = 5"],
          ["SAR", "Left with sign", "Signed √∑ 2‚Åø", "-20 SAR 2 = -5"]
        ]
      },

      performanceNote: `Performance Advantage:
‚Ä¢ Addition: 1-2 cycles
‚Ä¢ Multiplication: 5-10 cycles
‚Ä¢ Division: 20-39 cycles
‚Ä¢ Shift: 1 cycle!

Always substitute multiplication/division by powers of 2 with shifts when possible!`
    },

    {
      id: "unsigned-integers",
      title: "Unsigned Integer Representation",
      icon: "‚ûï",
      explanation: `Unsigned integers can only represent non-negative numbers (zero and positive).

The bit pattern is interpreted directly as a binary number:

B2U(X) = Œ£(x·µ¢ √ó 2‚Å±) for i = 0 to w-1

Where:
‚Ä¢ w = number of bits
‚Ä¢ x·µ¢ = bit i (0 or 1)
‚Ä¢ U = Unsigned interpretation`,

      formula: "Range: 0 to 2 ∑ - 1",
      
      ranges: {
        title: "Unsigned Integer Ranges",
        sizes: [
          { bits: 8, range: "0 to 255", formula: "0 to 2‚Å∏ - 1" },
          { bits: 16, range: "0 to 65,535", formula: "0 to 2¬π‚Å∂ - 1" },
          { bits: 32, range: "0 to 4,294,967,295", formula: "0 to 2¬≥¬≤ - 1" }
        ]
      },

      example: {
        title: "8-bit Unsigned Examples",
        table: [
          { binary: "00000000", hex: "0x00", decimal: "0" },
          { binary: "00001111", hex: "0x0F", decimal: "15" },
          { binary: "10000000", hex: "0x80", decimal: "128" },
          { binary: "11111111", hex: "0xFF", decimal: "255" }
        ]
      },

      observation: "With w bits, there are 2 ∑ different patterns, representing integers 0 through 2 ∑ - 1."
    },

    {
      id: "signed-integers",
      title: "Signed Integer Representation (Two's Complement)",
      icon: "‚ûñ",
      explanation: `Signed integers represent both positive and negative numbers using Two's Complement.

In two's complement:
‚Ä¢ The most significant bit (MSB) is the SIGN BIT
‚Ä¢ 0 in MSB = positive number
‚Ä¢ 1 in MSB = negative number

Formula:
B2T(X) = -x_{w-1} √ó 2^{w-1} + Œ£(x·µ¢ √ó 2‚Å±) for i = 0 to w-2

The MSB has a NEGATIVE weight!`,

      formula: "Range: -2^{w-1} to 2^{w-1} - 1",

      ranges: {
        title: "Signed Integer Ranges (Two's Complement)",
        sizes: [
          { bits: 8, range: "-128 to +127", formula: "-2‚Å∑ to 2‚Å∑ - 1" },
          { bits: 16, range: "-32,768 to +32,767", formula: "-2¬π‚Åµ to 2¬π‚Åµ - 1" },
          { bits: 32, range: "-2,147,483,648 to +2,147,483,647", formula: "-2¬≥¬π to 2¬≥¬π - 1" }
        ]
      },

      whyAsymmetric: `The range is asymmetric because:
‚Ä¢ Zero uses one of the "positive" slots
‚Ä¢ There are 2^{w-1} negative numbers (-2^{w-1} to -1)
‚Ä¢ There are 2^{w-1} non-negative numbers (0 to 2^{w-1}-1)
‚Ä¢ Most negative number has no positive counterpart!`,

      conversionTable: {
        title: "4-bit Two's Complement Examples",
        headers: ["Binary", "Hex", "Unsigned", "Signed"],
        rows: [
          ["0000", "0x0", "0", "0"],
          ["0001", "0x1", "1", "1"],
          ["0010", "0x2", "2", "2"],
          ["0111", "0x7", "7", "7"],
          ["1000", "0x8", "8", "-8"],
          ["1001", "0x9", "9", "-7"],
          ["1110", "0xE", "14", "-2"],
          ["1111", "0xF", "15", "-1"]
        ]
      },

      properties: {
        title: "Key Properties of Two's Complement",
        list: [
          "Uniqueness: Every bit pattern represents exactly one integer",
          "One zero: Only one representation of zero (000...000)",
          "Negation: Negating a number: invert all bits and add 1",
          "Addition: Same hardware works for both signed and unsigned",
          "Sign extension: Copy sign bit to expand to larger width"
        ]
      }
    },

    {
      id: "twos-complement-conversion",
      title: "Two's Complement Conversion Methods",
      icon: "üîÑ",
      explanation: `There are several methods to convert between decimal and two's complement binary.`,

      negativeToBinary: {
        title: "Method 1: Convert Negative Decimal to Binary",
        steps: [
          "1. Take the absolute value |N|",
          "2. Convert |N| to binary",
          "3. Invert all bits (0‚Üí1, 1‚Üí0) - One's Complement",
          "4. Add 1 to the result",
          "5. Result is Two's Complement representation"
        ],
        example: `Convert -5 to 8-bit:
Step 1: |N| = 5
Step 2: 5 in binary = 00000101
Step 3: Invert = 11111010
Step 4: Add 1 = 11111011
Step 5: -5 = 11111011‚ÇÇ = 0xFB`,
        verification: `Check: 5 + (-5) = 0
  00000101 (5)
+ 11111011 (-5)
= 00000000 with carry out (discarded) ‚úì`
      },

      shortcutMethod: {
        title: "Method 2: Shortcut Formula",
        formula: "For N < 0: Representation = 2 ∑ + N",
        example: `Convert -5 to 8-bit:
Representation = 2‚Å∏ + (-5) = 256 - 5 = 251
251 in binary = 11111011 = 0xFB ‚úì

Convert -128 to 8-bit:
Representation = 256 + (-128) = 128 = 0x80 = 10000000 ‚úì`
      },

      binaryToNegative: {
        title: "Method 3: Read a Negative Binary Number",
        shortcut: "If MSB is 1 (negative):",
        steps: [
          "1. Invert all bits",
          "2. Add 1",
          "3. Read as positive value",
          "4. Add negative sign"
        ],
        example: `Read signed 11111011:
Step 1: Invert = 00000100
Step 2: Add 1 = 00000101 = 5
Step 3: Therefore 11111011 = -5

Read signed 1100 (4-bit):
Step 1: Invert = 0011 = 3
Step 2: Add 1 = 0100 = 4
Step 3: Therefore 1100 = -4`
      },

      formulaMethod: {
        title: "Method 4: Weighted Sum Formula",
        formula: "Value = -x_{w-1} √ó 2^{w-1} + Œ£(x·µ¢ √ó 2‚Å±)",
        example: `11111011 (8-bit):
= -1√ó2‚Å∑ + 1√ó2‚Å∂ + 1√ó2‚Åµ + 1√ó2‚Å¥ + 1√ó2¬≥ + 0√ó2¬≤ + 1√ó2¬π + 1√ó2‚Å∞
= -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1
= -128 + 123
= -5 ‚úì`
      },

      calculatorFormula: {
        title: "Calculator Implementation",
        code: `function toTwosComplement(value, bits) {
  if (value >= 0) {
    return value;  // Positive: direct representation
  }
  // Negative: 2^n + value
  return Math.pow(2, bits) + value;
}

// Example: toTwosComplement(-5, 8)
// = 256 + (-5) = 251 = 0xFB = 11111011‚ÇÇ`
      }
    },

    {
      id: "sign-extension",
      title: "Sign Extension",
      icon: "üìè",
      explanation: `Sign extension is converting a signed integer from a smaller bit width to a larger one while preserving its value.

For UNSIGNED numbers: Add leading zeros (zero extension)
‚Ä¢ 8-bit 1001 ‚Üí 16-bit: 0000 0000 0000 1001

For SIGNED numbers: Copy the SIGN BIT to fill new positions
‚Ä¢ 8-bit 1001 (-7) ‚Üí 16-bit: 1111 1111 1111 1001 (-7)
‚Ä¢ 8-bit 0111 (7) ‚Üí 16-bit: 0000 0000 0000 0111 (7)`,

      whyItWorks: `Why sign extension preserves value:
The sign bit has weight -2^{w-1}. When extending:
‚Ä¢ Original: -1 √ó 2^{w-1}
‚Ä¢ Extended: -1 √ó 2^{W-1} + 1 √ó (2^{W-1} - 2^{w-1})
‚Ä¢ The added 1s contribute: 2^{W-1} - 2^{w-1}
‚Ä¢ Net effect: value is unchanged!`,

      examples: {
        title: "Sign Extension Examples",
        table: [
          { original: "1001 (4-bit)", value: "-7", extended: "1111 1001 (8-bit)", newValue: "-7" },
          { original: "0111 (4-bit)", value: "+7", extended: "0000 0111 (8-bit)", newValue: "+7" },
          { original: "1111 1011 (8-bit)", value: "-5", extended: "1111 1111 1111 1011 (16-bit)", newValue: "-5" },
          { original: "0000 0101 (8-bit)", value: "+5", extended: "0000 0000 0000 0101 (16-bit)", newValue: "+5" }
        ]
      },

      assemblyInstructions: {
        title: "x86 Sign Extension Instructions",
        instructions: [
          { inst: "CBW", description: "Convert Byte to Word", effect: "AL (8-bit) ‚Üí AX (16-bit)" },
          { inst: "CWD", description: "Convert Word to Doubleword", effect: "AX (16-bit) ‚Üí DX:AX (32-bit)" },
          { inst: "CWDE", description: "Convert Word to Doubleword Extended", effect: "AX (16-bit) ‚Üí EAX (32-bit)" },
          { inst: "CDQ", description: "Convert Doubleword to Quadword", effect: "EAX (32-bit) ‚Üí EDX:EAX (64-bit)" },
          { inst: "MOVSX", description: "Move with Sign Extension", effect: "Sign extend any source to destination" }
        ],
        example: `MOV AL, -5      ; AL = 0xFB (11111011)
CBW             ; AX = 0xFFFB (11111111 11111011)
                ; Sign bit (1) copied to AH

MOV AX, -5      ; AX = 0xFFFB
CWD             ; DX = 0xFFFF, AX = 0xFFFB
                ; Sign bit copied to DX`
      },

      truncation: {
        title: "Truncation (Reducing Bit Width)",
        explanation: `When truncating a w-bit number to k bits, we drop the high-order (w-k) bits.

This can alter the value - it's a form of overflow!`,
        example: `0x00FF (16-bit) = 255
Truncate to 8-bit: 0xFF = -1 (as signed!) ‚úó

0x1234 (16-bit) = 4660
Truncate to 8-bit: 0x34 = 52 ‚úì (just lost high bits)

Truncation formula: B2U_k([x_{k-1},...,x_0]) = B2U_w([x_{w-1},...,x_0]) mod 2^k`,
        warning: "Be careful truncating signed values - can change sign!"
      }
    },

    {
      id: "unsigned-arithmetic",
      title: "Unsigned Integer Arithmetic",
      icon: "‚ûï",
      explanation: `Unsigned arithmetic follows modular arithmetic (mod 2 ∑).

When a result requires more than w bits, the excess is discarded (truncated).`,

      addition: {
        title: "Unsigned Addition",
        formula: "x +·µ§ y = (x + y) mod 2 ∑",
        operation: "Add bit patterns as unsigned, discard carry out",
        example: `4-bit addition: 11 + 6
  1011 (11)
+ 0110 (6)
--------
 10001 (17)

Keep only 4 bits: 0001 (1)

Because: 11 + 6 = 17, 17 mod 16 = 1`,
        overflow: "Overflow occurs when carry out = 1 (true sum ‚â• 2 ∑)"
      },

      subtraction: {
        title: "Unsigned Subtraction",
        formula: "x -·µ§ y = (x - y) mod 2 ∑",
        operation: "Add two's complement of subtrahend, discard borrow",
        example: `4-bit subtraction: 4 - 7
  0100 (4)
+ 1001 (-7 in two's complement, or +9 unsigned)
--------
  1101 (13)

Because: 4 - 7 = -3, -3 mod 16 = 13`,
        overflow: "Overflow occurs when result > minuend (need to borrow)"
      },

      overflowDetection: {
        title: "Detecting Unsigned Overflow",
        addition: "CF (Carry Flag) = 1 when carry out of MSB occurs",
        subtraction: "CF = 1 when a borrow is needed",
        summary: "For unsigned: CF indicates overflow"
      },

      modularVisualization: {
        title: "Modular Arithmetic Visualization",
        description: "Unsigned arithmetic wraps around like a clock:",
        diagram: `
        2 ∑-1
          ‚Üë
    2 ∑-2 ‚Üê ‚Üí 0
          ‚Üì
          1
        `
      }
    },

    {
      id: "signed-arithmetic",
      title: "Signed (Two's Complement) Arithmetic",
      icon: "‚ûï‚ûñ",
      explanation: `Signed arithmetic uses the same hardware as unsigned! The bit patterns are identical - only the interpretation differs.

Addition formula: x +‚Çú y = U2T[(x + y) mod 2 ∑]

Subtract by adding negative: x - y = x + (-y)`,

      additionExamples: {
        title: "4-bit Signed Addition Examples",
        cases: [
          { x: "-8", y: "5", binary: "1000 + 0101", result: "1101 (-3)", case: "Case 2: Negative + Positive, no overflow" },
          { x: "-8", y: "-5", binary: "1000 + 1011", result: "0011 (3)", case: "Case 1: Negative overflow! (-13 needs 5 bits)" },
          { x: "2", y: "5", binary: "0010 + 0101", result: "0111 (7)", case: "Case 3: Positive + Positive, no overflow" },
          { x: "5", y: "5", binary: "0101 + 0101", result: "1010 (-6)", case: "Case 4: Positive overflow! (10 > 7)" }
        ]
      },

      overflowCases: {
        title: "Four Cases in Signed Addition",
        case1: { name: "Case 1: Negative + Negative = Positive", result: "NEGATIVE OVERFLOW", of: "OF = 1" },
        case2: { name: "Case 2: Negative + Positive", result: "Always correct", of: "OF = 0" },
        case3: { name: "Case 3: Positive + Positive = Negative", result: "POSITIVE OVERFLOW", of: "OF = 1" },
        case4: { name: "Case 4: Any other result", result: "No overflow", of: "OF = 0" }
      },

      overflowDetection: {
        title: "Detecting Signed Overflow (OF)",
        rule: "OF = 1 when:",
        conditions: [
          "Positive + Positive = Negative, OR",
          "Negative + Negative = Positive"
        ],
        formula: "OF = carry_in_to_MSB XOR carry_out_of_MSB",
        important: "For signed: OF (not CF) indicates overflow!"
      },

      subtraction: {
        title: "Signed Subtraction",
        method: "a - b = a + (-b)",
        example: `25 - 5 = 20 (6-bit)
  01 1001  (25)
+ 11 1011  (-5, two's complement)
-----------
    101 0100  
Truncate to 6 bits: 01 0100 = 20 ‚úì`,
        negation: "To negate: invert all bits and add 1"
      },

      cfVsOf: {
        title: "CF vs OF: The Critical Difference",
        comparison: [
          { flag: "CF (Carry Flag)", for: "UNSIGNED arithmetic", when: "Carry out of MSB or borrow needed" },
          { flag: "OF (Overflow Flag)", for: "SIGNED arithmetic", when: "Sign changes incorrectly" }
        ],
        examTip: "‚ö†Ô∏è EXAM TIP: Know when to check CF (unsigned) vs OF (signed)! They're different!"
      }
    },

    {
      id: "multiplication-division",
      title: "Multiplication and Division by Powers of 2",
      icon: "‚úñÔ∏è‚ûó",
      explanation: `Multiplication and division by powers of 2 can be done much faster using shift operations.`,

      multiplication: {
        title: "Multiplication by Powers of 2",
        rule: "x √ó 2·µè = x << k",
        explanation: "Shifting left by k bits multiplies by 2·µè",
        examples: [
          { operation: "7 √ó 2", binary: "00000111 << 1", result: "00001110 (14)" },
          { operation: "7 √ó 8", binary: "00000111 << 3", result: "00111000 (56)" },
          { operation: "3 √ó 4", binary: "00000011 << 2", result: "00001100 (12)" }
        ],
        overflowWarning: "If significant bits shift out, overflow occurs!"
      },

      unsignedDivision: {
        title: "Unsigned Division by Powers of 2",
        rule: "x √∑ 2·µè = x >> k (logical shift)",
        explanation: "Logical shift right fills with zeros",
        examples: [
          { operation: "42 √∑ 2", binary: "00101010 SHR 1", result: "00010101 (21)" },
          { operation: "42 √∑ 8", binary: "00101010 SHR 3", result: "00000101 (5)" }
        ],
        rounding: "Integer division truncates toward 0 (discards fraction)"
      },

      signedDivision: {
        title: "Signed Division by Powers of 2",
        rule: "x √∑ 2·µè requires arithmetic shift with bias for negatives",
        problem: `Problem: SAR rounds toward -‚àû, but we need toward 0
Example: -5 √∑ 2 should be -2, not -3`,
        solution: `Solution: Add bias before shifting if x < 0
Bias = 2·µè - 1 where k = shift amount`,
        examples: [
          { operation: "-5 √∑ 2", steps: "(1011 + 0001) SAR 1 = 1100 SAR 1 = 1110 (-2)", result: "-2 ‚úì" },
          { operation: "-5 √∑ 4", steps: "(1011 + 0011) SAR 2 = 1110 SAR 2 = 1111 (-1)", result: "-1 ‚úì" },
          { operation: "-11 √∑ 2 (5-bit)", steps: "(10101 + 00001) SAR 1 = 10110 SAR 1 = 11011 (-5)", result: "-5 ‚úì" }
        ]
      },

      performanceComparison: {
        title: "Performance Comparison",
        operations: [
          { operation: "Addition", cycles: "1-2 cycles" },
          { operation: "Shift", cycles: "1 cycle" },
          { operation: "Multiplication", cycles: "5-10 cycles" },
          { operation: "Division", cycles: "20-39 cycles" }
        ],
        recommendation: "Always use shifts for multiply/divide by powers of 2!"
      }
    },

    {
      id: "conversion-between-reps",
      title: "Converting Between Signed and Unsigned",
      icon: "üîÑ",
      explanation: `The same bit pattern can be interpreted as signed or unsigned, giving different values.`,

      formulas: {
        title: "Conversion Formulas",
        signedToUnsigned: {
          formula: "T2U(x) = x + 2 ∑ when x < 0, else x",
          explanation: "Add 2 ∑ to negative signed numbers",
          example: "T2U(-5, 8-bit) = -5 + 256 = 251 = 0xFB"
        },
        unsignedToSigned: {
          formula: "U2T(u) = u - 2 ∑ when u ‚â• 2 ∑‚Åª¬π, else u",
          explanation: "Subtract 2 ∑ from large unsigned values",
          example: "U2T(251, 8-bit) = 251 - 256 = -5"
        }
      },

      visualization: {
        title: "Visualizing the Conversion",
        description: "The conversion is a shift on the number line:",
        diagram: `
        UNSIGNED                    SIGNED
    0 -------- 2^{w-1} -------- 2^w-1    0 -------- 2^{w-1}
         |                            |         |
    0 ----+ 2^{w-1}                   -2^{w-1} ----+ 0
        '- w-1 bits ->'               '<- w-1 bits -'
        
Values 0 to 2^{w-1}-1 have same representation.
Values 2^{w-1} to 2^w-1 (unsigned) map to -2^{w-1} to -1 (signed).
        `
      },

      cProgramming: {
        title: "In C/C++ Programming",
        implicitCast: {
          description: "Implicit casting changes interpretation",
          example: `short int v = -12345;
unsigned short uv = v;
// v = 0xCFC7 (signed: -12345)
// uv = 0xCFC7 (unsigned: 53191)`
        },
        comparisonTrap: {
          description: "Mixing signed and unsigned is dangerous!",
          example: `int i = -1;
unsigned int u = 0;
if (i < u)  // FALSE! -1 is converted to UINT_MAX
    printf("i is less");  // Never prints!`
        }
      },

      shortcutReading: {
        title: "Shortcut: Reading Signed Values",
        method: "For negative numbers (MSB = 1):",
        steps: [
          "1. Invert all bits",
          "2. Add 1", 
          "3. Read the positive value",
          "4. Add negative sign"
        ],
        example: `Read signed 0xFB (11111011):
1. Invert: 00000100
2. Add 1: 00000101 = 5
3. Therefore: 0xFB as signed = -5`
      }
    },

    {
      id: "floating-point-intro",
      title: "Floating Point Introduction",
      icon: "üî¨",
      explanation: `Floating point represents real numbers (with fractional parts) using a form of scientific notation.

Limitations of fixed-point binary:
‚Ä¢ Binary fractions can only represent numbers of form M √ó 2·¥±
‚Ä¢ Many decimal fractions (like 0.1) have no finite binary representation

IEEE 754 Standard provides:
‚Ä¢ Standardized representation across systems
‚Ä¢ Special values (infinity, NaN)
‚Ä¢ Gradual underflow for very small numbers`,

      binaryFractions: {
        title: "Binary Fractions",
        explanation: `Just like decimal has decimal points, binary has binary points:

Decimal: 123.45 = 1√ó100 + 2√ó10 + 3√ó1 + 4√ó0.1 + 5√ó0.01
Binary:  101.11 = 1√ó4 + 0√ó2 + 1√ó1 + 1√ó0.5 + 1√ó0.25 = 5.75

Bit positions after the point:
‚Ä¢ .1 = 1/2 = 0.5
‚Ä¢ .01 = 1/4 = 0.25
‚Ä¢ .001 = 1/8 = 0.125
‚Ä¢ .0001 = 1/16 = 0.0625`,
        conversionMethod: {
          title: "Converting Decimal Fraction to Binary",
          steps: [
            "1. Separate integer and fractional parts",
            "2. Convert integer using division by 2",
            "3. Convert fraction using multiplication by 2",
            "4. For fraction: multiply by 2, integer part is next bit, repeat with fraction"
          ],
          example: `Convert 5.625 to binary:

Integer (5): 101

Fraction (0.625):
0.625 √ó 2 = 1.25 ‚Üí bit 1, use 0.25
0.25  √ó 2 = 0.5  ‚Üí bit 0, use 0.5
0.5   √ó 2 = 1.0  ‚Üí bit 1, use 0.0 (done!)

Result: 101.101`
        }
      },

      ieee754Format: {
        title: "IEEE 754 Floating Point Format",
        representation: "Value = (-1)À¢ √ó 1.M √ó 2^(E-bias)",
        components: [
          { name: "Sign (S)", bits: 1, description: "0=positive, 1=negative" },
          { name: "Exponent (E)", bits: "8 or 11", description: "Biased exponent" },
          { name: "Mantissa/Significand (M)", bits: "23 or 52", description: "Fractional part (with implicit leading 1)" }
        ],
        precisions: {
          single: { bits: 32, expBits: 8, mantBits: 23, bias: 127 },
          double: { bits: 64, expBits: 11, mantBits: 52, bias: 1023 }
        }
      },

      specialValues: {
        title: "Special Values in IEEE 754",
        values: [
          { exp: "All 0s", frac: "0", value: "¬±0 (two representations of zero)" },
          { exp: "All 0s", frac: "Non-zero", value: "Denormalized (very small numbers)" },
          { exp: "1 to 2^k-2", frac: "Any", value: "Normalized numbers (most values)" },
          { exp: "All 1s", frac: "0", value: "¬±‚àû (infinity)" },
          { exp: "All 1s", frac: "Non-zero", value: "NaN (Not a Number)" }
        ]
      },

      exampleConversion: {
        title: "Example: Convert -6.625 to IEEE 754 Single Precision",
        steps: [
          "Step 1: Convert to binary: 6.625 = 110.101",
          "Step 2: Normalize: 110.101 = 1.10101 √ó 2¬≤",
          "Step 3: Extract fields:",
          "  ‚Ä¢ Sign S = 1 (negative)",
          "  ‚Ä¢ Exponent E = 2 + 127 = 129 = 10000001",
          "  ‚Ä¢ Mantissa M = 10101000000000000000000 (23 bits)",
          "Step 4: Combine: 1 10000001 10101000000000000000000",
          "Result: 0xC0D40000"
        ]
      }
    },

    {
      id: "practice-problems",
      title: "Practice Problems with Solutions",
      icon: "üìù",
      explanation: "Test your understanding with these practice problems.",

      problems: [
        {
          question: "Convert 219 to binary and hexadecimal",
          solution: `Binary: 11011011
Hex: 0xDB

Work:
219 √∑ 2 = 109 r 1
109 √∑ 2 = 54  r 1
54  √∑ 2 = 27  r 0
27  √∑ 2 = 13  r 1
13  √∑ 2 = 6   r 1
6   √∑ 2 = 3   r 0
3   √∑ 2 = 1   r 1
1   √∑ 2 = 0   r 1
Read bottom to top: 11011011

Hex: 1101=D, 1011=B ‚Üí 0xDB`
        },
        {
          question: "Convert -42 to 8-bit two's complement",
          solution: `Step 1: 42 in binary = 00101010
Step 2: Invert = 11010101
Step 3: Add 1 = 11010110

Result: 11010110‚ÇÇ = 0xD6

Check: 42 + (-42) = 0
00101010 + 11010110 = 00000000 (with carry out) ‚úì`
        },
        {
          question: "What is 0x8A interpreted as 8-bit signed?",
          solution: `0x8A = 10001010 (binary)
MSB is 1, so negative.

Shortcut:
Invert: 01110101
Add 1:  01110110 = 118
Therefore: -118

Formula check:
-128 + 8 + 2 = -118 ‚úì`
        },
        {
          question: "Calculate 0x69 & 0x55",
          solution: `  01101001 (0x69)
& 01010101 (0x55)
= 01000001 (0x41)

Result: 0x41 = 65`
        },
        {
          question: "Sign extend 0x8A (8-bit) to 16-bit",
          solution: `0x8A = 10001010 (MSB is 1, negative)
Sign extension: copy 1s to high byte

Result: 11111111 10001010 = 0xFF8A

Value check:
8-bit: 0x8A = -128 + 8 + 2 = -118
16-bit: 0xFF8A = -32768 + 32768 - 128 + 8 + 2 = -118 ‚úì`
        },
        {
          question: "How is 0x12345678 stored in little-endian?",
          solution: `Little-endian: least significant byte at lowest address

0x12345678 broken into bytes:
0x78 (LSB), 0x56, 0x34, 0x12 (MSB)

Memory layout:
Address 0x100: 0x78
Address 0x101: 0x56
Address 0x102: 0x34
Address 0x103: 0x12`
        },
        {
          question: "Calculate 5 + (-3) in 4-bit two's complement",
          solution: `5 = 0101
-3 = 1101 (invert 0011 + 1)

  0101 (5)
+ 1101 (-3)
--------
 10010

Discard carry: 0010 = 2 ‚úì`
        },
        {
          question: "Does (-8) + (-5) overflow in 4-bit signed?",
          solution: `-8 = 1000
-5 = 1011

  1000
+ 1011
------
 10011 ‚Üí 0011 (3)

Result is positive, but both inputs were negative!
This is NEGATIVE OVERFLOW (OF = 1)

True sum -13 requires 5 bits (minimum -8 to +7 in 4-bit)`
        }
      ],

      examTips: [
        "Always check if MSB indicates sign for signed interpretation",
        "For hex to binary, write out all 4 bits - don't skip leading zeros within the nibble",
        "Two's complement range is always asymmetric: one more negative than positive",
        "CF is for unsigned overflow, OF is for signed overflow - don't confuse them!",
        "x86 is little-endian: remember 'low byte at low address'",
        "Sign extension copies the sign bit; zero extension fills with zeros"
      ]
    }
  ]
};

// ============================================================================
// LECTURE 3: FLOATING POINT
// ============================================================================
const lecture3Content = {
  title: "Lecture 3: Floating Point Representation",
  description: "How computers store and calculate with decimal numbers using IEEE 754 standard.",
  
  sections: [
    {
      id: "binary-fractions",
      title: "Binary Fractions",
      icon: "üî¢",
      explanation: `Just like decimal has a decimal point, binary has a binary point.

Decimal: 123.45 = 1√ó100 + 2√ó10 + 3√ó1 + 4√ó0.1 + 5√ó0.01
Binary:  101.11 = 1√ó4 + 0√ó2 + 1√ó1 + 1√ó0.5 + 1√ó0.25 = 5.75

Bit positions after the point:
.1 = 1/2 = 0.5
.01 = 1/4 = 0.25
.001 = 1/8 = 0.125
.0001 = 1/16 = 0.0625`,
      
      conversionMethod: {
        title: "Converting Decimal Fraction to Binary",
        steps: [
          "1. Separate integer and fractional parts",
          "2. Convert integer part using division by 2",
          "3. Convert fractional part using multiplication by 2",
          "4. For fraction: multiply by 2, take integer part as next bit, repeat with fraction"
        ],
        example: `Convert 5.625 to binary:

Integer part (5): 101

Fractional part (0.625):
0.625 √ó 2 = 1.25  ‚Üí bit 1, use 0.25
0.25  √ó 2 = 0.5   ‚Üí bit 0, use 0.5
0.5   √ó 2 = 1.0   ‚Üí bit 1, use 0.0 (done!)

Result: 101.101`
      }
    },
    {
      id: "ieee754",
      title: "IEEE 754 Floating Point Standard",
      icon: "üî¨",
      explanation: `IEEE 754 is the standard for floating point representation. It uses scientific notation in binary.

Scientific Notation in Decimal: 6.022 √ó 10¬≤¬≥
Scientific Notation in Binary:  1.101 √ó 2¬≥

The format has three parts:
1. SIGN (1 bit): 0=positive, 1=negative
2. EXPONENT: Stored with a "bias" to make it unsigned
3. MANTISSA (Significand): The fractional part after the leading 1`,
      
      singlePrecision: {
        title: "Single Precision (32-bit)",
        layout: `
[31] [30-23] [22-0]
Sign Exponent Mantissa
  1    8 bits   23 bits
        `,
        formula: `Value = (-1)^S √ó 1.M √ó 2^(E-127)

Where:
- S = sign bit (0 or 1)
- E = exponent (8 bits, biased by 127)
- M = mantissa (23 bits)
- 1. = implicit leading 1 (not stored)`,
        bias: 127,
        exponentRange: "E=1 to 254 (0 and 255 are special)",
        example: `Convert -6.625 to IEEE 754 single precision:

Step 1: Convert to binary
6.625 = 110.101

Step 2: Normalize (move binary point to after first 1)
110.101 = 1.10101 √ó 2¬≤

Step 3: Extract fields
Sign S = 1 (negative)
Exponent E = 2 + 127 = 129 = 10000001
Mantissa M = 10101000000000000000000 (23 bits)

Step 4: Combine
1 10000001 10101000000000000000000

Hex: 0xC0D40000`
      },
      
      doublePrecision: {
        title: "Double Precision (64-bit)",
        layout: `
[63] [62-52] [51-0]
Sign Exponent  Mantissa
  1    11 bits  52 bits
        `,
        formula: `Value = (-1)^S √ó 1.M √ó 2^(E-1023)

Where:
- S = sign bit
- E = exponent (11 bits, biased by 1023)
- M = mantissa (52 bits)`,
        bias: 1023,
        exponentRange: "E=1 to 2046 (0 and 2047 are special)"
      },
      
      specialValues: {
        title: "Special Values",
        zero: "E=0, M=0: Zero (+0 or -0 based on sign)",
        denormalized: "E=0, M‚â†0: Denormalized numbers (very small)",
        infinity: "E=all 1s, M=0: Infinity (+‚àû or -‚àû)",
        nan: "E=all 1s, M‚â†0: Not a Number (NaN)"
      },
      
      calculatorFormulas: {
        title: "Calculator Implementation",
        code: `function floatToIEEE754(value) {
  // Create buffer and view
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setFloat32(0, value);
  const bits = view.getUint32(0);
  
  // Extract fields
  const sign = (bits >> 31) & 1;
  const exponent = (bits >> 23) & 0xFF;
  const mantissa = bits & 0x7FFFFF;
  
  // Calculate actual value
  const actualExponent = exponent - 127;
  const mantissaValue = 1 + (mantissa / Math.pow(2, 23));
  const finalValue = Math.pow(-1, sign) * mantissaValue * Math.pow(2, actualExponent);
  
  return { sign, exponent, actualExponent, mantissa, bits, finalValue };
}`
      }
    }
  ]
};

// ============================================================================
// LECTURE 4: ASSEMBLY BASICS
// ============================================================================
const lecture4Content = {
  title: "Lecture 4: Assembly Language Basics",
  description: "x86 architecture, registers, instructions, and program structure.",
  
  sections: [
    {
      id: "registers",
      title: "CPU Registers",
      icon: "üì¶",
      explanation: "Registers are super-fast storage locations inside the CPU. x86 has several types.",
      
      generalPurpose: {
        title: "General Purpose Registers (32-bit)",
        registers: {
          EAX: {
            name: "Accumulator",
            usage: "Arithmetic operations, function return values",
            parts: "AH (high byte), AL (low byte)"
          },
          EBX: {
            name: "Base",
            usage: "Data pointer, addressing memory",
            parts: "BH, BL"
          },
          ECX: {
            name: "Count",
            usage: "Loop counter, string operations, shift count",
            parts: "CH, CL"
          },
          EDX: {
            name: "Data",
            usage: "I/O operations, multiply/divide high bits",
            parts: "DH, DL"
          }
        }
      },
      
      indexPointer: {
        title: "Index and Pointer Registers",
        registers: {
          ESI: { name: "Source Index", usage: "Source pointer for string/memory operations" },
          EDI: { name: "Destination Index", usage: "Destination pointer for string/memory operations" },
          ESP: { name: "Stack Pointer", usage: "Points to top of stack" },
          EBP: { name: "Base Pointer", usage: "Stack frame base, function parameters" }
        }
      },
      
      segment: {
        title: "Segment Registers (16-bit)",
        registers: {
          CS: { name: "Code Segment", usage: "Where program code is stored" },
          DS: { name: "Data Segment", usage: "Default data segment" },
          SS: { name: "Stack Segment", usage: "Where stack is stored" },
          ES: { name: "Extra Segment", usage: "Additional data segment" }
        }
      },
      
      special: {
        title: "Special Registers",
        registers: {
          EIP: { name: "Instruction Pointer", usage: "Address of next instruction to execute" },
          EFLAGS: { name: "Flags Register", usage: "Status and control flags" }
        }
      },
      
      partialRegisters: {
        title: "Accessing Partial Registers",
        explanation: `EAX (32-bit) can be accessed in parts:
- AX = lower 16 bits of EAX
- AH = upper 8 bits of AX
- AL = lower 8 bits of AX

Example:
MOV EAX, 0x12345678  ; EAX = 0x12345678
MOV AX, 0xABCD       ; EAX = 0x1234ABCD (upper 16 bits unchanged)
MOV AL, 0xFF         ; EAX = 0x1234ABFF (only low byte changed)`
      }
    },
    {
      id: "flags",
      title: "EFLAGS Register",
      icon: "üö©",
      explanation: "The flags register contains status bits that reflect the result of operations.",
      
      importantFlags: {
        CF: {
          name: "Carry Flag",
          description: "Set when unsigned arithmetic overflows",
          example: "255 + 1 = 0 with CF=1"
        },
        ZF: {
          name: "Zero Flag", 
          description: "Set when result is zero",
          example: "SUB EAX, EAX sets ZF=1"
        },
        SF: {
          name: "Sign Flag",
          description: "Set when result is negative (MSB=1)",
          example: "Result 0x80 sets SF=1"
        },
        OF: {
          name: "Overflow Flag",
          description: "Set when signed arithmetic overflows",
          example: "127 + 1 = -128 (overflow), OF=1"
        },
        PF: {
          name: "Parity Flag",
          description: "Set when low byte has even number of 1s",
          example: "0x03 (00000011) has PF=1"
        }
      },
      
      examTip: "Exam Tip: Know the difference! CF is for UNSIGNED overflow, OF is for SIGNED overflow."
    },
    {
      id: "mov-instruction",
      title: "MOV Instruction",
      icon: "üìã",
      explanation: "MOV copies data from source to destination. It does NOT affect flags.",
      
      syntax: "MOV destination, source",
      
      operandTypes: {
        title: "Types of Operands",
        types: [
          { type: "Immediate", example: "MOV EAX, 5", description: "Constant value" },
          { type: "Register", example: "MOV EAX, EBX", description: "From another register" },
          { type: "Memory", example: "MOV EAX, [mem]", description: "From memory location" }
        ]
      },
      
      restrictions: {
        title: "MOV Restrictions",
        list: [
          "‚ùå Cannot move memory to memory directly",
          "‚ùå Cannot move immediate to segment register directly",
          "‚ùå Both operands must be same size",
          "‚úì Can move register to register",
          "‚úì Can move immediate to register",
          "‚úì Can move register to memory",
          "‚úì Can move memory to register"
        ]
      },
      
      examples: [
        { code: "MOV EAX, 100", comment: "EAX = 100 (immediate)" },
        { code: "MOV EBX, EAX", comment: "EBX = EAX (register)" },
        { code: "MOV AL, [data]", comment: "AL = value at memory 'data'" },
        { code: "MOV [result], EAX", comment: "Store EAX to memory 'result'" }
      ]
    },
    {
      id: "arithmetic",
      title: "Arithmetic Instructions",
      icon: "‚ûï",
      
      add: {
        title: "ADD - Addition",
        syntax: "ADD destination, source",
        description: "destination = destination + source",
        flags: "Affects: OF, SF, ZF, AF, PF, CF",
        example: `ADD EAX, 5      ; EAX = EAX + 5
ADD AL, BL      ; AL = AL + BL
ADD [mem], 10   ; mem = mem + 10`
      },
      
      sub: {
        title: "SUB - Subtraction",
        syntax: "SUB destination, source",
        description: "destination = destination - source",
        flags: "Affects: OF, SF, ZF, AF, PF, CF",
        example: `SUB EAX, 10     ; EAX = EAX - 10
SUB AL, BL      ; AL = AL - BL`
      },
      
      incDec: {
        title: "INC and DEC",
        syntax: "INC operand / DEC operand",
        description: "Increment or decrement by 1",
        flags: "Affects: OF, SF, ZF, AF, PF. Does NOT affect CF!",
        example: `INC EAX         ; EAX = EAX + 1
DEC BL          ; BL = BL - 1`
      },
      
      mul: {
        title: "MUL - Unsigned Multiply",
        syntax: "MUL source",
        description: "Multiplies AL/AX/EAX by source",
        resultSizes: [
          "8-bit: AL √ó src ‚Üí AX",
          "16-bit: AX √ó src ‚Üí DX:AX",
          "32-bit: EAX √ó src ‚Üí EDX:EAX"
        ],
        example: `MOV AL, 5
MOV BL, 10
MUL BL          ; AX = 5 √ó 10 = 50`
      },
      
      div: {
        title: "DIV - Unsigned Divide",
        syntax: "DIV source",
        description: "Divides AX/DX:AX/EDX:EAX by source",
        resultSizes: [
          "8-bit: AX √∑ src ‚Üí AL (quotient), AH (remainder)",
          "16-bit: DX:AX √∑ src ‚Üí AX (quotient), DX (remainder)",
          "32-bit: EDX:EAX √∑ src ‚Üí EAX (quotient), EDX (remainder)"
        ],
        example: `MOV AX, 100
MOV BL, 3
DIV BL          ; AL = 33 (quotient), AH = 1 (remainder)`
      }
    }
  ]
};

// ============================================================================
// LECTURE 5: I/O AND ADDRESSING MODES
// ============================================================================
const lecture5Content = {
  title: "Lecture 5: I/O and Addressing Modes",
  description: "DOS interrupts, INT 21h functions, and different ways to access memory.",
  
  sections: [
    {
      id: "interrupts",
      title: "INT 21h - The DOS Interrupt",
      icon: "üìû",
      explanation: `INT 21h is like a phone call to the operating system (DOS). Your program calls INT 21h to ask DOS to do something for you, like:
- Read a character from keyboard
- Display a character on screen
- Read a string of text
- Exit the program

Think of it as calling a service - you prepare what you need (set up registers), then make the call (INT 21h).`,
      
      analogy: "It's like calling a restaurant to order food. You tell them what you want (set AH to function number), provide your details (set other registers), then make the call (INT 21h).",
      
      whyItMatters: "In DOS assembly, INT 21h is the PRIMARY way to do input/output. You MUST know these functions!",
      
      howItWorks: {
        title: "How INT 21h Works",
        steps: [
          "1. Set AH to the function number (what you want DOS to do)",
          "2. Set other registers as needed for that function",
          "3. Execute INT 21h",
          "4. DOS performs the operation",
          "5. Results are returned in registers (usually AL)"
        ]
      },
      
      functions: {
        readChar: {
          fn: "01h",
          name: "Read Character with Echo",
          description: "Waits for a keypress, displays the character, returns ASCII in AL",
          input: "AH = 01h",
          output: "AL = ASCII code of key pressed",
          example: `MOV AH, 01h     ; Function: Read character
INT 21h         ; Wait for keypress
; AL now contains the ASCII code`
        },
        
        writeChar: {
          fn: "02h", 
          name: "Write Character",
          description: "Displays the character in DL on screen",
          input: "AH = 02h, DL = ASCII character to display",
          output: "None (character displayed)",
          example: `MOV AH, 02h     ; Function: Write character
MOV DL, 'A'     ; Character to display
INT 21h         ; Displays 'A' on screen`
        },
        
        writeString: {
          fn: "09h",
          name: "Display String",
          description: "Displays a '$'-terminated string",
          input: "AH = 09h, DS:DX = address of string (must end with '$')",
          output: "None (string displayed)",
          warning: "String MUST end with '$' character!",
          example: `MSG DB 'Hello$'  ; String with terminator

MOV AH, 09h      ; Function: Display string
LEA DX, MSG      ; Load address of message
INT 21h          ; Displays 'Hello'`
        },
        
        readString: {
          fn: "0Ah",
          name: "Buffered Input",
          description: "Reads a string of characters into a buffer",
          input: "AH = 0Ah, DS:DX = address of input buffer",
          output: "Buffer filled with user input",
          bufferStructure: `Input buffer structure:
[offset 0] = maximum characters to read
[offset 1] = actual characters read (filled by DOS)
[offset 2+] = the actual characters`,
          example: `MAXLEN DB 20      ; Max 20 chars
ACTLEN DB ?       ; DOS fills this
BUFFER DB 20 DUP('$')  ; Space for characters
INPUT_BUF DB MAXLEN, ?, 20 DUP('$')

MOV AH, 0Ah       ; Function: Buffered input
LEA DX, INPUT_BUF ; Load buffer address
INT 21h           ; Wait for user input`
        },
        
        exit: {
          fn: "4Ch",
          name: "Exit Program",
          description: "Ends the program and returns to DOS",
          input: "AH = 4Ch, AL = return code (0 = success)",
          output: "Program terminates",
          example: `MOV AH, 4Ch     ; Function: Exit
MOV AL, 00h     ; Return code 0 (success)
INT 21h         ; Program ends`
        }
      }
    },
    {
      id: "addressing-modes",
      title: "Addressing Modes",
      icon: "üéØ",
      explanation: "Addressing modes are different ways to specify where data is located.",
      
      modes: {
        immediate: {
          name: "Immediate Addressing",
          syntax: "MOV AX, 5",
          description: "The operand IS the value (constant)",
          example: "MOV AX, 100    ; AX = 100",
          speed: "Fastest - no memory access needed"
        },
        
        register: {
          name: "Register Addressing",
          syntax: "MOV AX, BX",
          description: "Operand is in a register",
          example: "MOV AX, BX     ; Copy BX to AX",
          speed: "Very fast - register access"
        },
        
        direct: {
          name: "Direct Addressing",
          syntax: "MOV AX, [variable]",
          description: "Operand is at a specific memory address",
          example: `MOV AX, [count]    ; Load from memory 'count'
MOV [result], BX   ; Store to memory 'result'`,
          note: "Uses variable name or explicit address"
        },
        
        registerIndirect: {
          name: "Register Indirect",
          syntax: "MOV AX, [SI]",
          description: "Memory address is in a register",
          validRegisters: "Only BX, SI, DI, BP can be used",
          example: `MOV SI, OFFSET array
MOV AX, [SI]     ; Load from address in SI
INC SI           ; Move to next element`,
          useCase: "Array traversal, pointers"
        },
        
        based: {
          name: "Based Addressing",
          syntax: "MOV AX, [BX + 4]",
          description: "Base register + constant displacement",
          validRegisters: "BX or BP",
          example: `MOV BX, OFFSET array
MOV AX, [BX + 4]  ; 4th element of array`,
          useCase: "Accessing structure fields, array elements"
        },
        
        indexed: {
          name: "Indexed Addressing", 
          syntax: "MOV AX, [SI + 4]",
          description: "Index register + constant displacement",
          validRegisters: "SI or DI",
          example: `MOV SI, 0
MOV AX, [array + SI]  ; array[SI]`
        },
        
        basedIndexed: {
          name: "Based Indexed",
          syntax: "MOV AX, [BX + SI]",
          description: "Base register + Index register",
          example: `MOV BX, OFFSET array
MOV SI, 4
MOV AX, [BX + SI]  ; array[4]`,
          useCase: "Two-dimensional arrays, structures with arrays"
        },
        
        basedIndexedDisp: {
          name: "Based Indexed with Displacement",
          syntax: "MOV AX, [BX + SI + 10]",
          description: "Base + Index + Constant offset",
          example: `MOV BX, OFFSET table
MOV SI, ROW_SIZE
MOV AX, [BX + SI + 5]  ; table[row][5]`
        }
      },
      
      comparisonTable: {
        title: "Quick Reference Table",
        rows: [
          { mode: "Immediate", syntax: "MOV AX, 5", addressing: "Value is in instruction" },
          { mode: "Register", syntax: "MOV AX, BX", addressing: "Value in register" },
          { mode: "Direct", syntax: "MOV AX, [var]", addressing: "Address is in instruction" },
          { mode: "Register Indirect", syntax: "MOV AX, [SI]", addressing: "Address in SI/BX/DI/BP" },
          { mode: "Based", syntax: "MOV AX, [BX+4]", addressing: "BX/BP + displacement" },
          { mode: "Indexed", syntax: "MOV AX, [SI+4]", addressing: "SI/DI + displacement" },
          { mode: "Based Indexed", syntax: "MOV AX, [BX+SI]", addressing: "BX/BP + SI/DI" }
        ]
      }
    },
    {
      id: "ascii-conversions",
      title: "ASCII Conversions",
      icon: "üîÑ",
      explanation: "When working with numbers in DOS, you need to convert between numeric values and ASCII characters.",
      
      digitToASCII: {
        title: "Digit ‚Üí ASCII",
        formula: "ASCII = Digit + 30h",
        explanation: "Add 30h (48 decimal) to convert 0-9 to '0'-'9'",
        examples: [
          { digit: "0", hex: "00h + 30h = 30h", ascii: "'0'" },
          { digit: "5", hex: "05h + 30h = 35h", ascii: "'5'" },
          { digit: "9", hex: "09h + 30h = 39h", ascii: "'9'" }
        ],
        code: `MOV AL, 5       ; Number 5
ADD AL, 30h     ; Convert to ASCII
MOV DL, AL      ; DL = '5'
MOV AH, 02h     ; Display character
INT 21h         ; Shows '5' on screen`
      },
      
      asciiToDigit: {
        title: "ASCII ‚Üí Digit",
        formula: "Digit = ASCII - 30h",
        explanation: "Subtract 30h to convert '0'-'9' to 0-9",
        examples: [
          { ascii: "'0'", hex: "30h - 30h = 00h", digit: "0" },
          { ascii: "'7'", hex: "37h - 30h = 07h", digit: "7" }
        ],
        code: `MOV AL, '7'     ; ASCII '7'
SUB AL, 30h     ; Convert to digit
; AL now contains 7`
      },
      
      twoDigitNumber: {
        title: "Display Two-Digit Number (0-99)",
        explanation: "To display a two-digit number like 42:",
        algorithm: [
          "1. Divide number by 10",
          "2. Quotient = tens digit, Remainder = ones digit",
          "3. Convert both to ASCII (add 30h)",
          "4. Display tens, then ones"
        ],
        code: `MOV AX, 42      ; Number to display
MOV BL, 10
DIV BL          ; AL = 4 (tens), AH = 2 (ones)

MOV BL, AH      ; Save ones digit
ADD AL, 30h     ; Tens to ASCII
MOV DL, AL
MOV AH, 02h
INT 21h         ; Display tens

MOV DL, BL
ADD DL, 30h     ; Ones to ASCII
MOV AH, 02h
INT 21h         ; Display ones`
      }
    },
    {
      id: "complete-programs",
      title: "Complete Program Examples",
      icon: "üìÑ",
      
      helloWorld: {
        title: "Hello World",
        code: `.MODEL SMALL
.STACK 100h

.DATA
    MSG DB 'Hello, World!', 0Dh, 0Ah, '$'

.CODE
MAIN PROC
    MOV AX, @DATA
    MOV DS, AX
    
    MOV AH, 09h
    LEA DX, MSG
    INT 21h
    
    MOV AH, 4Ch
    INT 21h
MAIN ENDP
END MAIN`
      },
      
      echoProgram: {
        title: "Echo Program (Type and see characters)",
        code: `.MODEL SMALL
.STACK 100h

.CODE
MAIN PROC
    MOV AH, 01h     ; Read character
    INT 21h         ; AL has character
    
    MOV DL, AL      ; Copy to DL for output
    MOV AH, 02h     ; Display character
    INT 21h
    
    MOV AH, 4Ch     ; Exit
    INT 21h
MAIN ENDP
END MAIN`
      },
      
      readAndDisplay: {
        title: "Read String and Display",
        code: `.MODEL SMALL
.STACK 100h

.DATA
    BUFFER DB 20        ; Max length
           DB ?         ; Actual length (filled by DOS)
           DB 20 DUP('$') ; Buffer space
    MSG1 DB 'Enter text: $'
    MSG2 DB 0Dh, 0Ah, 'You typed: $'

.CODE
MAIN PROC
    MOV AX, @DATA
    MOV DS, AX
    
    ; Display prompt
    MOV AH, 09h
    LEA DX, MSG1
    INT 21h
    
    ; Read input
    MOV AH, 0Ah
    LEA DX, BUFFER
    INT 21h
    
    ; Add $ terminator after input
    MOV BL, BUFFER+1    ; Get actual length
    XOR BH, BH
    MOV BYTE PTR [BUFFER+2+BX], '$'
    
    ; Display result message
    MOV AH, 09h
    LEA DX, MSG2
    INT 21h
    
    ; Display the input
    MOV AH, 09h
    LEA DX, BUFFER+2
    INT 21h
    
    MOV AH, 4Ch
    INT 21h
MAIN ENDP
END MAIN`
      }
    }
  ]
};

// Export all lectures
const lecturesData = [lecture1Content, lecture2Content, lecture3Content, lecture4Content, lecture5Content];


// Summary statistics
const lectureStats = {
  totalLectures: 5,
  totalPages: 328,
  lectures: [{"num": 1, "title": "Course Introduction and Overview of Computer Systems", "pages": 55}, {"num": 2, "title": "Representing Information", "pages": 100}, {"num": 3, "title": "Integer Arithmetic and Floating Point", "pages": 47}, {"num": 4, "title": "Assembly Language Basics", "pages": 65}, {"num": 5, "title": "I/O, Addressing Modes and Assembly Programming", "pages": 61}]
};






        // ============================================
        // NAVIGATION
        // ============================================
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.section).classList.add('active');
            });
        });

        // ============================================
        // LECTURE SYSTEM
        // ============================================
        let currentLecture = 0;

        function renderLecture(index) {
            const lecture = lecturesData[index];
            if (!lecture) return;

            let html = `
                <div class="card">
                    <div class="card-header">
                        <h3>${lecture.icon || 'üìö'} ${lecture.title}</h3>
                        <span>by OsaZain</span>
                    </div>
                    <div style="padding: 15px; background: rgba(74, 144, 217, 0.1); border-radius: 8px; margin-bottom: 20px;">
                        <p style="margin: 0; color: var(--text-muted);">${lecture.description || ''}</p>
                    </div>
            `;

            // Render sections
            if (lecture.sections) {
                lecture.sections.forEach(section => {
                    html += renderSection(section);
                });
            }

            html += '</div>';
            document.getElementById('lecture-content').innerHTML = html;
        }

        function renderSection(section) {
            let html = `<div class="lecture-section" style="margin-bottom: 30px; border-left: 3px solid var(--primary); padding-left: 20px;">`;
            html += `<h4 style="color: var(--primary); margin-bottom: 15px;">${section.icon || ''} ${section.title}</h4>`;
            
            if (section.explanation) {
                html += `<div class="section-explanation" style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px; white-space: pre-wrap;">${escapeHtml(section.explanation)}</div>`;
            }
            
            if (section.analogy) {
                html += `<div class="analogy-box" style="background: rgba(240, 173, 78, 0.1); border-left: 4px solid var(--accent); padding: 15px; margin: 15px 0; border-radius: 0 8px 8px 0;">
                    <strong style="color: var(--accent);">üí° Analogy:</strong> ${escapeHtml(section.analogy)}
                </div>`;
            }
            
            if (section.whyItMatters) {
                html += `<div class="why-box" style="background: rgba(92, 184, 92, 0.1); border-left: 4px solid var(--secondary); padding: 15px; margin: 15px 0; border-radius: 0 8px 8px 0;">
                    <strong style="color: var(--secondary);">üéØ Why It Matters:</strong> ${escapeHtml(section.whyItMatters)}
                </div>`;
            }
            
            if (section.formula) {
                html += `<div class="formula-box" style="background: rgba(155, 89, 182, 0.1); border: 1px solid rgba(155, 89, 182, 0.3); padding: 15px; margin: 15px 0; border-radius: 8px;">
                    <strong style="color: #9b59b6;">üìê Formula:</strong> <code style="background: var(--card-bg); padding: 2px 6px; border-radius: 4px;">${section.formula}</code>
                </div>`;
            }
            
            if (section.examples) {
                html += `<div class="examples-box" style="margin: 15px 0;"><strong style="color: var(--info);">üìã Examples:</strong>`;
                if (Array.isArray(section.examples)) {
                    html += `<ul style="margin: 10px 0; padding-left: 20px;">`;
                    section.examples.forEach(ex => {
                        html += `<li style="margin: 5px 0;">${JSON.stringify(ex)}</li>`;
                    });
                    html += `</ul>`;
                }
                html += `</div>`;
            }
            
            html += `</div>`;
            return html;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.querySelectorAll('.lecture-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.lecture-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLecture = parseInt(btn.dataset.lecture);
                renderLecture(currentLecture);
            });
        });

        // Initialize first lecture
        renderLecture(0);

        // ============================================
        // CALCULATOR SYSTEM
        // ============================================
        
        // Base Converter
        let currentBase = 'dec';
        document.querySelectorAll('.base-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.base-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentBase = tab.dataset.base;
                convertBase();
            });
        });

        document.getElementById('base-input').addEventListener('input', convertBase);
        document.getElementById('base-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') convertBase();
        });
        document.getElementById('base-calc-btn').addEventListener('click', convertBase);

        function convertBase() {
            const input = document.getElementById('base-input').value.trim();
            if (!input) {
                document.getElementById('out-dec').textContent = '-';
                document.getElementById('out-bin').textContent = '-';
                document.getElementById('out-hex').textContent = '-';
                document.getElementById('out-oct').textContent = '-';
                return;
            }

            let dec;
            try {
                switch(currentBase) {
                    case 'dec': dec = parseInt(input, 10); break;
                    case 'bin': dec = parseInt(input, 2); break;
                    case 'hex': dec = parseInt(input.replace('0x', ''), 16); break;
                    case 'oct': dec = parseInt(input, 8); break;
                }
            } catch(e) { return; }

            if (isNaN(dec)) return;

            document.getElementById('out-dec').textContent = dec.toString(10);
            document.getElementById('out-bin').textContent = dec.toString(2);
            document.getElementById('out-hex').textContent = '0x' + dec.toString(16).toUpperCase();
            document.getElementById('out-oct').textContent = dec.toString(8);

            // Generate formula explanation
            let explanation = `<div style="background: rgba(240, 173, 78, 0.1); padding: 15px; border-radius: 8px;">`;
            explanation += `<strong style="color: var(--accent);">üìê Conversion Formulas:</strong>`;
            explanation += `<div style="font-family: monospace; background: var(--bg); padding: 10px; margin: 10px 0; border-radius: 4px;">`;
            
            if (currentBase === 'dec') {
                // Decimal to other bases
                explanation += `<strong>Decimal ‚Üí Binary:</strong> Repeated division by 2<br>`;
                explanation += `<strong>Decimal ‚Üí Hex:</strong> Repeated division by 16<br>`;
                explanation += `</div><strong>Step-by-step for ${dec}:</strong><br>`;
                
                // Show division steps for binary
                let n = dec, steps = [];
                while (n > 0) {
                    steps.push(`${n} √∑ 2 = ${Math.floor(n/2)} remainder ${n%2}`);
                    n = Math.floor(n/2);
                }
                explanation += `<div style="font-family: monospace; font-size: 12px; margin: 5px 0;">`;
                explanation += steps.slice(0, 8).join('<br>');
                if (steps.length > 8) explanation += `<br>...`;
                explanation += `</div>`;
                explanation += `Read remainders <strong>bottom to top</strong>: ${dec.toString(2)}<br>`;
                
                // Hex conversion
                let hn = dec, hsteps = [];
                while (hn > 0) {
                    let rem = hn % 16;
                    hsteps.push(`${hn} √∑ 16 = ${Math.floor(hn/16)} remainder ${rem.toString(16).toUpperCase()}`);
                    hn = Math.floor(hn/16);
                }
                explanation += `<br><strong>Hex conversion:</strong><br>`;
                explanation += `<div style="font-family: monospace; font-size: 12px; margin: 5px 0;">`;
                explanation += hsteps.slice(0, 4).join('<br>');
                explanation += `</div>`;
                explanation += `Result: 0x${dec.toString(16).toUpperCase()}`;
                
            } else if (currentBase === 'bin') {
                // Binary to others
                const groups = dec.toString(2).match(/.{1,4}/g) || [dec.toString(2)];
                explanation += `<strong>Binary ‚Üí Hex:</strong> Group by 4 bits from right<br>`;
                explanation += `<strong>Binary ‚Üí Dec:</strong> Sum of (bit √ó 2<sup>position</sup>)<br>`;
                explanation += `</div><strong>Hex conversion:</strong> ${groups.join(' ')}<br>`;
                explanation += `Each group = 1 hex digit<br>`;
                explanation += `Result: 0x${dec.toString(16).toUpperCase()}`;
                
            } else if (currentBase === 'hex') {
                // Hex to others
                explanation += `<strong>Hex ‚Üí Binary:</strong> Each digit ‚Üí 4 bits<br>`;
                explanation += `<strong>Hex ‚Üí Dec:</strong> Sum of (digit √ó 16<sup>position</sup>)<br>`;
                explanation += `</div><strong>Decimal calculation:</strong><br>`;
                let calc = input.replace('0x', '');
                let total = 0, calcStr = [];
                for (let i = 0; i < calc.length; i++) {
                    let digit = parseInt(calc[calc.length - 1 - i], 16);
                    let value = digit * Math.pow(16, i);
                    total += value;
                    calcStr.push(`${digit}√ó16^${i}=${value}`);
                }
                explanation += calcStr.join(' + ') + ` = ${total}`;
            } else {
                explanation += `Convert to decimal first, then to other bases.`;
            }
            
            explanation += `</div>`;
            document.getElementById('base-explanation').innerHTML = explanation;
        }

        // IEEE 754 Converter
        function updateIEEE754() {
            const val = parseFloat(document.getElementById('ieee-input').value);
            if (isNaN(val)) return;

            const buffer = new ArrayBuffer(4);
            const floatView = new Float32Array(buffer);
            const intView = new Uint32Array(buffer);
            floatView[0] = val;
            const bits = intView[0];

            const sign = (bits >>> 31) & 0x1;
            const exponent = (bits >>> 23) & 0xFF;
            const mantissa = bits & 0x7FFFFF;

            document.getElementById('ieee-sign').textContent = sign;
            document.getElementById('ieee-exp').textContent = exponent + ' (biased: ' + (exponent - 127) + ')';
            document.getElementById('ieee-mant').textContent = '0x' + mantissa.toString(16).toUpperCase().padStart(6, '0');
            document.getElementById('ieee-hex').textContent = '0x' + bits.toString(16).toUpperCase().padStart(8, '0');
            document.getElementById('ieee-bin').textContent = bits.toString(2).padStart(32, '0').replace(/(\d{1})(\d{8})(\d{23})/, '$1 $2 $3');

            // Generate detailed formula explanation
            const actualExp = exponent === 0 ? "-126 (denormalized)" : (exponent - 127);
            const mantissaValue = 1 + (mantissa / Math.pow(2, 23));
            const calculatedValue = (sign ? -1 : 1) * Math.pow(2, parseInt(actualExp)) * (exponent === 0 ? (mantissa / Math.pow(2, 23)) : mantissaValue);
            
            document.getElementById('ieee-explanation').innerHTML = `
                <div style="background: rgba(74, 144, 217, 0.1); padding: 15px; border-radius: 8px; margin-top: 10px;">
                    <strong style="color: var(--primary);">üìê IEEE 754 Formula:</strong>
                    <div style="font-family: monospace; background: var(--bg); padding: 10px; margin: 10px 0; border-radius: 4px;">
                        Value = (-1)<sup>S</sup> √ó 1.M √ó 2<sup>(E-127)</sup>
                    </div>
                    <strong>Step-by-step:</strong><br>
                    1. <strong>Sign bit (S):</strong> ${sign} ‚Üí ${sign ? 'Negative' : 'Positive'}<br>
                    2. <strong>Exponent (E):</strong> ${exponent} ‚àí 127 = ${actualExp}<br>
                    3. <strong>Mantissa (M):</strong> 1.${mantissa.toString(2).padStart(23, '0')} = ${mantissaValue.toFixed(6)}<br>
                    4. <strong>Calculate:</strong> ${sign ? '-' : ''}1.${mantissa.toString(2).padStart(23, '0')} √ó 2<sup>${actualExp}</sup><br>
                    <strong>Result:</strong> ${calculatedValue.toFixed(6)} ‚âà ${val}
                </div>
            `;
        }
        document.getElementById('ieee-input').addEventListener('input', updateIEEE754);
        document.getElementById('ieee-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateIEEE754();
        });
        document.getElementById('ieee-calc-btn').addEventListener('click', updateIEEE754);

        // Two's Complement
        document.getElementById('twos-input').addEventListener('input', updateTwosComplement);
        document.getElementById('twos-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateTwosComplement();
        });
        document.getElementById('twos-bits').addEventListener('change', updateTwosComplement);
        document.getElementById('twos-calc-btn').addEventListener('click', updateTwosComplement);

        function updateTwosComplement() {
            const val = parseInt(document.getElementById('twos-input').value);
            const bits = parseInt(document.getElementById('twos-bits').value);
            if (isNaN(val)) return;

            const max = Math.pow(2, bits);
            const mask = max - 1;
            let unsigned = val & mask;
            
            document.getElementById('twos-bin').textContent = unsigned.toString(2).padStart(bits, '0');
            document.getElementById('twos-hex').textContent = '0x' + unsigned.toString(16).toUpperCase();
            document.getElementById('twos-dec').textContent = val;

            // Generate formula explanation
            const absVal = Math.abs(val);
            const absBinary = absVal.toString(2).padStart(bits, '0');
            const inverted = (max - 1 - absVal).toString(2).padStart(bits, '0');
            const twosComp = ((~absVal + 1) & mask).toString(2).padStart(bits, '0');
            
            let exp = `<div style="background: rgba(92, 184, 92, 0.1); padding: 15px; border-radius: 8px;">`;
            exp += `<strong style="color: var(--secondary);">üìê Two's Complement Formula:</strong>`;
            exp += `<div style="font-family: monospace; background: var(--bg); padding: 10px; margin: 10px 0; border-radius: 4px;">`;
            exp += `For N < 0: Representation = 2<sup>n</sup> + N<br>`;
            exp += `Range: -2<sup>n-1</sup> to 2<sup>n-1</sup> - 1`;
            exp += `</div>`;
            exp += `<strong>Range (${bits}-bit):</strong> ${-(max/2)} to ${(max/2)-1}<br><br>`;
            
            if (val < 0) {
                exp += `<strong>Step-by-step for ${val}:</strong><br>`;
                exp += `1. Absolute value: |${val}| = ${absVal}<br>`;
                exp += `2. Binary: ${absBinary}<br>`;
                exp += `3. Invert bits: ${inverted}<br>`;
                exp += `4. Add 1: ${twosComp}<br>`;
                exp += `<strong>Formula check:</strong> 2^${bits} + (${val}) = ${max} - ${absVal} = ${unsigned} = 0x${unsigned.toString(16).toUpperCase()}`;
            } else {
                exp += `<strong>Positive number:</strong> Direct binary representation<br>`;
                exp += `${val} = ${unsigned.toString(2).padStart(bits, '0')}`;
            }
            exp += `</div>`;
            document.getElementById('twos-explanation').innerHTML = exp;
        }

        // ASCII Converter
        function updateASCIIFromText() {
            const text = document.getElementById('ascii-text').value;
            if (!text) return;

            const codes = [];
            const hex = [];
            const bin = [];
            
            for (let char of text) {
                const code = char.charCodeAt(0);
                codes.push(code);
                hex.push('0x' + code.toString(16).toUpperCase().padStart(2, '0'));
                bin.push(code.toString(2).padStart(8, '0'));
            }

            document.getElementById('ascii-dec').textContent = codes.join(' ');
            document.getElementById('ascii-hex').textContent = hex.join(' ');
            document.getElementById('ascii-bin').textContent = bin.join(' ');
            document.getElementById('ascii-codes').value = codes.join(' ');
        }

        function updateASCIIFromCodes() {
            const codes = document.getElementById('ascii-codes').value.trim().split(/\s+/).map(c => parseInt(c)).filter(c => !isNaN(c));
            if (codes.length === 0) return;

            const text = String.fromCharCode(...codes);
            const hex = codes.map(c => '0x' + c.toString(16).toUpperCase().padStart(2, '0'));
            const bin = codes.map(c => c.toString(2).padStart(8, '0'));

            document.getElementById('ascii-text').value = text;
            document.getElementById('ascii-dec').textContent = codes.join(' ');
            document.getElementById('ascii-hex').textContent = hex.join(' ');
            document.getElementById('ascii-bin').textContent = bin.join(' ');
        }

        document.getElementById('ascii-text').addEventListener('input', updateASCIIFromText);
        document.getElementById('ascii-text').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateASCIIFromText();
        });
        document.getElementById('ascii-codes').addEventListener('input', updateASCIIFromCodes);
        document.getElementById('ascii-codes').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateASCIIFromCodes();
        });
        document.getElementById('ascii-calc-btn').addEventListener('click', function() {
            updateASCIIFromText();
            updateASCIIFromCodes();
        });

        // Bitwise Operations
        ['bit-a', 'bit-b'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('input', updateBitwise);
            el.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') updateBitwise();
            });
        });
        document.getElementById('bit-calc-btn').addEventListener('click', updateBitwise);

        function updateBitwise() {
            let a = parseInt(document.getElementById('bit-a').value.replace('0x', ''), 16) || 0;
            let b = parseInt(document.getElementById('bit-b').value.replace('0x', ''), 16) || 0;

            const and = (a & b) >>> 0;
            const or = (a | b) >>> 0;
            const xor = (a ^ b) >>> 0;
            const not = (~a) >>> 0;
            const shl = (a << 1) >>> 0;
            const shr = (a >>> 1) >>> 0;

            document.getElementById('bit-and').textContent = '0x' + and.toString(16).toUpperCase();
            document.getElementById('bit-or').textContent = '0x' + or.toString(16).toUpperCase();
            document.getElementById('bit-xor').textContent = '0x' + xor.toString(16).toUpperCase();
            document.getElementById('bit-not').textContent = '0x' + not.toString(16).toUpperCase();
            document.getElementById('bit-shl').textContent = '0x' + shl.toString(16).toUpperCase();
            document.getElementById('bit-shr').textContent = '0x' + shr.toString(16).toUpperCase();
        }

        // Address Calculator
        ['addr-seg', 'addr-off'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('input', updateAddress);
            el.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') updateAddress();
            });
        });
        document.getElementById('addr-calc-btn').addEventListener('click', updateAddress);

        function updateAddress() {
            const seg = parseInt(document.getElementById('addr-seg').value.replace('0x', ''), 16) || 0;
            const off = parseInt(document.getElementById('addr-off').value.replace('0x', ''), 16) || 0;

            const physical = ((seg << 4) + off) & 0xFFFFF;

            document.getElementById('addr-physical').textContent = '0x' + physical.toString(16).toUpperCase().padStart(5, '0');
            document.getElementById('addr-calc').textContent = `${seg} √ó 16 + ${off} = ${physical}`;
        }

        // ============================================
        // SIMULATOR SYSTEM
        // ============================================
        class CPUSimulator {
            constructor() {
                this.registers = {
                    AX: 0x0000, BX: 0x0000, CX: 0x0000, DX: 0x0000,
                    SI: 0x0000, DI: 0x0000, BP: 0x0000, SP: 0xFFFE,
                    CS: 0xF000, DS: 0x0000, SS: 0x0000, ES: 0x0000,
                    IP: 0x0000, FLAGS: 0x0002
                };
                this.selectedReg = null;
                this.history = [];
                this.flagBits = { CF: 0, PF: 2, AF: 4, ZF: 6, SF: 7, TF: 8, IF: 9, DF: 10, OF: 11 };
                this.saveState();
                this.attachListeners();
                this.updateDisplay();
            }

            saveState() {
                this.history.push(JSON.parse(JSON.stringify(this.registers)));
                if (this.history.length > 50) this.history.shift();
            }

            undo() {
                if (this.history.length > 1) {
                    this.history.pop();
                    this.registers = JSON.parse(JSON.stringify(this.history[this.history.length - 1]));
                    this.updateDisplay();
                }
            }

            reset() {
                this.registers = {
                    AX: 0x0000, BX: 0x0000, CX: 0x0000, DX: 0x0000,
                    SI: 0x0000, DI: 0x0000, BP: 0x0000, SP: 0xFFFE,
                    CS: 0xF000, DS: 0x0000, SS: 0x0000, ES: 0x0000,
                    IP: 0x0000, FLAGS: 0x0002
                };
                this.saveState();
                this.updateDisplay();
            }

            getFlag(flag) {
                return (this.registers.FLAGS >> this.flagBits[flag]) & 1;
            }

            setFlag(flag, value) {
                const bit = this.flagBits[flag];
                if (value) {
                    this.registers.FLAGS |= (1 << bit);
                } else {
                    this.registers.FLAGS &= ~(1 << bit);
                }
            }

            getHigh(reg) {
                return (this.registers[reg] >> 8) & 0xFF;
            }

            getLow(reg) {
                return this.registers[reg] & 0xFF;
            }

            setHigh(reg, val) {
                this.registers[reg] = ((val & 0xFF) << 8) | (this.registers[reg] & 0xFF);
            }

            setLow(reg, val) {
                this.registers[reg] = (this.registers[reg] & 0xFF00) | (val & 0xFF);
            }

            updateDisplay() {
                // Update all register displays
                ['AX', 'BX', 'CX', 'DX', 'SI', 'DI', 'BP', 'SP', 'CS', 'DS', 'SS', 'ES', 'IP'].forEach(reg => {
                    const el = document.getElementById(`sim-${reg.toLowerCase()}`);
                    if (el) {
                        el.textContent = this.registers[reg].toString(16).toUpperCase().padStart(4, '0') + 'h';
                    }
                });

                // Update 8-bit displays
                ['A', 'B', 'C', 'D'].forEach(pre => {
                    const high = this.getHigh(pre + 'X');
                    const low = this.getLow(pre + 'X');
                    const highEl = document.getElementById(`sim-${pre.toLowerCase()}h`);
                    const lowEl = document.getElementById(`sim-${pre.toLowerCase()}l`);
                    const binEl = document.getElementById(`sim-${pre.toLowerCase()}x-bin`);
                    
                    if (highEl) highEl.textContent = high.toString(16).toUpperCase().padStart(2, '0') + 'h';
                    if (lowEl) lowEl.textContent = low.toString(16).toUpperCase().padStart(2, '0') + 'h';
                    if (binEl) {
                        const val = this.registers[pre + 'X'];
                        binEl.textContent = val.toString(2).padStart(16, '0').replace(/(.{8})/, '$1 ');
                    }
                });

                // Update flags
                Object.keys(this.flagBits).forEach(flag => {
                    const el = document.getElementById(`flag-${flag.toLowerCase()}`);
                    if (el) {
                        el.classList.toggle('set', this.getFlag(flag) === 1);
                    }
                });

                document.getElementById('sim-flags').textContent = this.registers.FLAGS.toString(16).toUpperCase().padStart(4, '0') + 'h';
                document.getElementById('sim-flags-bin').textContent = this.registers.FLAGS.toString(2).padStart(16, '0').replace(/(.{8})/, '$1 ');
            }

            attachListeners() {
                // Register selection
                document.querySelectorAll('[data-reg]').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.reg-card, .simple-reg').forEach(r => r.classList.remove('selected'));
                        el.classList.add('selected');
                        this.selectedReg = el.dataset.reg;
                        document.getElementById('selected-reg').textContent = this.selectedReg;
                    });
                });

                // Operation buttons
                document.querySelectorAll('.op-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (!this.selectedReg) {
                            alert('Please select a register first');
                            return;
                        }
                        const op = btn.dataset.op;
                        if (op === 'SET') {
                            const val = prompt(`Enter value for ${this.selectedReg} (hex):`);
                            if (val) {
                                this.saveState();
                                this.registers[this.selectedReg] = parseInt(val.replace('h', ''), 16) & 0xFFFF;
                                this.updateDisplay();
                                document.getElementById('last-op').textContent = `Last: MOV ${this.selectedReg}, ${val}`;
                            }
                        } else {
                            this.executeOp(op);
                        }
                    });
                });

                document.getElementById('exec-op').addEventListener('click', () => {
                    const op = document.querySelector('.op-btn[data-op="MOV"]');
                    if (op) op.click();
                });

                document.getElementById('sim-reset').addEventListener('click', () => this.reset());
                document.getElementById('sim-undo').addEventListener('click', () => this.undo());

                document.getElementById('example-select').addEventListener('change', (e) => {
                    this.loadExample(e.target.value);
                });
            }

            executeOp(op) {
                this.saveState();
                const reg = this.selectedReg;
                const is8bit = reg.length === 2 && /[HL]$/.test(reg);
                const baseReg = is8bit ? reg.charAt(0) + 'X' : reg;
                
                let val = is8bit ? (reg.endsWith('H') ? this.getHigh(baseReg) : this.getLow(baseReg)) : this.registers[reg];
                const immVal = parseInt(document.getElementById('imm-value').value.replace('h', ''), 16) || 0;
                
                let result, oldVal = val;
                const max = is8bit ? 0xFF : 0xFFFF;
                const bits = is8bit ? 8 : 16;

                switch(op) {
                    case 'MOV': result = immVal & max; break;
                    case 'ADD': 
                        result = (val + immVal) & max;
                        this.setFlag('CF', (val + immVal) > max);
                        this.updateFlags(result, bits);
                        break;
                    case 'SUB': 
                        result = (val - immVal) & max;
                        this.setFlag('CF', val < immVal);
                        this.updateFlags(result, bits);
                        break;
                    case 'INC': 
                        result = (val + 1) & max;
                        this.updateFlags(result, bits);
                        break;
                    case 'DEC': 
                        result = (val - 1) & max;
                        this.updateFlags(result, bits);
                        break;
                    case 'AND': 
                        result = val & immVal;
                        this.setFlag('CF', 0);
                        this.setFlag('OF', 0);
                        this.updateFlags(result, bits);
                        break;
                    case 'OR': 
                        result = val | immVal;
                        this.setFlag('CF', 0);
                        this.setFlag('OF', 0);
                        this.updateFlags(result, bits);
                        break;
                    case 'XOR': 
                        result = val ^ immVal;
                        this.setFlag('CF', 0);
                        this.setFlag('OF', 0);
                        this.updateFlags(result, bits);
                        break;
                    case 'NOT': 
                        result = (~val) & max;
                        break;
                    case 'SHL': 
                        result = (val << 1) & max;
                        this.setFlag('CF', (val >> (bits - 1)) & 1);
                        this.updateFlags(result, bits);
                        break;
                    case 'SHR': 
                        result = (val >>> 1) & max;
                        this.setFlag('CF', val & 1);
                        this.updateFlags(result, bits);
                        break;
                    default: return;
                }

                if (is8bit) {
                    if (reg.endsWith('H')) this.setHigh(baseReg, result);
                    else this.setLow(baseReg, result);
                } else {
                    this.registers[reg] = result;
                }

                this.updateDisplay();
                document.getElementById('last-op').textContent = `Last: ${op} ${reg}${op !== 'NOT' && op !== 'INC' && op !== 'DEC' ? ', ' + immVal.toString(16).toUpperCase() + 'h' : ''}`;
            }

            updateFlags(result, bits) {
                this.setFlag('ZF', result === 0);
                this.setFlag('SF', (result >> (bits - 1)) & 1);
                this.setFlag('PF', this.calcParity(result & 0xFF));
            }

            calcParity(byte) {
                let count = 0;
                for (let i = 0; i < 8; i++) count += (byte >> i) & 1;
                return count % 2 === 0;
            }

            loadExample(name) {
                this.reset();
                this.saveState();
                
                const examples = {
                    'hello': () => {
                        this.registers.AX = 0x0900;
                        this.registers.DX = 0x0000;
                    },
                    'add': () => {
                        this.registers.AX = 0x0010;
                        this.registers.BX = 0x0020;
                    },
                    'loop': () => {
                        this.registers.CX = 0x000A;
                    },
                    'string': () => {
                        this.registers.SI = 0x0100;
                        this.registers.DI = 0x0200;
                        this.registers.DS = 0x0000;
                        this.registers.ES = 0x0000;
                    },
                    'stack': () => {
                        this.registers.SP = 0x0FFE;
                        this.registers.SS = 0x0000;
                        this.registers.AX = 0x1234;
                    },
                    'flags': () => {
                        this.registers.AX = 0x00FF;
                        this.registers.FLAGS = 0x0000;
                    }
                };

                if (examples[name]) {
                    examples[name]();
                    this.updateDisplay();
                }
            }
        }

        const simulator = new CPUSimulator();



        // ============================================
        // FLASHCARDS SYSTEM
        // ============================================
        const flashcardsData = [
            { category: "Registers", question: "What is the AX register used for?", answer: "AX is the Accumulator register used for arithmetic operations, I/O operations, and interrupt calls. It can be accessed as two 8-bit registers: AH (high) and AL (low)." },
            { category: "Registers", question: "What is the difference between AX and AL?", answer: "AX is a 16-bit register, while AL is the lower 8 bits of AX. AH contains the upper 8 bits. Many operations can work with either the full 16-bit AX or just the 8-bit AL." },
            { category: "Registers", question: "What is the CX register primarily used for?", answer: "CX is the Count register. It's used as a loop counter (LOOP instruction decrements CX), for string operations with REP prefix, and for shift/rotate counts." },
            { category: "Registers", question: "What is the purpose of the BX register?", answer: "BX is the Base register. It's commonly used as a pointer to data in memory, especially for array indexing and addressing calculations." },
            { category: "Registers", question: "What is the DX register used for?", answer: "DX is the Data register. It's used for I/O operations, as an extension of AX for multiply/divide operations (high word), and for port addressing." },
            { category: "Registers", question: "What is the SI register?", answer: "SI (Source Index) is used as a source pointer for string operations. By default, it works with the DS (Data Segment) register." },
            { category: "Registers", question: "What is the DI register?", answer: "DI (Destination Index) is used as a destination pointer for string operations. It works with the ES (Extra Segment) register by default." },
            { category: "Registers", question: "What is the difference between SP and BP?", answer: "SP (Stack Pointer) always points to the top of the stack. BP (Base Pointer) is used to access data on the stack (parameters and local variables) without modifying SP." },
            { category: "Registers", question: "What are segment registers?", answer: "Segment registers (CS, DS, SS, ES) define memory segments. CS=Code Segment, DS=Data Segment, SS=Stack Segment, ES=Extra Segment for string destinations." },
            { category: "Registers", question: "Why can't you MOV an immediate value directly to DS?", answer: "You cannot move an immediate value directly to a segment register. You must use a general-purpose register as an intermediary: MOV AX, @DATA then MOV DS, AX." },
            { category: "Flags", question: "What is the Zero Flag (ZF)?", answer: "ZF is set when the result of an operation is zero. It's used for equality comparisons (JE/JZ jumps if ZF=1)." },
            { category: "Flags", question: "What is the Carry Flag (CF)?", answer: "CF is set when an arithmetic operation generates a carry out of or borrow into the most significant bit. Used for unsigned comparisons." },
            { category: "Flags", question: "What is the Sign Flag (SF)?", answer: "SF is set when the result of an operation is negative (the most significant bit is 1). It reflects the sign bit of the result." },
            { category: "Flags", question: "What is the Overflow Flag (OF)?", answer: "OF is set when a signed arithmetic operation results in overflow (the result is too large or too small for the destination)." },
            { category: "Flags", question: "What is the Parity Flag (PF)?", answer: "PF is set when the result has an even number of 1 bits in the least significant byte. Used for error checking." },
            { category: "Instructions", question: "What does the MOV instruction do?", answer: "MOV copies data from source to destination. It does NOT affect any flags. It can move between registers, memory, and immediate values (with restrictions)." },
            { category: "Instructions", question: "What is the difference between ADD and INC?", answer: "ADD adds any value to a register/memory. INC adds exactly 1. ADD affects CF, but INC does NOT affect the Carry Flag." },
            { category: "Instructions", question: "What does the CMP instruction do?", answer: "CMP compares two operands by subtracting them (without storing the result). It sets flags based on the result for conditional jumps." },
            { category: "Instructions", question: "What does JMP do?", answer: "JMP (Jump) unconditionally transfers control to a different location in the code. It can be short, near, or far." },
            { category: "Instructions", question: "What is the difference between JE and JZ?", answer: "JE (Jump if Equal) and JZ (Jump if Zero) are the same instruction. Both jump if ZF=1 (typically after CMP)." },
            { category: "Instructions", question: "What does the LOOP instruction do?", answer: "LOOP decrements CX and jumps if CX is not zero. It's used for creating counted loops without manually updating the counter." },
            { category: "Instructions", question: "What does INT 21h do?", answer: "INT 21h is the DOS interrupt. The function number goes in AH. Common functions: 01h (input), 02h (output char), 09h (output string), 4Ch (exit)." },
            { category: "Instructions", question: "What does PUSH do?", answer: "PUSH decrements SP by 2 and stores a word on the stack. It's used to save register values or pass parameters." },
            { category: "Instructions", question: "What does POP do?", answer: "POP retrieves a word from the stack (at SP) and increments SP by 2. It restores values saved by PUSH." },
            { category: "Instructions", question: "What does CALL do?", answer: "CALL pushes the return address (next instruction) onto the stack and jumps to a procedure. RET returns by popping the address." },
            { category: "Instructions", question: "What is the difference between SHL and SHR?", answer: "SHL (Shift Left) shifts bits left, filling with zeros. SHR (Shift Right) shifts bits right, filling with zeros. Both shift CF gets the bit shifted out." },
            { category: "Instructions", question: "What does the NOT instruction do?", answer: "NOT inverts all bits (one's complement). It does NOT affect any flags, unlike NEG which affects flags." },
            { category: "Instructions", question: "What is the LEA instruction?", answer: "LEA (Load Effective Address) calculates the address of a memory operand and stores it in a register. It doesn't access memory, just computes the address." },
            { category: "Instructions", question: "What does the TEST instruction do?", answer: "TEST performs a bitwise AND and sets flags (like ZF, SF, PF) but doesn't store the result. Used for checking bits without modifying data." },
            { category: "Memory", question: "How is physical address calculated in real mode?", answer: "Physical Address = Segment √ó 16 + Offset. A segment register is shifted left 4 bits (√ó16) and added to the offset." },
            { category: "Memory", question: "What is little-endian byte ordering?", answer: "In little-endian (used by x86), the least significant byte is stored at the lowest memory address. For 0x1234, 0x34 is stored first." },
            { category: "Memory", question: "What is the stack?", answer: "The stack is a LIFO (Last-In-First-Out) data structure in memory. SS:SP points to the top. It grows downward (toward lower addresses)." },
            { category: "Memory", question: "What is the difference between .DATA and .CODE segments?", answer: ".DATA contains initialized variables and data. .CODE contains executable instructions. The CPU fetches instructions from CS (Code Segment)." },
            { category: "Memory", question: "What is a buffer overflow?", answer: "A buffer overflow occurs when data written to a buffer exceeds its allocated size, potentially overwriting adjacent memory including return addresses." },
            { category: "Data Types", question: "What is the range of an 8-bit signed integer?", answer: "An 8-bit signed integer (using two's complement) ranges from -128 to +127. The MSB is the sign bit." },
            { category: "Data Types", question: "What is the range of a 16-bit unsigned integer?", answer: "A 16-bit unsigned integer ranges from 0 to 65,535 (0 to 2^16 - 1). All bits are used for magnitude." },
            { category: "Data Types", question: "How is -5 represented in 8-bit two's complement?", answer: "-5 in 8-bit two's complement is 0xFB (11111011). Invert 00000101 to get 11111010, then add 1." },
            { category: "Data Types", question: "What is ASCII?", answer: "ASCII (American Standard Code for Information Interchange) is a 7-bit character encoding. 'A' = 65 (0x41), '0' = 48 (0x30)." },
            { category: "Data Types", question: "What is the difference between DB and DW?", answer: "DB (Define Byte) allocates 8-bit data. DW (Define Word) allocates 16-bit data. DD allocates 32-bit (double word) data." },
            { category: "Addressing", question: "What is direct addressing?", answer: "Direct addressing uses a constant address: MOV AX, [1000h]. The value is taken from memory address DS:1000h." },
            { category: "Addressing", question: "What is register indirect addressing?", answer: "Register indirect uses a register as a pointer: MOV AX, [BX]. BX contains the offset address in the data segment." },
            { category: "Addressing", question: "What is based-indexed addressing?", answer: "Based-indexed combines a base register (BX or BP) with an index register (SI or DI): MOV AX, [BX+SI]." },
            { category: "Procedures", question: "What is the purpose of PROC and ENDP?", answer: "PROC marks the beginning of a procedure, ENDP marks the end. They help organize code into reusable subroutines." },
            { category: "Procedures", question: "What registers must be preserved in a procedure?", answer: "According to convention, BP, SP, DS, SI, and DI should be preserved if modified. AX, BX, CX, DX are typically scratch registers." },
            { category: "Procedures", question: "What is the difference between RET and RET n?", answer: "RET pops the return address and returns. RET n (e.g., RET 4) also adds n to SP after popping, used to clean up stack parameters." },
            { category: "Interrupts", question: "What is an interrupt?", answer: "An interrupt is a signal that causes the CPU to pause current execution and execute an interrupt handler, then return to the original code." },
            { category: "Interrupts", question: "What is the difference between hardware and software interrupts?", answer: "Hardware interrupts are triggered by external devices. Software interrupts (like INT 21h) are triggered by the INT instruction in code." },
            { category: "Macros", question: "What is the difference between a macro and a procedure?", answer: "A macro is expanded inline at assembly time (faster, larger code). A procedure is called at runtime (slower, reusable, smaller code)." },
            { category: "I/O", question: "How do you output a character in DOS?", answer: "MOV AH, 02h (function 2), MOV DL, 'A' (character), INT 21h. The character in DL is displayed on screen." },
            { category: "I/O", question: "How do you input a character in DOS?", answer: "MOV AH, 01h, INT 21h. The character is returned in AL, and also echoed to the screen." },
            { category: "I/O", question: "How do you output a string in DOS?", answer: "MOV AH, 09h, MOV DX, offset string, INT 21h. The string must be '$' terminated (not null-terminated)." },
            { category: "Optimization", question: "Why use XOR AX, AX instead of MOV AX, 0?", answer: "XOR AX, AX is faster (fewer bytes, fewer cycles) and clears the register to zero. It's a common optimization technique." }
        ];

        let currentCard = 0;
        let knownCards = 0;
        let reviewCards = 0;
        let cardOrder = [...Array(flashcardsData.length).keys()];

        function updateFlashcard() {
            const card = flashcardsData[cardOrder[currentCard]];
            document.getElementById('fc-category').textContent = card.category;
            document.getElementById('fc-question').textContent = card.question;
            document.getElementById('fc-answer').textContent = card.answer;
            document.getElementById('fc-current').textContent = currentCard + 1;
            document.getElementById('fc-total').textContent = flashcardsData.length;
            document.getElementById('fc-known').textContent = knownCards;
            document.getElementById('fc-review').textContent = reviewCards;
            document.getElementById('flashcard').classList.remove('flipped');
        }

        document.getElementById('flashcard').addEventListener('click', () => {
            document.getElementById('flashcard').classList.toggle('flipped');
        });

        document.getElementById('fc-know').addEventListener('click', () => {
            knownCards++;
            currentCard++;
            if (currentCard >= flashcardsData.length) {
                currentCard = 0;
                alert('Deck complete! Starting over.');
            }
            updateFlashcard();
        });

        document.getElementById('fc-dont').addEventListener('click', () => {
            reviewCards++;
            currentCard++;
            if (currentCard >= flashcardsData.length) {
                currentCard = 0;
                alert('Deck complete! Starting over.');
            }
            updateFlashcard();
        });

        document.getElementById('fc-shuffle').addEventListener('click', () => {
            cardOrder.sort(() => Math.random() - 0.5);
            currentCard = 0;
            knownCards = 0;
            reviewCards = 0;
            updateFlashcard();
        });

        updateFlashcard();

        // ============================================
        // GAMES SYSTEM
        // ============================================
        const games = {
            registerRacer: {
                title: 'üèéÔ∏è Register Racer',
                questions: [
                    { q: 'Store loop counter', a: 'CX', options: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Store string source address', a: 'SI', options: ['SI', 'DI', 'SP', 'BP'] },
                    { q: 'Store string destination address', a: 'DI', options: ['SI', 'DI', 'SP', 'BP'] },
                    { q: 'Accumulator for arithmetic', a: 'AX', options: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Base register for addressing', a: 'BX', options: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Data register for I/O', a: 'DX', options: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Stack pointer', a: 'SP', options: ['SI', 'DI', 'SP', 'BP'] },
                    { q: 'Base pointer for stack frames', a: 'BP', options: ['SI', 'DI', 'SP', 'BP'] }
                ]
            },
            hexHunter: {
                title: 'üî¢ Hex Hunter',
                modes: ['decToHex', 'hexToDec', 'binToHex', 'hexToBin']
            }
        };

        let currentGame = null;
        let gameScore = 0;
        let gameTimer = null;
        let gameTime = 60;

        document.querySelectorAll('.game-card').forEach(card => {
            card.addEventListener('click', () => {
                const gameName = card.dataset.game;
                startGame(gameName);
            });
        });

        function startGame(gameName) {
            currentGame = gameName;
            document.getElementById('games-menu').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';

            if (gameName === 'registerRacer') {
                initRegisterRacer();
            } else if (gameName === 'hexHunter') {
                initHexHunter();
            } else {
                // Generic game placeholder
                document.getElementById('game-container').innerHTML = `
                    <div class="game-container">
                        <div class="game-header-compact">
                            <button class="btn-back" onclick="backToGames()">‚Üê Back to Games</button>
                            <h2>${games[gameName]?.title || gameName}</h2>
                        </div>
                        <div style="text-align: center; padding: 50px;">
                            <p>Game implementation for ${gameName}</p>
                            <button class="btn btn-primary" onclick="backToGames()">Back</button>
                        </div>
                    </div>
                `;
            }
        }

        function backToGames() {
            clearInterval(gameTimer);
            document.getElementById('games-menu').style.display = 'block';
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('game-container').innerHTML = '';
        }

        function initRegisterRacer() {
            gameScore = 0;
            gameTime = 60;
            let currentQ = 0;
            let streak = 0;
            
            const questions = [...games.registerRacer.questions].sort(() => Math.random() - 0.5);
            
            document.getElementById('game-container').innerHTML = `
                <div class="game-container register-racer">
                    <div class="game-header-compact">
                        <div class="header-left">
                            <button class="btn-back" onclick="backToGames()">‚Üê Back</button>
                            <h2>üèéÔ∏è Register Racer</h2>
                        </div>
                        <div class="game-stats-bar">
                            <span class="stat-box">‚≠ê <span id="rr-score">0</span></span>
                            <span class="stat-box">üî• <span id="rr-streak">0</span></span>
                        </div>
                    </div>
                    <div class="timer-bar">
                        <div class="timer-progress" id="rr-timer-bar"></div>
                        <span class="timer-text">‚è±Ô∏è <span id="rr-timer">60</span>s</span>
                    </div>
                    <div style="text-align: center; padding: 30px;">
                        <h3 id="rr-question">${questions[0].q}</h3>
                        <div class="answers-grid" id="rr-answers"></div>
                        <div id="rr-feedback" style="margin-top: 20px; font-size: 18px;"></div>
                    </div>
                </div>
            `;

            renderAnswers(questions[0]);
            startGameTimer();

            function renderAnswers(q) {
                const grid = document.getElementById('rr-answers');
                grid.innerHTML = q.options.map(opt => 
                    `<button class="answer-btn" data-ans="${opt}">${opt}</button>`
                ).join('');

                grid.querySelectorAll('.answer-btn').forEach(btn => {
                    btn.addEventListener('click', () => checkAnswer(btn, q));
                });
            }

            function checkAnswer(btn, q) {
                const correct = btn.dataset.ans === q.a;
                const feedback = document.getElementById('rr-feedback');
                
                if (correct) {
                    streak++;
                    const points = 10 + (streak > 3 ? 5 : 0);
                    gameScore += points;
                    feedback.innerHTML = `‚úÖ Correct! +${points} points`;
                    feedback.style.color = 'var(--success)';
                } else {
                    streak = 0;
                    feedback.innerHTML = `‚ùå Wrong! The answer was ${q.a}`;
                    feedback.style.color = 'var(--danger)';
                }

                document.getElementById('rr-score').textContent = gameScore;
                document.getElementById('rr-streak').textContent = streak;

                setTimeout(() => {
                    currentQ++;
                    if (currentQ >= questions.length) currentQ = 0;
                    document.getElementById('rr-question').textContent = questions[currentQ].q;
                    feedback.textContent = '';
                    renderAnswers(questions[currentQ]);
                }, 1500);
            }

            function startGameTimer() {
                gameTimer = setInterval(() => {
                    gameTime--;
                    document.getElementById('rr-timer').textContent = gameTime;
                    document.getElementById('rr-timer-bar').style.width = (gameTime/60*100) + '%';
                    
                    if (gameTime <= 0) {
                        clearInterval(gameTimer);
                        alert(`Game Over! Final Score: ${gameScore}`);
                        backToGames();
                    }
                }, 1000);
            }
        }

        function initHexHunter() {
            gameScore = 0;
            gameTime = 90;
            let inputBuffer = '';
            
            document.getElementById('game-container').innerHTML = `
                <div class="game-container hex-hunter">
                    <div class="game-header-compact">
                        <div class="header-left">
                            <button class="btn-back" onclick="backToGames()">‚Üê Back</button>
                            <h2>üî¢ Hex Hunter</h2>
                        </div>
                        <div class="game-stats-bar">
                            <span class="stat-box">‚≠ê <span id="hh-score">0</span></span>
                        </div>
                    </div>
                    <div class="timer-bar">
                        <div class="timer-progress" id="hh-timer-bar"></div>
                        <span class="timer-text">‚è±Ô∏è <span id="hh-timer">90</span>s</span>
                    </div>
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">Convert:</div>
                        <div style="font-size: 36px; font-weight: bold; color: var(--primary);" id="hh-from">Decimal: 255</div>
                        <div style="font-size: 20px; margin: 20px 0;">‚Üì</div>
                        <div style="font-size: 18px;">to Hexadecimal</div>
                        <div style="font-size: 32px; font-family: monospace; margin: 20px 0; padding: 15px; background: var(--bg); border-radius: 8px;" id="hh-input">_</div>
                        <div id="hh-feedback" style="margin: 10px 0; min-height: 24px;"></div>
                    </div>
                    <div class="keypad">
                        <div class="keypad-row">
                            <button class="key" data-key="1">1</button>
                            <button class="key" data-key="2">2</button>
                            <button class="key" data-key="3">3</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key" data-key="4">4</button>
                            <button class="key" data-key="5">5</button>
                            <button class="key" data-key="6">6</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key" data-key="7">7</button>
                            <button class="key" data-key="8">8</button>
                            <button class="key" data-key="9">9</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key hex" data-key="A">A</button>
                            <button class="key" data-key="0">0</button>
                            <button class="key hex" data-key="B">B</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key hex" data-key="C">C</button>
                            <button class="key hex" data-key="D">D</button>
                            <button class="key hex" data-key="E">E</button>
                            <button class="key hex" data-key="F">F</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key control" data-key="CLR">CLR</button>
                            <button class="key control" data-key="DEL">‚å´</button>
                            <button class="key control enter" data-key="ENT">‚èé</button>
                        </div>
                    </div>
                </div>
            `;

            let fromVal = Math.floor(Math.random() * 256);
            document.getElementById('hh-from').textContent = `Decimal: ${fromVal}`;

            document.querySelectorAll('.key').forEach(key => {
                key.addEventListener('click', () => {
                    const k = key.dataset.key;
                    if (k === 'CLR') {
                        inputBuffer = '';
                    } else if (k === 'DEL') {
                        inputBuffer = inputBuffer.slice(0, -1);
                    } else if (k === 'ENT') {
                        checkHexAnswer();
                    } else if (inputBuffer.length < 4) {
                        inputBuffer += k;
                    }
                    document.getElementById('hh-input').textContent = inputBuffer || '_';
                });
            });

            function checkHexAnswer() {
                const correct = fromVal.toString(16).toUpperCase();
                const feedback = document.getElementById('hh-feedback');
                
                if (inputBuffer === correct) {
                    gameScore += 15;
                    feedback.innerHTML = '‚úÖ Correct!';
                    feedback.style.color = 'var(--success)';
                } else {
                    feedback.innerHTML = `‚ùå Wrong! ${fromVal} = 0x${correct}`;
                    feedback.style.color = 'var(--danger)';
                }
                
                document.getElementById('hh-score').textContent = gameScore;
                
                setTimeout(() => {
                    fromVal = Math.floor(Math.random() * 256);
                    document.getElementById('hh-from').textContent = `Decimal: ${fromVal}`;
                    inputBuffer = '';
                    document.getElementById('hh-input').textContent = '_';
                    feedback.textContent = '';
                }, 1500);
            }

            gameTimer = setInterval(() => {
                gameTime--;
                document.getElementById('hh-timer').textContent = gameTime;
                document.getElementById('hh-timer-bar').style.width = (gameTime/90*100) + '%';
                
                if (gameTime <= 0) {
                    clearInterval(gameTimer);
                    alert(`Game Over! Final Score: ${gameScore}`);
                    backToGames();
                }
            }, 1000);
        }



        // ============================================
        // TEST SYSTEM
        // ============================================
        const testQuestions = [
            {
                question: "Which register is traditionally used as the accumulator for arithmetic operations in x86 assembly?",
                options: ["BX", "CX", "DX", "AX"],
                correct: 3,
                explanation: "AX is the Accumulator register. It's optimized for arithmetic operations like MUL, DIV, and is used for I/O operations and interrupt calls. It can be accessed as 8-bit halves (AH and AL)."
            },
            {
                question: "What is the purpose of the CX register in x86 assembly?",
                options: ["Accumulator", "Base pointer", "Counter for loops", "Data register"],
                correct: 2,
                explanation: "CX is the Count register. It's used as a loop counter (the LOOP instruction automatically decrements CX), for string operations with REP prefix, and for shift/rotate counts."
            },
            {
                question: "Which flag is set when the result of an arithmetic operation is zero?",
                options: ["Carry Flag (CF)", "Zero Flag (ZF)", "Sign Flag (SF)", "Overflow Flag (OF)"],
                correct: 1,
                explanation: "The Zero Flag (ZF) is set when the result of an operation is zero. It's commonly used after CMP to test for equality (JE/JZ jumps if ZF=1)."
            },
            {
                question: "What is the correct formula for calculating physical address in x86 real mode?",
                options: ["Segment + Offset", "Segment √ó 16 + Offset", "Segment √ó 256 + Offset", "Segment << 8 + Offset"],
                correct: 1,
                explanation: "Physical Address = Segment √ó 16 + Offset. The segment register is shifted left 4 bits (equivalent to multiplying by 16) and added to the offset to form the 20-bit physical address."
            },
            {
                question: "Which instruction is used to compare two values without storing the result?",
                options: ["SUB", "CMP", "TEST", "XOR"],
                correct: 1,
                explanation: "CMP (Compare) subtracts the second operand from the first and sets flags based on the result, but does not store the result. It's used before conditional jumps to make decisions."
            },
            {
                question: "What is the range of values for an 8-bit signed integer using two's complement?",
                options: ["0 to 255", "-127 to 127", "-128 to 127", "-256 to 255"],
                correct: 2,
                explanation: "An 8-bit signed integer ranges from -128 to +127. The MSB is the sign bit (0=positive, 1=negative), allowing 128 negative numbers and 128 non-negative numbers (0-127)."
            },
            {
                question: "What does the instruction 'MOV AX, @DATA' followed by 'MOV DS, AX' accomplish?",
                options: ["Clears the data segment", "Initializes DS with the data segment address", "Saves AX to memory", "Loads AX with the stack pointer"],
                correct: 1,
                explanation: "You cannot move an immediate value directly to a segment register like DS. This sequence uses AX as an intermediary to initialize the Data Segment register with the address of the data segment."
            },
            {
                question: "Which x86 flag indicates a signed arithmetic overflow?",
                options: ["Carry Flag (CF)", "Parity Flag (PF)", "Overflow Flag (OF)", "Auxiliary Flag (AF)"],
                correct: 2,
                explanation: "The Overflow Flag (OF) is set when a signed arithmetic operation produces a result too large or too small to fit in the destination. CF indicates unsigned overflow."
            },
            {
                question: "What is the difference between SHL and SHR instructions?",
                options: ["SHL is faster", "SHL shifts left, SHR shifts right", "SHL affects CF, SHR does not", "SHL is for 8-bit, SHR is for 16-bit"],
                correct: 1,
                explanation: "SHL (Shift Left) shifts bits to the left, filling with zeros. SHR (Shift Right) shifts bits to the right, filling with zeros. Both affect the Carry Flag with the bit shifted out."
            },
            {
                question: "What is the purpose of the LOOP instruction?",
                options: ["Jump to a subroutine", "Decrement CX and jump if not zero", "Compare two strings", "Load a register with an address"],
                correct: 1,
                explanation: "LOOP decrements CX and jumps to the specified label if CX is not zero. It provides a convenient way to create counted loops without manually decrementing and testing the counter."
            },
            {
                question: "In little-endian byte ordering, how is the 16-bit value 0x1234 stored in memory?",
                options: ["12 34", "34 12", "00 12 34", "12 34 00"],
                correct: 1,
                explanation: "In little-endian (used by x86), the least significant byte is stored first. So 0x1234 is stored as 0x34 at the lower address, followed by 0x12 at the higher address."
            },
            {
                question: "Which interrupt is used for DOS system calls?",
                options: ["INT 10h", "INT 16h", "INT 21h", "INT 33h"],
                correct: 2,
                explanation: "INT 21h is the DOS interrupt. The function number is placed in AH. Common functions: 01h (input), 02h (output char), 09h (output string), 4Ch (exit program)."
            },
            {
                question: "What does the PUSH instruction do?",
                options: ["Increments SP and stores a value", "Decrements SP and stores a value", "Stores a value without changing SP", "Loads a value from the stack"],
                correct: 1,
                explanation: "PUSH decrements SP by 2 (for a word) and stores the value at the new stack location. The stack grows downward in memory, toward lower addresses."
            },
            {
                question: "What is the result of XOR AX, AX?",
                options: ["AX = 0xFFFF", "AX = 0", "AX unchanged", "AX = AX + AX"],
                correct: 1,
                explanation: "XORing a value with itself produces zero. XOR AX, AX is a common optimization to clear a register to zero - it's faster and uses fewer bytes than MOV AX, 0."
            },
            {
                question: "Which register pair is used for string operations with the MOVSB instruction?",
                options: ["AX:BX", "CS:IP", "DS:SI and ES:DI", "SS:SP"],
                correct: 2,
                explanation: "MOVSB copies a byte from DS:SI to ES:DI. DS:SI points to the source, ES:DI points to the destination. SI and DI are automatically incremented or decremented based on DF."
            },
            {
                question: "What does the TEST instruction do?",
                options: ["Adds two values", "Performs AND and sets flags without storing result", "Compares strings", "Tests if a bit is set"],
                correct: 1,
                explanation: "TEST performs a bitwise AND operation and sets flags (ZF, SF, PF) based on the result, but does not store the result. It's used to check bits without modifying data."
            },
            {
                question: "What is the ASCII code for the character 'A'?",
                options: ["64 (0x40)", "65 (0x41)", "97 (0x61)", "48 (0x30)"],
                correct: 1,
                explanation: "The ASCII code for uppercase 'A' is 65 (0x41). Lowercase 'a' is 97 (0x61). Digit '0' is 48 (0x30). These offsets are useful for converting between characters and numbers."
            },
            {
                question: "What is a buffer overflow?",
                options: ["Running out of memory", "Writing past the end of a buffer", "Reading from invalid memory", "Stack underflow"],
                correct: 1,
                explanation: "A buffer overflow occurs when data written to a buffer exceeds its allocated size, potentially overwriting adjacent memory including return addresses, leading to security vulnerabilities."
            },
            {
                question: "Which addressing mode uses a register as a pointer to memory?",
                options: ["Immediate", "Direct", "Register indirect", "Based-indexed"],
                correct: 2,
                explanation: "Register indirect addressing uses a register (BX, SI, DI, BP) as a pointer to memory. Example: MOV AX, [BX] loads AX from the address in BX."
            },
            {
                question: "What is the purpose of the PROC and ENDP directives?",
                options: ["Define data variables", "Mark the beginning and end of a procedure", "Include external files", "Set memory segments"],
                correct: 1,
                explanation: "PROC marks the beginning of a procedure (subroutine), and ENDP marks its end. They help organize code into reusable blocks that can be called with CALL and returned from with RET."
            }
        ];

        let currentQuestion = 0;
        let testAnswers = [];
        let userAnswers = [];

        document.getElementById('start-test').addEventListener('click', () => {
            document.getElementById('test-start').style.display = 'none';
            document.getElementById('test-active').style.display = 'block';
            currentQuestion = 0;
            userAnswers = new Array(testQuestions.length).fill(null);
            renderQuestion();
        });

        function renderQuestion() {
            const q = testQuestions[currentQuestion];
            document.getElementById('test-progress').style.width = ((currentQuestion + 1) / testQuestions.length * 100) + '%';
            document.getElementById('test-question').innerHTML = `<strong>Question ${currentQuestion + 1} of ${testQuestions.length}:</strong><br>${q.question}`;
            
            const optionsHtml = q.options.map((opt, i) => 
                `<button class="option-btn ${userAnswers[currentQuestion] === i ? 'selected' : ''}" data-idx="${i}">${String.fromCharCode(65 + i)}. ${opt}</button>`
            ).join('');
            document.getElementById('test-options').innerHTML = optionsHtml;

            // Show explanation if already answered
            const explanation = document.getElementById('test-explanation');
            if (userAnswers[currentQuestion] !== null) {
                explanation.innerHTML = `<strong>Explanation:</strong><br>${q.explanation}`;
                explanation.style.display = 'block';
                
                // Mark correct/incorrect
                document.querySelectorAll('.option-btn').forEach((btn, i) => {
                    if (i === q.correct) btn.classList.add('correct');
                    else if (i === userAnswers[currentQuestion]) btn.classList.add('incorrect');
                });
            } else {
                explanation.style.display = 'none';
            }

            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.addEventListener('click', () => selectAnswer(parseInt(btn.dataset.idx)));
            });

            document.getElementById('test-prev').disabled = currentQuestion === 0;
            document.getElementById('test-next').textContent = currentQuestion === testQuestions.length - 1 ? 'Finish' : 'Next Question';
        }

        function selectAnswer(idx) {
            userAnswers[currentQuestion] = idx;
            renderQuestion();
        }

        document.getElementById('test-prev').addEventListener('click', () => {
            if (currentQuestion > 0) {
                currentQuestion--;
                renderQuestion();
            }
        });

        document.getElementById('test-next').addEventListener('click', () => {
            if (currentQuestion < testQuestions.length - 1) {
                currentQuestion++;
                renderQuestion();
            } else {
                showResults();
            }
        });

        function showResults() {
            document.getElementById('test-active').style.display = 'none';
            document.getElementById('test-results').style.display = 'block';

            let correct = 0;
            userAnswers.forEach((ans, i) => {
                if (ans === testQuestions[i].correct) correct++;
            });

            const score = Math.round(correct / testQuestions.length * 100);
            document.getElementById('test-score').textContent = score + '%';

            let message = '';
            if (score >= 90) message = 'üéâ Excellent! You have mastered assembly language!';
            else if (score >= 70) message = 'üëç Good job! You understand most concepts.';
            else if (score >= 50) message = 'üìö Keep studying! Review the lectures and try again.';
            else message = 'üí™ Don\'t give up! Practice makes perfect.';

            document.getElementById('test-message').innerHTML = `${message}<br>You got ${correct} out of ${testQuestions.length} questions correct.`;
        }

        document.getElementById('retake-test').addEventListener('click', () => {
            document.getElementById('test-results').style.display = 'none';
            document.getElementById('test-start').style.display = 'block';
        });

        document.getElementById('review-answers').addEventListener('click', () => {
            document.getElementById('test-results').style.display = 'none';
            document.getElementById('test-active').style.display = 'block';
            currentQuestion = 0;
            renderQuestion();
        });

        // ============================================
        // INTERACTIVE LEARNING DEVICES
        // ============================================

        // --- INLINE QUIZ DATA AND FUNCTIONS ---
        const inlineQuizData = {
            'number-systems': [
                {
                    question: "Convert decimal 45 to binary:",
                    options: ["101011", "101101", "110101", "100111"],
                    correct: 1,
                    explanation: "45 / 2 = 22 r1, 22 / 2 = 11 r0, 11 / 2 = 5 r1, 5 / 2 = 2 r1, 2 / 2 = 1 r0, 1 / 2 = 0 r1. Reading bottom-to-top: 101101"
                },
                {
                    question: "What is 0xFF in decimal?",
                    options: ["255", "256", "240", "128"],
                    correct: 0,
                    explanation: "0xFF = 15*16 + 15 = 240 + 15 = 255"
                }
            ],
            'twos-complement': [
                {
                    question: "What is the 8-bit two's complement representation of -5?",
                    options: ["0xFB", "0x05", "0xFA", "0xF5"],
                    correct: 0,
                    explanation: "5 = 00000101, invert = 11111010, add 1 = 11111011 = 0xFB"
                },
                {
                    question: "What is the range of 16-bit signed integers?",
                    options: ["0 to 65535", "-32768 to 32767", "-32767 to 32767", "-128 to 127"],
                    correct: 1,
                    explanation: "16-bit signed: -2^15 to 2^15-1 = -32768 to 32767"
                }
            ],
            'ieee754': [
                {
                    question: "In IEEE 754 single precision, how many bits are used for the exponent?",
                    options: ["8 bits", "11 bits", "23 bits", "32 bits"],
                    correct: 0,
                    explanation: "Single precision uses 1 bit sign, 8 bits exponent, 23 bits mantissa"
                },
                {
                    question: "What is the bias value for IEEE 754 single precision?",
                    options: ["127", "128", "1023", "255"],
                    correct: 0,
                    explanation: "Single precision uses bias of 127. Double precision uses 1023."
                }
            ],
            'registers': [
                {
                    question: "Which register is typically used as a loop counter?",
                    options: ["AX", "BX", "CX", "DX"],
                    correct: 2,
                    explanation: "CX is the Count register, used by LOOP instructions and string operations with REP"
                },
                {
                    question: "What is the name of the register that points to the top of the stack?",
                    options: ["BP", "SP", "IP", "SI"],
                    correct: 1,
                    explanation: "SP (Stack Pointer) always points to the top of the stack"
                }
            ],
            'flags': [
                {
                    question: "Which flag is set when the result of an operation is zero?",
                    options: ["CF (Carry)", "ZF (Zero)", "SF (Sign)", "OF (Overflow)"],
                    correct: 1,
                    explanation: "ZF (Zero Flag) is set when the result is zero. Used for equality comparisons."
                },
                {
                    question: "What is the difference between CF and OF?",
                    options: ["They are the same", "CF is for signed, OF for unsigned", "CF is for unsigned, OF for signed", "CF is for addition, OF for subtraction"],
                    correct: 2,
                    explanation: "CF (Carry Flag) indicates unsigned overflow. OF (Overflow Flag) indicates signed overflow."
                }
            ],
            'addressing-modes': [
                {
                    question: "Which addressing mode uses MOV AX, [BX]?",
                    options: ["Immediate", "Direct", "Register Indirect", "Based Indexed"],
                    correct: 2,
                    explanation: "[BX] uses the value in BX as a memory address pointer - this is Register Indirect addressing"
                },
                {
                    question: "What addressing mode is used in MOV AX, 5?",
                    options: ["Immediate", "Register", "Direct", "Indirect"],
                    correct: 0,
                    explanation: "The value 5 is used directly as the operand - this is Immediate addressing"
                }
            ],
            'interrupts': [
                {
                    question: "What value should be in AH for INT 21h to read a character?",
                    options: ["00h", "01h", "02h", "09h"],
                    correct: 1,
                    explanation: "AH=01h is the function to read a character with echo. AH=02h outputs a character."
                },
                {
                    question: "What interrupt function displays a string?",
                    options: ["01h", "02h", "09h", "4Ch"],
                    correct: 2,
                    explanation: "INT 21h with AH=09h displays a '$'-terminated string pointed to by DS:DX"
                }
            ],
            'bitwise': [
                {
                    question: "What is the result of 0x0F AND 0x3A?",
                    options: ["0x3F", "0x0A", "0x35", "0x00"],
                    correct: 1,
                    explanation: "0x0F = 00001111, 0x3A = 00111010. AND gives 00001010 = 0x0A"
                },
                {
                    question: "Which operation is commonly used to convert a digit to ASCII?",
                    options: ["AND with 30h", "OR with 30h", "XOR with 30h", "NOT"],
                    correct: 1,
                    explanation: "OR with 30h sets the high nibble to 0011, converting 0-9 to '0'-'9' (30h-39h)"
                }
            ]
        };

        function createInlineQuiz(topicId) {
            const quizzes = inlineQuizData[topicId];
            if (!quizzes || quizzes.length === 0) return '';
            
            const quiz = quizzes[Math.floor(Math.random() * quizzes.length)];
            const quizId = 'quiz-' + Math.random().toString(36).substr(2, 9);
            
            let html = '<div class="inline-quiz" id="' + quizId + '">';
            html += '<div class="inline-quiz-title">Check Your Understanding</div>';
            html += '<div class="inline-quiz-question">' + quiz.question + '</div>';
            html += '<div class="inline-quiz-options">';
            
            quiz.options.forEach((opt, idx) => {
                html += '<button class="inline-quiz-option" onclick="checkInlineQuiz(\'' + quizId + '\', ' + idx + ', ' + quiz.correct + ', \'' + quiz.explanation.replace(/'/g, "\\'") + '\')">' + String.fromCharCode(65 + idx) + '. ' + opt + '</button>';
            });
            
            html += '</div>';
            html += '<div class="inline-quiz-feedback" id="' + quizId + '-feedback"></div>';
            html += '</div>';
            
            return html;
        }

        function checkInlineQuiz(quizId, selected, correct, explanation) {
            const options = document.querySelectorAll('#' + quizId + ' .inline-quiz-option');
            const feedback = document.getElementById(quizId + '-feedback');
            
            options.forEach((opt, idx) => {
                opt.classList.add('disabled');
                if (idx === correct) opt.classList.add('correct');
                else if (idx === selected && idx !== correct) opt.classList.add('incorrect');
            });
            
            const isCorrect = selected === correct;
            feedback.className = 'inline-quiz-feedback ' + (isCorrect ? 'correct' : 'incorrect');
            feedback.innerHTML = '<strong>' + (isCorrect ? 'Correct!' : 'Not quite.') + '</strong><br>' + explanation;
        }

        // --- INTERACTIVE FORMULA EXPLORERS ---
        
        function createTwosComplementExplorer() {
            return '<div class="formula-explorer">' +
                '<div class="formula-explorer-title">Interactive Two\'s Complement Converter</div>' +
                '<div style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px;">' +
                '<div><label class="calc-label">Decimal Number:</label>' +
                '<input type="number" class="calc-input" id="tc-input" placeholder="-42" style="width: 150px;" oninput="updateTwosComplementExplorer()"></div>' +
                '<div><label class="calc-label">Bit Width:</label>' +
                '<select class="calc-input" id="tc-bits" style="width: 100px;" onchange="updateTwosComplementExplorer()">' +
                '<option value="8">8-bit</option><option value="16" selected>16-bit</option><option value="32">32-bit</option>' +
                '</select></div></div>' +
                '<div class="formula-visualizer" id="tc-visualizer">Enter a number to see the two\'s complement breakdown</div>' +
                '<div class="step-visualizer" id="tc-steps"></div></div>';
        }

        function updateTwosComplementExplorer() {
            const val = parseInt(document.getElementById('tc-input').value);
            const bits = parseInt(document.getElementById('tc-bits').value);
            
            if (isNaN(val)) {
                document.getElementById('tc-visualizer').innerHTML = 'Enter a number to see the two\'s complement breakdown';
                document.getElementById('tc-steps').innerHTML = '';
                return;
            }
            
            const max = Math.pow(2, bits);
            const mask = max - 1;
            const unsigned = val & mask;
            
            let html = '<div style="text-align: center;">';
            html += '<div style="font-size: 1.2rem; margin-bottom: 10px;">Decimal: <strong>' + val + '</strong></div>';
            html += '<div style="font-size: 1.2rem; margin-bottom: 10px;">Hex: <strong>0x' + unsigned.toString(16).toUpperCase().padStart(bits/4, '0') + '</strong></div>';
            html += '<div style="font-size: 1.1rem; font-family: monospace;">Binary: <strong style="color: var(--primary);">' + unsigned.toString(2).padStart(bits, '0') + '</strong></div>';
            html += '</div>';
            document.getElementById('tc-visualizer').innerHTML = html;
            
            let stepsHtml = '';
            if (val < 0) {
                const absVal = Math.abs(val);
                const absBinary = absVal.toString(2).padStart(bits, '0');
                const inverted = (max - 1 - absVal).toString(2).padStart(bits, '0');
                const twosComp = unsigned.toString(2).padStart(bits, '0');
                
                stepsHtml += createStep(1, 'Take absolute value: |' + val + '| = ' + absVal, true);
                stepsHtml += createStep(2, 'Convert to binary: ' + absBinary, true);
                stepsHtml += createStep(3, 'Invert all bits (One\'s Complement):<br><span style="font-family: monospace; color: #e74c3c;">' + absBinary + ' ‚Üí ' + inverted + '</span>', true);
                stepsHtml += createStep(4, 'Add 1 (Two\'s Complement):<br><span style="font-family: monospace; color: #27ae60;">' + inverted + ' + 1 = ' + twosComp + '</span>', true);
                stepsHtml += createStep(5, 'Formula check: 2^' + bits + ' + (' + val + ') = ' + max + ' - ' + absVal + ' = ' + unsigned, false);
            } else {
                stepsHtml += createStep(1, 'Positive number - direct binary representation', true);
                stepsHtml += createStep(2, val + ' = ' + unsigned.toString(2).padStart(bits, '0'), false);
            }
            
            document.getElementById('tc-steps').innerHTML = stepsHtml;
        }

        function createStep(num, content, active) {
            return '<div class="step-item ' + (active ? 'active' : '') + '">' +
                '<div class="step-number">' + num + '</div>' +
                '<div class="step-content">' + content + '</div>' +
                '</div>';
        }

        function createIEEE754Explorer() {
            return '<div class="formula-explorer">' +
                '<div class="formula-explorer-title">Visual IEEE 754 Bit Breakdown</div>' +
                '<div style="margin-bottom: 15px;">' +
                '<label class="calc-label">Decimal Number:</label>' +
                '<input type="text" class="calc-input" id="ieee-explorer-input" placeholder="e.g., -6.625" style="width: 200px;" oninput="updateIEEE754Explorer()">' +
                '</div>' +
                '<div class="formula-visualizer">' +
                '<div style="text-align: center; margin-bottom: 15px; font-weight: bold;">32-Bit Layout</div>' +
                '<div class="bit-breakdown" id="ieee-bits">' +
                '<div class="bit-group sign"><div class="bit-value">S</div><div class="bit-group-label">1 bit</div></div>' +
                '<div class="bit-group exponent"><div class="bit-value">EEEEEEEE</div><div class="bit-group-label">8 bits</div></div>' +
                '<div class="bit-group mantissa"><div class="bit-value">MMMMMMMMMMMMMMMMMMMMMMM</div><div class="bit-group-label">23 bits</div></div>' +
                '</div>' +
                '<div id="ieee-explainer" style="margin-top: 15px; text-align: center;">Enter a number to see the bit breakdown</div>' +
                '</div>' +
                '<div class="cheat-formula">' +
                '<div class="cheat-formula-name">Formula</div>' +
                '<div class="cheat-formula-math">Value = (-1)^S √ó 1.M √ó 2^(E-127)</div>' +
                '</div></div>';
        }

        function updateIEEE754Explorer() {
            const input = document.getElementById('ieee-explorer-input').value;
            const val = parseFloat(input);
            
            if (isNaN(val)) {
                document.getElementById('ieee-bits').innerHTML = 
                    '<div class="bit-group sign"><div class="bit-value">S</div><div class="bit-group-label">1 bit</div></div>' +
                    '<div class="bit-group exponent"><div class="bit-value">EEEEEEEE</div><div class="bit-group-label">8 bits</div></div>' +
                    '<div class="bit-group mantissa"><div class="bit-value">MMMMMMMMMMMMMMMMMMMMMMM</div><div class="bit-group-label">23 bits</div></div>';
                document.getElementById('ieee-explainer').textContent = 'Enter a number to see the bit breakdown';
                return;
            }
            
            const buffer = new ArrayBuffer(4);
            const floatView = new Float32Array(buffer);
            const intView = new Uint32Array(buffer);
            floatView[0] = val;
            const bits = intView[0];
            
            const sign = (bits >>> 31) & 0x1;
            const exponent = (bits >>> 23) & 0xFF;
            const mantissa = bits & 0x7FFFFF;
            
            const signBits = sign.toString();
            const expBits = exponent.toString(2).padStart(8, '0');
            const mantBits = mantissa.toString(2).padStart(23, '0');
            
            document.getElementById('ieee-bits').innerHTML = 
                '<div class="bit-group sign"><div class="bit-value">' + signBits + '</div><div class="bit-group-label">Sign</div></div>' +
                '<div class="bit-group exponent"><div class="bit-value">' + expBits + '</div><div class="bit-group-label">Exp: ' + exponent + ' (' + (exponent-127) + ')</div></div>' +
                '<div class="bit-group mantissa"><div class="bit-value" style="font-size: 10px;">' + mantBits + '</div><div class="bit-group-label">Mantissa</div></div>';
            
            const actualExp = exponent === 0 ? -126 : exponent - 127;
            const mantissaValue = exponent === 0 ? (mantissa / Math.pow(2, 23)) : (1 + mantissa / Math.pow(2, 23));
            
            document.getElementById('ieee-explainer').innerHTML = 
                '<strong>Sign:</strong> ' + sign + ' (' + (sign ? 'Negative' : 'Positive') + ') | ' +
                '<strong>Exponent:</strong> ' + exponent + ' - 127 = ' + actualExp + ' | ' +
                '<strong>Mantissa:</strong> ' + mantissaValue.toFixed(6) + '<br>' +
                '<strong>Hex:</strong> 0x' + bits.toString(16).toUpperCase().padStart(8, '0');
        }

        function createBaseConversionVisualizer() {
            return '<div class="formula-explorer">' +
                '<div class="formula-explorer-title">Step-by-Step Base Converter</div>' +
                '<div style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px;">' +
                '<div><label class="calc-label">Input Number:</label>' +
                '<input type="text" class="calc-input" id="bc-input" placeholder="219" style="width: 150px;" oninput="updateBaseConversionVisualizer()"></div>' +
                '<div><label class="calc-label">From Base:</label>' +
                '<select class="calc-input" id="bc-from" style="width: 100px;" onchange="updateBaseConversionVisualizer()">' +
                '<option value="10" selected>Decimal</option><option value="2">Binary</option><option value="16">Hex</option>' +
                '</select></div>' +
                '<div><label class="calc-label">To Base:</label>' +
                '<select class="calc-input" id="bc-to" style="width: 100px;" onchange="updateBaseConversionVisualizer()">' +
                '<option value="2" selected>Binary</option><option value="10">Decimal</option><option value="16">Hex</option>' +
                '</select></div></div>' +
                '<div class="step-visualizer" id="bc-steps">Enter a number to see step-by-step conversion</div></div>';
        }

        function updateBaseConversionVisualizer() {
            const input = document.getElementById('bc-input').value.trim();
            const fromBase = parseInt(document.getElementById('bc-from').value);
            const toBase = parseInt(document.getElementById('bc-to').value);
            
            if (!input) {
                document.getElementById('bc-steps').innerHTML = 'Enter a number to see step-by-step conversion';
                return;
            }
            
            let dec;
            try {
                dec = parseInt(input, fromBase);
            } catch(e) {
                document.getElementById('bc-steps').innerHTML = 'Invalid input for selected base';
                return;
            }
            
            if (isNaN(dec)) {
                document.getElementById('bc-steps').innerHTML = 'Invalid input';
                return;
            }
            
            let html = '';
            
            if (fromBase === 10 && toBase === 2) {
                html += createStep(1, 'Converting ' + dec + ' from decimal to binary', true);
                let n = dec, steps = [];
                while (n > 0) {
                    steps.push(n + ' / 2 = ' + Math.floor(n/2) + ' remainder ' + n%2);
                    n = Math.floor(n/2);
                }
                html += createStep(2, 'Repeated division by 2:<br><span style="font-family: monospace; font-size: 12px;">' + steps.join('<br>') + '</span>', true);
                html += createStep(3, 'Read remainders <strong>bottom to top</strong>: ' + dec.toString(2), false);
            } else if (fromBase === 10 && toBase === 16) {
                html += createStep(1, 'Converting ' + dec + ' from decimal to hex', true);
                let n = dec, steps = [];
                while (n > 0) {
                    const rem = n % 16;
                    steps.push(n + ' / 16 = ' + Math.floor(n/16) + ' remainder ' + rem.toString(16).toUpperCase());
                    n = Math.floor(n/16);
                }
                html += createStep(2, 'Repeated division by 16:<br><span style="font-family: monospace; font-size: 12px;">' + steps.join('<br>') + '</span>', true);
                html += createStep(3, 'Read remainders <strong>bottom to top</strong>: 0x' + dec.toString(16).toUpperCase(), false);
            } else if (fromBase === 2 && toBase === 16) {
                const bin = dec.toString(2);
                const groups = bin.match(/.{1,4}/g) || [bin];
                html += createStep(1, 'Converting ' + input + ' from binary to hex', true);
                html += createStep(2, 'Group binary into sets of 4 (from right): ' + groups.join(' '), true);
                html += createStep(3, 'Each group = 1 hex digit: 0x' + dec.toString(16).toUpperCase(), false);
            } else {
                html += createStep(1, 'Converting from base ' + fromBase + ' to base ' + toBase, true);
                html += createStep(2, 'First convert to decimal: ' + dec, true);
                html += createStep(3, 'Then to base ' + toBase + ': ' + dec.toString(toBase).toUpperCase(), false);
            }
            
            document.getElementById('bc-steps').innerHTML = html;
        }

        // --- PRACTICE PROBLEM GENERATORS ---
        
        const practiceState = {};

        function createPracticeGenerator(type) {
            const id = 'pg-' + Math.random().toString(36).substr(2, 9);
            
            if (type === 'converter') {
                setTimeout(() => initConverterPractice(id), 100);
                return '<div class="practice-generator">' +
                    '<div class="practice-generator-title">Random Number Converter Practice</div>' +
                    '<div id="' + id + '-problem" class="practice-problem">' +
                    '<div class="practice-problem-text">Convert decimal <strong id="' + id + '-num">42</strong> to hexadecimal</div>' +
                    '<input type="text" class="practice-input" id="' + id + '-answer" placeholder="0x..." onkeypress="if(event.key===\'Enter\')checkConverterPractice(\'' + id + '\')">' +
                    '</div>' +
                    '<div style="text-align: center;">' +
                    '<button class="btn btn-primary" onclick="checkConverterPractice(\'' + id + '\')">Check Answer</button>' +
                    '<button class="btn btn-secondary" onclick="nextConverterPractice(\'' + id + '\')">New Problem</button>' +
                    '</div>' +
                    '<div class="practice-feedback" id="' + id + '-feedback"></div></div>';
            } else if (type === 'ieee') {
                setTimeout(() => initIEEEPractice(id), 100);
                return '<div class="practice-generator">' +
                    '<div class="practice-generator-title">IEEE 754 Encoding Practice</div>' +
                    '<div id="' + id + '-problem" class="practice-problem">' +
                    '<div class="practice-problem-text">Encode <strong id="' + id + '-num">3.14159</strong> in IEEE 754 (hex)</div>' +
                    '<input type="text" class="practice-input" id="' + id + '-answer" placeholder="0x..." onkeypress="if(event.key===\'Enter\')checkIEEEPractice(\'' + id + '\')">' +
                    '</div>' +
                    '<div style="text-align: center;">' +
                    '<button class="btn btn-primary" onclick="checkIEEEPractice(\'' + id + '\')">Check Answer</button>' +
                    '<button class="btn btn-secondary" onclick="nextIEEEPractice(\'' + id + '\')">New Problem</button>' +
                    '</div>' +
                    '<div class="practice-feedback" id="' + id + '-feedback"></div></div>';
            } else if (type === 'addressing') {
                setTimeout(() => initAddressingPractice(id), 100);
                return '<div class="practice-generator">' +
                    '<div class="practice-generator-title">Addressing Mode Identification</div>' +
                    '<div id="' + id + '-problem" class="practice-problem">' +
                    '<div class="practice-problem-text" style="font-family: monospace;" id="' + id + '-instruction">MOV AX, [BX + SI + 4]</div>' +
                    '<div style="margin: 15px 0;">' +
                    '<select class="calc-input" id="' + id + '-answer" style="width: 250px;">' +
                    '<option value="">Select addressing mode...</option>' +
                    '<option value="immediate">Immediate</option>' +
                    '<option value="register">Register</option>' +
                    '<option value="direct">Direct</option>' +
                    '<option value="register-indirect">Register Indirect</option>' +
                    '<option value="based">Based</option>' +
                    '<option value="indexed">Indexed</option>' +
                    '<option value="based-indexed">Based Indexed</option>' +
                    '<option value="based-indexed-disp">Based Indexed with Displacement</option>' +
                    '</select></div></div>' +
                    '<div style="text-align: center;">' +
                    '<button class="btn btn-primary" onclick="checkAddressingPractice(\'' + id + '\')">Check Answer</button>' +
                    '<button class="btn btn-secondary" onclick="nextAddressingPractice(\'' + id + '\')">New Problem</button>' +
                    '</div>' +
                    '<div class="practice-feedback" id="' + id + '-feedback"></div></div>';
            }
            return '';
        }

        function initConverterPractice(id) {
            const modes = [
                { from: 'dec', to: 'hex', label: 'to hexadecimal', fn: n => '0x' + n.toString(16).toUpperCase() },
                { from: 'dec', to: 'bin', label: 'to binary', fn: n => n.toString(2) },
                { from: 'hex', to: 'dec', label: 'to decimal', fn: n => n.toString() },
                { from: 'bin', to: 'dec', label: 'to decimal', fn: n => n.toString() }
            ];
            const mode = modes[Math.floor(Math.random() * modes.length)];
            let num;
            if (mode.from === 'dec') num = Math.floor(Math.random() * 256);
            else if (mode.from === 'hex') num = Math.floor(Math.random() * 256);
            else num = Math.floor(Math.random() * 64);
            
            practiceState[id] = { num, mode, answer: mode.fn(num) };
            
            const displayNum = mode.from === 'hex' ? '0x' + num.toString(16).toUpperCase() : 
                              mode.from === 'bin' ? num.toString(2) : num;
            
            const numEl = document.getElementById(id + '-num');
            if (numEl) {
                numEl.textContent = displayNum;
                document.getElementById(id + '-problem').querySelector('.practice-problem-text').innerHTML = 
                    'Convert <strong>' + displayNum + '</strong> ' + mode.label;
            }
        }

        function checkConverterPractice(id) {
            if (!practiceState[id]) initConverterPractice(id);
            
            const inputEl = document.getElementById(id + '-answer');
            const feedbackEl = document.getElementById(id + '-feedback');
            if (!inputEl || !feedbackEl) return;
            
            const input = inputEl.value.trim().toUpperCase();
            const correct = practiceState[id].answer.toUpperCase();
            
            const isCorrect = input === correct || input === correct.replace('0X', '');
            
            feedbackEl.className = 'practice-feedback show ' + (isCorrect ? 'correct' : 'incorrect');
            feedbackEl.innerHTML = isCorrect ? 
                'Correct!' : 
                'Not quite. The answer is ' + practiceState[id].answer;
        }

        function nextConverterPractice(id) {
            const inputEl = document.getElementById(id + '-answer');
            const feedbackEl = document.getElementById(id + '-feedback');
            if (inputEl) inputEl.value = '';
            if (feedbackEl) feedbackEl.className = 'practice-feedback';
            initConverterPractice(id);
        }

        function initIEEEPractice(id) {
            const nums = [1.0, 2.0, 4.0, 0.5, 3.14159, -1.0, 0.1, 100.0, -0.5, 6.625];
            const num = nums[Math.floor(Math.random() * nums.length)];
            
            const buffer = new ArrayBuffer(4);
            const floatView = new Float32Array(buffer);
            const intView = new Uint32Array(buffer);
            floatView[0] = num;
            
            practiceState[id] = { num, answer: '0x' + intView[0].toString(16).toUpperCase().padStart(8, '0') };
            
            const numEl = document.getElementById(id + '-num');
            if (numEl) numEl.textContent = num;
        }

        function checkIEEEPractice(id) {
            if (!practiceState[id]) initIEEEPractice(id);
            
            const inputEl = document.getElementById(id + '-answer');
            const feedbackEl = document.getElementById(id + '-feedback');
            if (!inputEl || !feedbackEl) return;
            
            const input = inputEl.value.trim().toUpperCase();
            const correct = practiceState[id].answer.toUpperCase();
            
            const isCorrect = input === correct || input === correct.replace('0X', '');
            
            feedbackEl.className = 'practice-feedback show ' + (isCorrect ? 'correct' : 'incorrect');
            feedbackEl.innerHTML = isCorrect ? 
                'Correct!' : 
                'Not quite. The answer is ' + practiceState[id].answer;
        }

        function nextIEEEPractice(id) {
            const inputEl = document.getElementById(id + '-answer');
            const feedbackEl = document.getElementById(id + '-feedback');
            if (inputEl) inputEl.value = '';
            if (feedbackEl) feedbackEl.className = 'practice-feedback';
            initIEEEPractice(id);
        }

        function initAddressingPractice(id) {
            const problems = [
                { instr: 'MOV AX, 5', mode: 'immediate', desc: 'The value 5 is used directly' },
                { instr: 'MOV AX, BX', mode: 'register', desc: 'Data is in register BX' },
                { instr: 'MOV AX, [1000h]', mode: 'direct', desc: 'Direct memory address' },
                { instr: 'MOV AX, [BX]', mode: 'register-indirect', desc: 'BX contains the address' },
                { instr: 'MOV AX, [BX + 4]', mode: 'based', desc: 'Base register + displacement' },
                { instr: 'MOV AX, [SI + 8]', mode: 'indexed', desc: 'Index register + displacement' },
                { instr: 'MOV AX, [BX + SI]', mode: 'based-indexed', desc: 'Base + Index registers' },
                { instr: 'MOV AX, [BX + SI + 4]', mode: 'based-indexed-disp', desc: 'Base + Index + displacement' }
            ];
            const problem = problems[Math.floor(Math.random() * problems.length)];
            practiceState[id] = problem;
            
            const instrEl = document.getElementById(id + '-instruction');
            if (instrEl) instrEl.textContent = problem.instr;
        }

        function checkAddressingPractice(id) {
            if (!practiceState[id]) initAddressingPractice(id);
            
            const inputEl = document.getElementById(id + '-answer');
            const feedbackEl = document.getElementById(id + '-feedback');
            if (!inputEl || !feedbackEl) return;
            
            const input = inputEl.value;
            const correct = practiceState[id].mode;
            
            const isCorrect = input === correct;
            
            feedbackEl.className = 'practice-feedback show ' + (isCorrect ? 'correct' : 'incorrect');
            feedbackEl.innerHTML = isCorrect ? 
                'Correct!' : 
                'Not quite. This is <strong>' + practiceState[id].mode.replace(/-/g, ' ') + '</strong> addressing.<br>' + practiceState[id].desc;
        }

        function nextAddressingPractice(id) {
            const inputEl = document.getElementById(id + '-answer');
            const feedbackEl = document.getElementById(id + '-feedback');
            if (inputEl) inputEl.value = '';
            if (feedbackEl) feedbackEl.className = 'practice-feedback';
            initAddressingPractice(id);
        }

        // --- QUICK REFERENCE CARDS ---
        
        function createQuickReferenceCard(type) {
            if (type === 'registers') {
                return '<div class="quick-ref-card" onclick="toggleQuickRef(this)">' +
                    '<div class="quick-ref-header"><span class="quick-ref-title">Register Quick Reference</span><span class="quick-ref-toggle">Click to expand</span></div>' +
                    '<div class="quick-ref-content"><div class="ref-grid">' +
                    '<div class="ref-item"><div class="ref-item-name">AX (Accumulator)</div><div class="ref-item-desc">Arithmetic, I/O, returns. Parts: AH, AL</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">BX (Base)</div><div class="ref-item-desc">Memory addressing, pointers. Parts: BH, BL</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">CX (Count)</div><div class="ref-item-desc">Loop counter, string ops. Parts: CH, CL</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">DX (Data)</div><div class="ref-item-desc">I/O, MUL/DIV high bits. Parts: DH, DL</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">SI / DI</div><div class="ref-item-desc">Source/Destination Index for strings</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">SP / BP</div><div class="ref-item-desc">Stack Pointer / Base Pointer</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">CS / DS / SS / ES</div><div class="ref-item-desc">Code, Data, Stack, Extra Segments</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">IP</div><div class="ref-item-desc">Instruction Pointer (next instruction)</div></div>' +
                    '</div></div></div>';
            } else if (type === 'flags') {
                return '<div class="quick-ref-card" onclick="toggleQuickRef(this)">' +
                    '<div class="quick-ref-header"><span class="quick-ref-title">Flags Quick Reference</span><span class="quick-ref-toggle">Click to expand</span></div>' +
                    '<div class="quick-ref-content"><div class="ref-grid">' +
                    '<div class="ref-item"><div class="ref-item-name">CF (Carry Flag)</div><div class="ref-item-desc">Unsigned overflow. 255 + 1 = 0, CF=1</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">ZF (Zero Flag)</div><div class="ref-item-desc">Result is zero. Used for equality</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">SF (Sign Flag)</div><div class="ref-item-desc">Result is negative (MSB = 1)</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">OF (Overflow Flag)</div><div class="ref-item-desc">Signed overflow. 127 + 1 = -128</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">PF (Parity Flag)</div><div class="ref-item-desc">Even number of 1s in low byte</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">AF (Auxiliary)</div><div class="ref-item-desc">Carry/borrow from bit 3 (BCD)</div></div>' +
                    '</div>' +
                    '<div style="margin-top: 15px; padding: 10px; background: rgba(231, 76, 60, 0.1); border-radius: 6px;">' +
                    '<strong>Key Distinction:</strong> CF = UNSIGNED overflow, OF = SIGNED overflow</div></div></div>';
            } else if (type === 'instructions') {
                return '<div class="quick-ref-card" onclick="toggleQuickRef(this)">' +
                    '<div class="quick-ref-header"><span class="quick-ref-title">Common Instructions</span><span class="quick-ref-toggle">Click to expand</span></div>' +
                    '<div class="quick-ref-content"><div class="ref-grid">' +
                    '<div class="ref-item"><div class="ref-item-name">MOV dest, src</div><div class="ref-item-desc">Copy data. Does NOT affect flags!</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">ADD / SUB</div><div class="ref-item-desc">Add/Subtract. Affects all flags</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">INC / DEC</div><div class="ref-item-desc">Increment/Decrement. Does NOT affect CF!</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">CMP a, b</div><div class="ref-item-desc">Compare (subtract, no store). Sets flags</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">AND / OR / XOR</div><div class="ref-item-desc">Bitwise ops. CF=0, OF=0 after</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">SHL / SHR / SAR</div><div class="ref-item-desc">Shift ops. CF gets shifted bit</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">PUSH / POP</div><div class="ref-item-desc">Stack operations. SP changes by 2</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">CALL / RET</div><div class="ref-item-desc">Call/return from procedure</div></div>' +
                    '</div></div></div>';
            } else if (type === 'int21h') {
                return '<div class="quick-ref-card" onclick="toggleQuickRef(this)">' +
                    '<div class="quick-ref-header"><span class="quick-ref-title">INT 21h Functions</span><span class="quick-ref-toggle">Click to expand</span></div>' +
                    '<div class="quick-ref-content"><div class="ref-grid">' +
                    '<div class="ref-item"><div class="ref-item-name">AH = 01h - Read Char</div><div class="ref-item-desc">Waits for key, echoes. Returns in AL</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">AH = 02h - Write Char</div><div class="ref-item-desc">DL = character to display</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">AH = 09h - Display String</div><div class="ref-item-desc">DS:DX = address of $-terminated string</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">AH = 0Ah - Buffered Input</div><div class="ref-item-desc">DS:DX = input buffer structure</div></div>' +
                    '<div class="ref-item"><div class="ref-item-name">AH = 4Ch - Exit</div><div class="ref-item-desc">AL = return code (0 = success)</div></div>' +
                    '</div></div></div>';
            }
            return '';
        }

        function toggleQuickRef(card) {
            card.classList.toggle('expanded');
            const content = card.querySelector('.quick-ref-content');
            const toggle = card.querySelector('.quick-ref-toggle');
            content.classList.toggle('show');
            toggle.textContent = content.classList.contains('show') ? 'Click to collapse' : 'Click to expand';
        }

        // --- EXAM PREP SECTION ---
        
        function createExamPrepSection() {
            return '<div class="card" style="margin-top: 30px;">' +
                '<div class="card-header"><h2>Exam Prep Center</h2></div>' +
                '<div class="cheat-sheet">' +
                '<div class="cheat-sheet-title">Formula Cheat Sheet</div>' +
                '<div class="cheat-formula"><div class="cheat-formula-name">Two\'s Complement (Negative Numbers)</div>' +
                '<div class="cheat-formula-math">Representation = 2^n + N (where N < 0)</div>' +
                '<div style="font-size: 12px; color: var(--text-muted); margin-top: 5px;">Range: -2^(n-1) to 2^(n-1) - 1</div></div>' +
                '<div class="cheat-formula"><div class="cheat-formula-name">Physical Address (Real Mode)</div>' +
                '<div class="cheat-formula-math">Physical = Segment * 16 + Offset</div>' +
                '<div style="font-size: 12px; color: var(--text-muted); margin-top: 5px;">Also: (Segment << 4) + Offset</div></div>' +
                '<div class="cheat-formula"><div class="cheat-formula-name">IEEE 754 Single Precision</div>' +
                '<div class="cheat-formula-math">Value = (-1)^S * 1.M * 2^(E-127)</div>' +
                '<div style="font-size: 12px; color: var(--text-muted); margin-top: 5px;">Bias = 127, 1 bit sign + 8 bits exponent + 23 bits mantissa</div></div>' +
                '<div class="cheat-formula"><div class="cheat-formula-name">ASCII Conversion</div>' +
                '<div class="cheat-formula-math">Digit to ASCII: + 30h | ASCII to Digit: - 30h</div>' +
                '<div style="font-size: 12px; color: var(--text-muted); margin-top: 5px;">\'0\' = 30h, \'A\' = 41h, \'a\' = 61h</div></div>' +
                '<div class="cheat-formula"><div class="cheat-formula-name">Shift Operations</div>' +
                '<div class="cheat-formula-math">SHL n = * 2^n | SHR n = / 2^n (unsigned)</div>' +
                '<div style="font-size: 12px; color: var(--text-muted); margin-top: 5px;">Use SAR for signed division (preserves sign)</div></div>' +
                '</div>' +
                '<div style="background: var(--bg); padding: 20px; border-radius: 12px; margin-top: 20px;">' +
                '<h3 style="color: var(--primary); text-align: center;">Timed Practice Mode</h3>' +
                '<div class="timer-display"><div class="timer-value" id="exam-timer">60</div><div class="timer-label">seconds</div></div>' +
                '<div id="timed-question" style="text-align: center; font-size: 1.2rem; margin-bottom: 20px;">Click Start to begin timed practice</div>' +
                '<div class="answers-grid" id="timed-answers" style="max-width: 500px; margin: 0 auto;"></div>' +
                '<div id="timed-feedback" style="text-align: center; margin-top: 15px; min-height: 30px;"></div>' +
                '<div style="text-align: center; margin-top: 20px;">' +
                '<button class="btn btn-primary" id="start-timed-btn" onclick="startTimedPractice()">Start Timed Practice</button>' +
                '<button class="btn btn-secondary" id="stop-timed-btn" onclick="stopTimedPractice()" style="display: none;">Stop</button>' +
                '</div>' +
                '<div style="text-align: center; margin-top: 15px; color: var(--text-muted);">' +
                'Score: <span id="timed-score">0</span> | Streak: <span id="timed-streak">0</span>' +
                '</div></div>' +
                '<div style="margin-top: 30px;">' +
                '<h3 style="color: var(--accent); margin-bottom: 15px;">Common Exam Questions with Solutions</h3>' +
                createCommonExamQuestions() +
                '</div></div>';
        }

        function createCommonExamQuestions() {
            const questions = [
                {
                    q: "Convert -73 to 8-bit two's complement",
                    solution: "Step 1: |73| = 73 = 01001001<br>Step 2: Invert = 10110110<br>Step 3: Add 1 = 10110111 = 0xB7",
                    answer: "0xB7"
                },
                {
                    q: "Calculate physical address for Segment=0x1234, Offset=0x5678",
                    solution: "Physical = 0x1234 * 16 + 0x5678<br>= 0x12340 + 0x5678<br>= 0x179B8",
                    answer: "0x179B8"
                },
                {
                    q: "What is the value of FLAGS after MOV AL, 0 followed by ADD AL, 0?",
                    solution: "MOV doesn't affect flags. ADD AL, 0 results in 0, so:<br>ZF=1 (zero result), SF=0 (not negative),<br>CF=0 (no carry), PF=1 (even parity)",
                    answer: "ZF=1, SF=0, CF=0, PF=1"
                },
                {
                    q: "How is 0x1234 stored in little-endian memory at 0x100?",
                    solution: "Little-endian: low byte first<br>0x100: 0x34<br>0x101: 0x12",
                    answer: "[0x100]=0x34, [0x101]=0x12"
                },
                {
                    q: "Convert decimal 5.75 to IEEE 754 single precision",
                    solution: "5.75 = 101.11 = 1.0111 * 2^2<br>Sign=0, Exp=2+127=129=10000001,<br>Mantissa=0111000...<br>Result: 0x40B80000",
                    answer: "0x40B80000"
                }
            ];
            
            return questions.map((q, i) => 
                '<div class="quick-ref-card" onclick="toggleQuickRef(this)">' +
                '<div class="quick-ref-header"><span class="quick-ref-title">Q' + (i+1) + ': ' + q.q + '</span><span class="quick-ref-toggle">View Solution</span></div>' +
                '<div class="quick-ref-content"><div style="background: rgba(74, 144, 217, 0.1); padding: 15px; border-radius: 8px;">' +
                '<strong>Solution:</strong><br>' + q.solution +
                '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border);">' +
                '<strong>Answer:</strong> <span style="color: var(--success);">' + q.answer + '</span></div></div></div></div>'
            ).join('');
        }

        // Timed Practice State
        let timedPracticeState = {
            active: false,
            timer: null,
            timeLeft: 60,
            score: 0,
            streak: 0,
            currentQuestion: null
        };

        function startTimedPractice() {
            timedPracticeState.active = true;
            timedPracticeState.timeLeft = 60;
            timedPracticeState.score = 0;
            timedPracticeState.streak = 0;
            
            document.getElementById('start-timed-btn').style.display = 'none';
            document.getElementById('stop-timed-btn').style.display = 'inline-block';
            
            nextTimedQuestion();
            
            timedPracticeState.timer = setInterval(() => {
                timedPracticeState.timeLeft--;
                document.getElementById('exam-timer').textContent = timedPracticeState.timeLeft;
                
                if (timedPracticeState.timeLeft <= 10) {
                    document.getElementById('exam-timer').style.color = 'var(--danger)';
                }
                
                if (timedPracticeState.timeLeft <= 0) {
                    stopTimedPractice();
                    alert('Time is up! Final score: ' + timedPracticeState.score);
                }
            }, 1000);
        }

        function stopTimedPractice() {
            timedPracticeState.active = false;
            clearInterval(timedPracticeState.timer);
            document.getElementById('start-timed-btn').style.display = 'inline-block';
            document.getElementById('stop-timed-btn').style.display = 'none';
            document.getElementById('exam-timer').textContent = '60';
            document.getElementById('exam-timer').style.color = 'var(--danger)';
        }

        function nextTimedQuestion() {
            const types = ['hex', 'binary', 'flags', 'register'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let question, options, correct;
            
            if (type === 'hex') {
                const dec = Math.floor(Math.random() * 256);
                question = 'Convert decimal ' + dec + ' to hex:';
                correct = '0x' + dec.toString(16).toUpperCase();
                options = generateHexOptions(dec);
            } else if (type === 'binary') {
                const dec = Math.floor(Math.random() * 32);
                question = 'Convert decimal ' + dec + ' to binary:';
                correct = dec.toString(2);
                options = generateBinaryOptions(dec);
            } else if (type === 'flags') {
                const flagQuestions = [
                    { q: 'Which flag indicates zero result?', a: 'ZF', opts: ['CF', 'ZF', 'SF', 'OF'] },
                    { q: 'Which flag indicates unsigned overflow?', a: 'CF', opts: ['CF', 'ZF', 'SF', 'OF'] },
                    { q: 'Which flag indicates signed overflow?', a: 'OF', opts: ['CF', 'ZF', 'SF', 'OF'] }
                ];
                const fq = flagQuestions[Math.floor(Math.random() * flagQuestions.length)];
                question = fq.q;
                correct = fq.a;
                options = fq.opts;
            } else {
                const regQuestions = [
                    { q: 'Which register is used for loop counting?', a: 'CX', opts: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Which register points to stack top?', a: 'SP', opts: ['BP', 'SP', 'IP', 'SI'] },
                    { q: 'Which is the accumulator register?', a: 'AX', opts: ['AX', 'BX', 'CX', 'DX'] }
                ];
                const rq = regQuestions[Math.floor(Math.random() * regQuestions.length)];
                question = rq.q;
                correct = rq.a;
                options = rq.opts;
            }
            
            timedPracticeState.currentQuestion = { question, options, correct };
            
            document.getElementById('timed-question').textContent = question;
            document.getElementById('timed-answers').innerHTML = options.map((opt) => 
                '<button class="answer-btn" onclick="checkTimedAnswer(\'' + opt + '\', \'' + correct + '\')">' + opt + '</button>'
            ).join('');
            document.getElementById('timed-feedback').innerHTML = '';
        }

        function generateHexOptions(dec) {
            const correct = '0x' + dec.toString(16).toUpperCase();
            const options = [correct];
            while (options.length < 4) {
                const wrong = '0x' + Math.floor(Math.random() * 256).toString(16).toUpperCase();
                if (!options.includes(wrong)) options.push(wrong);
            }
            return options.sort(() => Math.random() - 0.5);
        }

        function generateBinaryOptions(dec) {
            const correct = dec.toString(2);
            const options = [correct];
            while (options.length < 4) {
                const wrong = Math.floor(Math.random() * 32).toString(2);
                if (!options.includes(wrong)) options.push(wrong);
            }
            return options.sort(() => Math.random() - 0.5);
        }

        function checkTimedAnswer(selected, correct) {
            const feedback = document.getElementById('timed-feedback');
            
            if (selected === correct) {
                timedPracticeState.score += 10 + (timedPracticeState.streak > 2 ? 5 : 0);
                timedPracticeState.streak++;
                feedback.innerHTML = '<span style="color: var(--success);">Correct! +' + (10 + (timedPracticeState.streak > 2 ? 5 : 0)) + ' points</span>';
            } else {
                timedPracticeState.streak = 0;
                feedback.innerHTML = '<span style="color: var(--danger);">Wrong! Answer: ' + correct + '</span>';
            }
            
            document.getElementById('timed-score').textContent = timedPracticeState.score;
            document.getElementById('timed-streak').textContent = timedPracticeState.streak;
            
            setTimeout(nextTimedQuestion, 1500);
        }

        // Override renderSection to include inline quizzes
        const originalRenderSection = renderSection;
        renderSection = function(section) {
            let html = originalRenderSection(section);
            
            const quizTopics = {
                'number-systems': 'number-systems',
                'twos-complement': 'twos-complement',
                'ieee754': 'ieee754',
                'registers': 'registers',
                'flags': 'flags',
                'addressing-modes': 'addressing-modes',
                'interrupts': 'interrupts',
                'bitwise-operations': 'bitwise'
            };
            
            if (section.id && quizTopics[section.id]) {
                html = html.replace('</div>', createInlineQuiz(quizTopics[section.id]) + '</div>');
            }
            
            return html;
        };
        
        // Override renderLecture to add interactive explorers and reference cards
        const originalRenderLecture = renderLecture;
        renderLecture = function(index) {
            originalRenderLecture(index);
            
            const lecture = lecturesData[index];
            if (!lecture) return;
            
            let extraContent = '';
            
            if (index === 1) {
                extraContent += createTwosComplementExplorer();
                extraContent += createBaseConversionVisualizer();
                extraContent += createPracticeGenerator('converter');
            } else if (index === 2) {
                extraContent += createIEEE754Explorer();
                extraContent += createPracticeGenerator('ieee');
            } else if (index === 3) {
                extraContent += createQuickReferenceCard('registers');
                extraContent += createQuickReferenceCard('flags');
                extraContent += createQuickReferenceCard('instructions');
            } else if (index === 4) {
                extraContent += createPracticeGenerator('addressing');
                extraContent += createQuickReferenceCard('int21h');
            }
            
            extraContent += createExamPrepSection();
            
            if (extraContent) {
                const contentDiv = document.getElementById('lecture-content');
                if (contentDiv) contentDiv.innerHTML += extraContent;
            }
        };

        // Re-render current lecture
        renderLecture(currentLecture);

    </script>
</body>
</html>
