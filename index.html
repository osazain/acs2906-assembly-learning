<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACS2906 Assembly Language Learning App - Complete Edition</title>
    <style>
        /* ============================================
           COMPLETE CSS STYLES
           ============================================ */
        :root {
            --primary: #4a90d9;
            --primary-dark: #357abd;
            --secondary: #5cb85c;
            --accent: #f0ad4e;
            --danger: #d9534f;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --bg: #1a1a2e;
            --card-bg: #16213e;
            --text: #e0e0e0;
            --text-muted: #888;
            --border: #0f3460;
            --success: #27ae60;
            --warning: #f39c12;
            --info: #3498db;
            --reg-ax: #FF6B6B;
            --reg-bx: #4ECDC4;
            --reg-cx: #45B7D1;
            --reg-dx: #96CEB4;
            --reg-si: #FFE66D;
            --reg-di: #FFE66D;
            --reg-bp: #FF6B9D;
            --reg-sp: #FF6B9D;
            --reg-cs: #C7CEEA;
            --reg-ds: #C7CEEA;
            --reg-ss: #C7CEEA;
            --reg-es: #C7CEEA;
            --flag-set: #27ae60;
            --flag-unset: #555;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Navigation */
        nav {
            background: var(--card-bg);
            border-bottom: 2px solid var(--border);
            padding: 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            max-width: 1400px;
            margin: 0 auto;
        }

        .nav-tab {
            padding: 15px 20px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

        .nav-tab:hover {
            color: var(--text);
            background: rgba(74, 144, 217, 0.1);
        }

        .nav-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        /* Main Content */
        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1, h2, h3, h4 {
            color: var(--primary);
            margin-bottom: 15px;
        }

        h1 { font-size: 2rem; }
        h2 { font-size: 1.5rem; }
        h3 { font-size: 1.25rem; }

        /* Cards */
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--dark);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }

        /* Lecture Section Styles */
        .lecture-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .lecture-btn {
            padding: 10px 20px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lecture-btn:hover, .lecture-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        .lecture-content {
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 10px;
        }

        .lecture-content::-webkit-scrollbar {
            width: 8px;
        }

        .lecture-content::-webkit-scrollbar-track {
            background: var(--bg);
        }

        .lecture-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .page-content {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .page-number {
            background: var(--primary);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .content-tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 10px;
            margin-right: 5px;
        }

        .tag-code { background: #e74c3c; }
        .tag-math { background: #9b59b6; }
        .tag-def { background: #3498db; }
        .tag-exam { background: #f39c12; }

        /* Calculator Styles */
        .calc-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .calc-panel {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
        }

        .calc-title {
            color: var(--primary);
            font-size: 1.1rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .calc-input-group {
            margin-bottom: 15px;
        }

        .calc-label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-muted);
            font-size: 12px;
        }

        .calc-input {
            width: 100%;
            padding: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text);
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .calc-output {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
        }

        .calc-explanation {
            background: rgba(74, 144, 217, 0.1);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            margin-top: 10px;
            font-size: 13px;
        }

        .base-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .base-tab {
            padding: 8px 15px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            cursor: pointer;
            border-radius: 5px;
            font-size: 12px;
        }

        .base-tab.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        /* Simulator Styles */
        .simulator-container {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
        }

        .sim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .sim-main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 900px) {
            .sim-main {
                grid-template-columns: 1fr;
            }
        }

        .reg-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-muted);
        }

        .gp-registers {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .reg-card {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reg-card:hover {
            border-color: var(--primary);
        }

        .reg-card.selected {
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(240, 173, 78, 0.3);
        }

        .reg-name {
            font-weight: bold;
            font-size: 14px;
        }

        .reg-value {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: var(--primary);
        }

        .reg-binary {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .reg-8bit-row {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }

        .reg-8bit {
            flex: 1;
            background: rgba(255,255,255,0.05);
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
        }

        .reg-8bit:hover {
            background: rgba(255,255,255,0.1);
        }

        .index-regs, .segment-regs, .special-regs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .simple-reg {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            text-align: center;
        }

        .simple-reg:hover {
            border-color: var(--primary);
        }

        .flags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .flag-item {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--bg);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .flag-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--flag-unset);
        }

        .flag-indicator.set {
            background: var(--flag-set);
            box-shadow: 0 0 8px var(--flag-set);
        }

        .op-panel {
            background: var(--bg);
            border-radius: 8px;
            padding: 15px;
        }

        .op-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .op-btn {
            padding: 10px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .op-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .op-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .imm-input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .imm-input {
            flex: 1;
            padding: 10px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text);
            font-family: monospace;
        }

        .code-panel {
            background: var(--bg);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .code-display {
            font-family: 'Courier New', monospace;
            background: #0d1117;
            padding: 15px;
            border-radius: 5px;
            min-height: 150px;
            white-space: pre-wrap;
            color: #c9d1d9;
            line-height: 1.8;
        }

        .code-line {
            display: flex;
        }

        .line-num {
            color: #484f58;
            width: 30px;
            text-align: right;
            margin-right: 15px;
            user-select: none;
        }

        .line-content {
            flex: 1;
        }

        .mnemonic { color: #ff7b72; }
        .register { color: #79c0ff; }
        .immediate { color: #a5d6ff; }
        .comment { color: #8b949e; }
        .directive { color: #d2a8ff; }

        .example-select {
            margin-bottom: 15px;
        }

        /* Flashcard Styles */
        .flashcard-container {
            max-width: 600px;
            margin: 0 auto;
        }

        .flashcard-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-badge {
            background: var(--card-bg);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
        }

        .flashcard {
            background: var(--card-bg);
            border: 2px solid var(--border);
            border-radius: 15px;
            min-height: 300px;
            perspective: 1000px;
            cursor: pointer;
            position: relative;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .card-front {
            z-index: 2;
        }

        .card-back {
            transform: rotateY(180deg);
            background: var(--bg);
        }

        .card-category {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--primary);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 11px;
        }

        .card-question {
            font-size: 1.3rem;
            line-height: 1.6;
        }

        .card-answer {
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .flashcard-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .fc-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .fc-btn-know { background: var(--success); color: white; }
        .fc-btn-dont { background: var(--danger); color: white; }
        .fc-btn-shuffle { background: var(--accent); color: var(--dark); }

        /* Games Section Styles */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .game-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .game-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .game-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .game-desc {
            color: var(--text-muted);
            font-size: 13px;
            margin-bottom: 15px;
        }

        .game-container {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
        }

        .game-header-compact {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .btn-back {
            padding: 8px 15px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
        }

        .game-stats-bar {
            display: flex;
            gap: 10px;
        }

        .stat-box {
            background: var(--bg);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
        }

        .difficulty-selector-enhanced {
            background: var(--bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .diff-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .diff-btn {
            padding: 8px 20px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
        }

        .diff-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        .answers-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .answer-btn {
            padding: 15px;
            background: var(--bg);
            border: 2px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .answer-btn:hover {
            border-color: var(--primary);
            background: rgba(74, 144, 217, 0.1);
        }

        .answer-btn.correct {
            background: var(--success);
            border-color: var(--success);
        }

        .answer-btn.wrong {
            background: var(--danger);
            border-color: var(--danger);
        }

        .timer-bar {
            background: var(--bg);
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            margin-bottom: 20px;
        }

        .timer-progress {
            background: linear-gradient(90deg, var(--success), var(--accent));
            height: 100%;
            width: 100%;
            transition: width 1s linear;
        }

        .timer-progress.urgent {
            background: var(--danger);
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
        }

        .hidden { display: none !important; }

        /* Test Styles */
        .test-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .test-progress {
            background: var(--bg);
            height: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .test-progress-bar {
            background: var(--primary);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .options-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-btn {
            text-align: left;
            padding: 15px 20px;
            background: var(--bg);
            border: 2px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-btn:hover {
            border-color: var(--primary);
        }

        .option-btn.selected {
            background: var(--primary);
            border-color: var(--primary);
        }

        .option-btn.correct {
            background: var(--success);
            border-color: var(--success);
        }

        .option-btn.incorrect {
            background: var(--danger);
            border-color: var(--danger);
        }

        .explanation-box {
            background: rgba(74, 144, 217, 0.1);
            border-left: 4px solid var(--primary);
            padding: 15px 20px;
            margin-top: 20px;
            border-radius: 0 8px 8px 0;
        }

        .test-results {
            text-align: center;
            padding: 40px;
        }

        .score-circle {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin: 20px auto;
            border: 5px solid var(--primary);
        }

        .score-value {
            font-size: 3rem;
            font-weight: bold;
            color: var(--primary);
        }

        .score-label {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Keypad for Hex Hunter */
        .keypad {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-width: 300px;
            margin: 20px auto;
        }

        .keypad-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .key {
            width: 60px;
            height: 50px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }

        .key:hover {
            background: var(--primary);
        }

        .key.hex {
            background: rgba(155, 89, 182, 0.2);
        }

        .key.control {
            background: var(--card-bg);
        }

        .key.enter {
            background: var(--success);
            width: 80px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .nav-tabs {
                overflow-x: auto;
                flex-wrap: nowrap;
            }

            .sim-main {
                grid-template-columns: 1fr;
            }

            .gp-registers {
                grid-template-columns: 1fr;
            }

            .op-buttons {
                grid-template-columns: repeat(2, 1fr);
            }

            .answers-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <nav>
        <div class="nav-tabs">
            <button class="nav-tab active" data-section="lectures">üìö Lectures</button>
            <button class="nav-tab" data-section="calculator">üßÆ Calculator</button>
            <button class="nav-tab" data-section="simulator">üîß Simulator</button>
            <button class="nav-tab" data-section="flashcards">üé¥ Flashcards</button>
            <button class="nav-tab" data-section="games">üéÆ Games</button>
            <button class="nav-tab" data-section="tests">üìù Tests</button>
        </div>
        <div style="margin-left: auto; padding: 10px 20px; font-size: 12px; color: var(--text-muted);">by <span style="color: var(--primary);">OsaZain</span></div>
    </nav>

    <main>
        <!-- LECTURES SECTION -->
        <section id="lectures" class="active">
            <div class="card">
                <div class="card-header">
                    <h2>üìö ACS2906 Assembly Learning Guide <span style="font-size: 14px; color: var(--primary); font-weight: normal;">by OsaZain</span></h2><p style="color: var(--text-muted); margin-top: 5px;">Beginner-friendly explanations, formulas & examples</p>
                </div>
                <div class="lecture-nav" id="lecture-nav">
                    <button class="lecture-btn active" data-lecture="0">üìò L1: Computer Systems</button>
                    <button class="lecture-btn" data-lecture="1">üìó L2: Data Representation</button>
                    <button class="lecture-btn" data-lecture="2">üìô L3: Floating Point</button>
                    <button class="lecture-btn" data-lecture="3">üìï L4: Assembly Basics</button>
                    <button class="lecture-btn" data-lecture="4">üìì L5: I/O & Addressing</button>
                </div>
                <div class="lecture-content" id="lecture-content">
                    <!-- Lecture content populated by JavaScript -->
                </div>
            </div>
        </section>

        <!-- CALCULATOR SECTION -->
        <section id="calculator">
            <h2>üßÆ Assembly Calculators</h2>
            <div class="calc-grid">
                <!-- Base Converter -->
                <div class="calc-panel">
                    <div class="calc-title">üî¢ Base Converter (Dec/Bin/Hex/Oct)</div>
                    <div class="base-tabs">
                        <button class="base-tab active" data-base="dec">Decimal</button>
                        <button class="base-tab" data-base="bin">Binary</button>
                        <button class="base-tab" data-base="hex">Hex</button>
                        <button class="base-tab" data-base="oct">Octal</button>
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Input Value:</label>
                        <input type="text" class="calc-input" id="base-input" placeholder="Enter value...">
                        <button class="btn btn-primary" id="base-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="base-output">
                        <div>Decimal: <span id="out-dec">-</span></div>
                        <div>Binary: <span id="out-bin">-</span></div>
                        <div>Hexadecimal: <span id="out-hex">-</span></div>
                        <div>Octal: <span id="out-oct">-</span></div>
                    </div>
                    <div class="calc-explanation" id="base-explanation">
                        Enter a number to see conversions with detailed explanations.
                    </div>
                </div>

                <!-- IEEE 754 Converter -->
                <div class="calc-panel">
                    <div class="calc-title">üî¨ IEEE 754 Floating Point</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Decimal Number:</label>
                        <input type="text" class="calc-input" id="ieee-input" placeholder="e.g., 3.14159">
                        <button class="btn btn-primary" id="ieee-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="ieee-output">
                        <div>Sign: <span id="ieee-sign">-</span></div>
                        <div>Exponent: <span id="ieee-exp">-</span></div>
                        <div>Mantissa: <span id="ieee-mant">-</span></div>
                        <div>32-bit Hex: <span id="ieee-hex">-</span></div>
                        <div>Binary: <span id="ieee-bin">-</span></div>
                    </div>
                    <div class="calc-explanation" id="ieee-explanation">
                        Enter a decimal number to see its IEEE 754 single-precision representation.
                    </div>
                </div>

                <!-- Two's Complement -->
                <div class="calc-panel">
                    <div class="calc-title">‚ûï‚ûñ Two's Complement</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Decimal Number (can be negative):</label>
                        <input type="text" class="calc-input" id="twos-input" placeholder="e.g., -42">
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Bit Width:</label>
                        <select class="calc-input" id="twos-bits">
                            <option value="8">8-bit</option>
                            <option value="16" selected>16-bit</option>
                            <option value="32">32-bit</option>
                        </select>
                        <button class="btn btn-primary" id="twos-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="twos-output">
                        <div>Binary: <span id="twos-bin">-</span></div>
                        <div>Hexadecimal: <span id="twos-hex">-</span></div>
                        <div>Decimal: <span id="twos-dec">-</span></div>
                    </div>
                    <div class="calc-explanation" id="twos-explanation">
                        Two's complement representation for signed integers.
                    </div>
                </div>

                <!-- ASCII Converter -->
                <div class="calc-panel">
                    <div class="calc-title">üî§ ASCII Converter</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Text:</label>
                        <input type="text" class="calc-input" id="ascii-text" placeholder="Enter text...">
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Or ASCII Codes (space separated):</label>
                        <input type="text" class="calc-input" id="ascii-codes" placeholder="e.g., 65 66 67">
                        <button class="btn btn-primary" id="ascii-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="ascii-output">
                        <div>Hex: <span id="ascii-hex">-</span></div>
                        <div>Decimal: <span id="ascii-dec">-</span></div>
                        <div>Binary: <span id="ascii-bin">-</span></div>
                    </div>
                    <div class="calc-explanation" id="ascii-explanation">
                        Convert between text and ASCII representations.
                    </div>
                </div>

                <!-- Bitwise Operations -->
                <div class="calc-panel">
                    <div class="calc-title">‚öôÔ∏è Bitwise Operations</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Operand A (hex):</label>
                        <input type="text" class="calc-input" id="bit-a" placeholder="0xFF00">
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Operand B (hex):</label>
                        <input type="text" class="calc-input" id="bit-b" placeholder="0x0F0F">
                        <button class="btn btn-primary" id="bit-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="bit-output">
                        <div>AND: <span id="bit-and">-</span></div>
                        <div>OR: <span id="bit-or">-</span></div>
                        <div>XOR: <span id="bit-xor">-</span></div>
                        <div>NOT A: <span id="bit-not">-</span></div>
                        <div>A &lt;&lt; 1: <span id="bit-shl">-</span></div>
                        <div>A &gt;&gt; 1: <span id="bit-shr">-</span></div>
                    </div>
                    <div class="calc-explanation" id="bit-explanation">
                        Bitwise operations commonly used in assembly programming.
                    </div>
                </div>

                <!-- Address Calculator -->
                <div class="calc-panel">
                    <div class="calc-title">üìç Memory Address Calculator</div>
                    <div class="calc-input-group">
                        <label class="calc-label">Segment (hex):</label>
                        <input type="text" class="calc-input" id="addr-seg" placeholder="0x0000">
                    </div>
                    <div class="calc-input-group">
                        <label class="calc-label">Offset (hex):</label>
                        <input type="text" class="calc-input" id="addr-off" placeholder="0x0000">
                        <button class="btn btn-primary" id="addr-calc-btn" style="margin-top: 10px;">Calculate</button>
                    </div>
                    <div class="calc-output" id="addr-output">
                        <div>Physical Address: <span id="addr-physical">-</span></div>
                        <div>Calculation: <span id="addr-calc">-</span></div>
                    </div>
                    <div class="calc-explanation">
                        x86 real-mode addressing: Physical = Segment √ó 16 + Offset
                    </div>
                </div>
            </div>
        </section>

        <!-- SIMULATOR SECTION -->
        <section id="simulator">
            <div class="simulator-container">
                <div class="sim-header">
                    <h2>üîß 8086 CPU Simulator</h2>
                    <div>
                        <button class="btn btn-secondary" id="sim-reset">üîÑ Reset</button>
                        <button class="btn btn-secondary" id="sim-undo">‚Ü©Ô∏è Undo</button>
                        <select class="example-select" id="example-select">
                            <option value="">-- Load Example --</option>
                            <option value="hello">Hello World Setup</option>
                            <option value="add">Addition Example</option>
                            <option value="loop">Loop Counter</option>
                            <option value="string">String Operation</option>
                            <option value="stack">Stack Operations</option>
                            <option value="flags">Flags Demo</option>
                        </select>
                    </div>
                </div>
                <div class="sim-main">
                    <div class="reg-section">
                        <h3>üìä General Purpose Registers</h3>
                        <div class="gp-registers">
                            <div class="reg-card" data-reg="AX" style="--reg-color: var(--reg-ax)">
                                <div class="reg-name">AX</div>
                                <div class="reg-value" id="sim-ax">0000h</div>
                                <div class="reg-binary" id="sim-ax-bin">00000000 00000000</div>
                                <div class="reg-8bit-row">
                                    <div class="reg-8bit" data-half="AH">AH: <span id="sim-ah">00h</span></div>
                                    <div class="reg-8bit" data-half="AL">AL: <span id="sim-al">00h</span></div>
                                </div>
                            </div>
                            <div class="reg-card" data-reg="BX" style="--reg-color: var(--reg-bx)">
                                <div class="reg-name">BX</div>
                                <div class="reg-value" id="sim-bx">0000h</div>
                                <div class="reg-binary" id="sim-bx-bin">00000000 00000000</div>
                                <div class="reg-8bit-row">
                                    <div class="reg-8bit" data-half="BH">BH: <span id="sim-bh">00h</span></div>
                                    <div class="reg-8bit" data-half="BL">BL: <span id="sim-bl">00h</span></div>
                                </div>
                            </div>
                            <div class="reg-card" data-reg="CX" style="--reg-color: var(--reg-cx)">
                                <div class="reg-name">CX</div>
                                <div class="reg-value" id="sim-cx">0000h</div>
                                <div class="reg-binary" id="sim-cx-bin">00000000 00000000</div>
                                <div class="reg-8bit-row">
                                    <div class="reg-8bit" data-half="CH">CH: <span id="sim-ch">00h</span></div>
                                    <div class="reg-8bit" data-half="CL">CL: <span id="sim-cl">00h</span></div>
                                </div>
                            </div>
                            <div class="reg-card" data-reg="DX" style="--reg-color: var(--reg-dx)">
                                <div class="reg-name">DX</div>
                                <div class="reg-value" id="sim-dx">0000h</div>
                                <div class="reg-binary" id="sim-dx-bin">00000000 00000000</div>
                                <div class="reg-8bit-row">
                                    <div class="reg-8bit" data-half="DH">DH: <span id="sim-dh">00h</span></div>
                                    <div class="reg-8bit" data-half="DL">DL: <span id="sim-dl">00h</span></div>
                                </div>
                            </div>
                        </div>

                        <h3>üìç Index & Pointer Registers</h3>
                        <div class="index-regs">
                            <div class="simple-reg" data-reg="SI">
                                <div class="reg-name">SI</div>
                                <div class="reg-value" id="sim-si">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="DI">
                                <div class="reg-name">DI</div>
                                <div class="reg-value" id="sim-di">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="BP">
                                <div class="reg-name">BP</div>
                                <div class="reg-value" id="sim-bp">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="SP">
                                <div class="reg-name">SP</div>
                                <div class="reg-value" id="sim-sp">FFFEh</div>
                            </div>
                        </div>

                        <h3>üóÇÔ∏è Segment Registers</h3>
                        <div class="segment-regs">
                            <div class="simple-reg" data-reg="CS">
                                <div class="reg-name">CS</div>
                                <div class="reg-value" id="sim-cs">F000h</div>
                            </div>
                            <div class="simple-reg" data-reg="DS">
                                <div class="reg-name">DS</div>
                                <div class="reg-value" id="sim-ds">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="SS">
                                <div class="reg-name">SS</div>
                                <div class="reg-value" id="sim-ss">0000h</div>
                            </div>
                            <div class="simple-reg" data-reg="ES">
                                <div class="reg-name">ES</div>
                                <div class="reg-value" id="sim-es">0000h</div>
                            </div>
                        </div>

                        <h3>‚ö° Special Registers</h3>
                        <div class="special-regs">
                            <div class="simple-reg" data-reg="IP">
                                <div class="reg-name">IP</div>
                                <div class="reg-value" id="sim-ip">0000h</div>
                            </div>
                        </div>

                        <h3>üè≥Ô∏è Flags Register</h3>
                        <div class="flags-container">
                            <div class="flag-item" data-flag="CF"><div class="flag-indicator" id="flag-cf"></div>CF</div>
                            <div class="flag-item" data-flag="PF"><div class="flag-indicator" id="flag-pf"></div>PF</div>
                            <div class="flag-item" data-flag="AF"><div class="flag-indicator" id="flag-af"></div>AF</div>
                            <div class="flag-item" data-flag="ZF"><div class="flag-indicator" id="flag-zf"></div>ZF</div>
                            <div class="flag-item" data-flag="SF"><div class="flag-indicator" id="flag-sf"></div>SF</div>
                            <div class="flag-item" data-flag="TF"><div class="flag-indicator" id="flag-tf"></div>TF</div>
                            <div class="flag-item" data-flag="IF"><div class="flag-indicator" id="flag-if"></div>IF</div>
                            <div class="flag-item" data-flag="DF"><div class="flag-indicator" id="flag-df"></div>DF</div>
                            <div class="flag-item" data-flag="OF"><div class="flag-indicator" id="flag-of"></div>OF</div>
                        </div>
                        <div style="margin-top: 10px; font-family: monospace; font-size: 12px;">
                            FLAGS: <span id="sim-flags">0002h</span> | Binary: <span id="sim-flags-bin">00000000 00000010</span>
                        </div>
                    </div>

                    <div class="op-panel">
                        <h3>üî® Operations</h3>
                        <div style="margin-bottom: 15px; padding: 10px; background: var(--bg); border-radius: 5px;">
                            Selected: <strong id="selected-reg" style="color: var(--accent);">None</strong>
                        </div>
                        <div class="op-buttons">
                            <button class="op-btn" data-op="MOV">MOV</button>
                            <button class="op-btn" data-op="ADD">ADD</button>
                            <button class="op-btn" data-op="SUB">SUB</button>
                            <button class="op-btn" data-op="INC">INC</button>
                            <button class="op-btn" data-op="DEC">DEC</button>
                            <button class="op-btn" data-op="AND">AND</button>
                            <button class="op-btn" data-op="OR">OR</button>
                            <button class="op-btn" data-op="XOR">XOR</button>
                            <button class="op-btn" data-op="NOT">NOT</button>
                            <button class="op-btn" data-op="SHL">SHL</button>
                            <button class="op-btn" data-op="SHR">SHR</button>
                            <button class="op-btn" data-op="SET">SET</button>
                        </div>
                        <div class="imm-input-row">
                            <input type="text" class="imm-input" id="imm-value" placeholder="Immediate value (hex)">
                            <button class="btn btn-primary" id="exec-op">Execute</button>
                        </div>
                        <div style="margin-top: 15px; padding: 10px; background: var(--bg); border-radius: 5px; font-family: monospace; font-size: 12px;" id="last-op">
                            Last operation: None
                        </div>
                    </div>
                </div>

                <div class="code-panel">
                    <h3>üìÑ Assembly Code</h3>
                    <div class="code-display" id="code-display">
                        <div class="code-line"><span class="line-num">1</span><span class="line-content"><span class="directive">.MODEL</span> <span class="register">SMALL</span></span></div>
                        <div class="code-line"><span class="line-num">2</span><span class="line-content"><span class="directive">.STACK</span> <span class="immediate">100h</span></span></div>
                        <div class="code-line"><span class="line-num">3</span><span class="line-content"></span></div>
                        <div class="code-line"><span class="line-num">4</span><span class="line-content"><span class="directive">.DATA</span></span></div>
                        <div class="code-line"><span class="line-num">5</span><span class="line-content">    <span class="comment">; Data definitions here</span></span></div>
                        <div class="code-line"><span class="line-num">6</span><span class="line-content"></span></div>
                        <div class="code-line"><span class="line-num">7</span><span class="line-content"><span class="directive">.CODE</span></span></div>
                        <div class="code-line"><span class="line-num">8</span><span class="line-content"><span class="directive">MAIN</span> <span class="directive">PROC</span></span></div>
                        <div class="code-line"><span class="line-num">9</span><span class="line-content">    <span class="comment">; Your code here</span></span></div>
                        <div class="code-line"><span class="line-num">10</span><span class="line-content">    <span class="mnemonic">MOV</span> <span class="register">AX</span>, <span class="immediate">@DATA</span></span></div>
                        <div class="code-line"><span class="line-num">11</span><span class="line-content">    <span class="mnemonic">MOV</span> <span class="register">DS</span>, <span class="register">AX</span></span></div>
                        <div class="code-line"><span class="line-num">12</span><span class="line-content">    </span></div>
                        <div class="code-line"><span class="line-num">13</span><span class="line-content">    <span class="mnemonic">MOV</span> <span class="register">AH</span>, <span class="immediate">4Ch</span></span></div>
                        <div class="code-line"><span class="line-num">14</span><span class="line-content">    <span class="mnemonic">INT</span> <span class="immediate">21h</span></span></div>
                        <div class="code-line"><span class="line-num">15</span><span class="line-content"><span class="directive">MAIN</span> <span class="directive">ENDP</span></span></div>
                        <div class="code-line"><span class="line-num">16</span><span class="line-content">    <span class="directive">END</span> <span class="register">MAIN</span></span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- FLASHCARDS SECTION -->
        <section id="flashcards">
            <div class="flashcard-container">
                <h2 style="text-align: center;">üé¥ Study Flashcards</h2>
                <div class="flashcard-stats">
                    <div class="stat-badge">Card <span id="fc-current">1</span> / <span id="fc-total">50</span></div>
                    <div class="stat-badge">Known: <span id="fc-known">0</span></div>
                    <div class="stat-badge">Review: <span id="fc-review">0</span></div>
                </div>
                <div class="flashcard" id="flashcard">
                    <div class="card-face card-front">
                        <div class="card-category" id="fc-category">Registers</div>
                        <div class="card-question" id="fc-question">What is the AX register used for?</div>
                        <div style="margin-top: 30px; color: var(--text-muted); font-size: 12px;">
                            Click to flip
                        </div>
                    </div>
                    <div class="card-face card-back">
                        <div class="card-answer" id="fc-answer">
                            AX is the Accumulator register used for arithmetic operations, I/O operations, and interrupt calls. It can be accessed as two 8-bit registers: AH (high) and AL (low).
                        </div>
                    </div>
                </div>
                <div class="flashcard-controls">
                    <button class="fc-btn fc-btn-dont" id="fc-dont">ü§î Don't Know</button>
                    <button class="fc-btn fc-btn-shuffle" id="fc-shuffle">üîÄ Shuffle</button>
                    <button class="fc-btn fc-btn-know" id="fc-know">‚úÖ Know It</button>
                </div>
            </div>
        </section>

        <!-- GAMES SECTION -->
        <section id="games">
            <div id="games-menu">
                <h2>üéÆ Learning Games</h2>
                <div class="games-grid">
                    <div class="game-card" data-game="registerRacer">
                        <div class="game-icon">üèéÔ∏è</div>
                        <div class="game-title">Register Racer</div>
                        <div class="game-desc">Race against time to identify the correct register for each operation!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="hexHunter">
                        <div class="game-icon">üî¢</div>
                        <div class="game-title">Hex Hunter</div>
                        <div class="game-desc">Convert between decimal, hexadecimal, and binary as fast as you can!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="flagMaster">
                        <div class="game-icon">üèÅ</div>
                        <div class="game-title">Flag Master</div>
                        <div class="game-desc">Master the x86 flags by predicting their state after operations!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="opcodeHero">
                        <div class="game-icon">ü¶∏</div>
                        <div class="game-title">Opcode Hero</div>
                        <div class="game-desc">Identify assembly instructions and their effects!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="memoryMatch">
                        <div class="game-icon">üß†</div>
                        <div class="game-title">Memory Match</div>
                        <div class="game-desc">Match addressing modes with their descriptions!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                    <div class="game-card" data-game="stackAttack">
                        <div class="game-icon">üìö</div>
                        <div class="game-title">Stack Attack</div>
                        <div class="game-desc">Track stack operations and predict SP/BP values!</div>
                        <button class="btn btn-primary">Play Now</button>
                    </div>
                </div>
            </div>
            <div id="game-container" style="display: none;"></div>
        </section>

        <!-- TESTS SECTION -->
        <section id="tests">
            <div class="test-container">
                <h2>üìù Practice Tests</h2>
                <div id="test-start">
                    <div class="card" style="text-align: center; padding: 40px;">
                        <h3>Test Your Assembly Knowledge</h3>
                        <p style="margin: 20px 0; color: var(--text-muted);">
                            20 questions covering all lectures with detailed explanations
                        </p>
                        <button class="btn btn-primary" id="start-test" style="font-size: 18px; padding: 15px 40px;">
                            Start Test
                        </button>
                    </div>
                </div>
                <div id="test-active" style="display: none;">
                    <div class="test-progress">
                        <div class="test-progress-bar" id="test-progress"></div>
                    </div>
                    <div class="question-card">
                        <div class="question-text" id="test-question"></div>
                        <div class="options-list" id="test-options"></div>
                        <div class="explanation-box" id="test-explanation" style="display: none;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                        <button class="btn btn-secondary" id="test-prev" disabled>Previous</button>
                        <button class="btn btn-primary" id="test-next">Next Question</button>
                    </div>
                </div>
                <div id="test-results" style="display: none;">
                    <div class="card test-results">
                        <h2>Test Complete!</h2>
                        <div class="score-circle">
                            <div class="score-value" id="test-score">0%</div>
                            <div class="score-label">Score</div>
                        </div>
                        <p id="test-message"></p>
                        <div style="margin-top: 30px;">
                            <button class="btn btn-primary" id="retake-test">Retake Test</button>
                            <button class="btn btn-secondary" id="review-answers">Review Answers</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>


    <!-- FOOTER -->
    <footer style="background: var(--card-bg); border-top: 2px solid var(--border); padding: 20px; text-align: center; margin-top: 40px;">
        <div style="max-width: 1400px; margin: 0 auto;">
            <span style="color: var(--text-muted); font-size: 13px;">Created by <strong style="color: var(--primary);">OsaZain</strong> for ACS2906 Assembly Language</span>
            <span style="color: var(--text-muted); font-size: 12px; display: block; margin-top: 5px;">University of Winnipeg</span>
        </div>
    </footer>

    <script>
/**
 * Complete Lecture Content for ACS2906 Assembly Language Course
 * University of Winnipeg - Computer Architecture and System Software
 * 
 * Auto-extracted from PDFs on 2026-02-08 21:17:46
 * Total Pages: 328
 * 
 * This file contains the complete content of all 5 lecture PDFs including:
 * - All text content from every page
 * - Structured page-by-page breakdown
 * - Code examples and assembly instructions
 * - Identified sections and topics
 * - Content type classifications (code, exam_focus, definitions, etc.)
 */


// ============================================
// REWRITTEN LECTURE CONTENT - Beginner Friendly
// by OsaZain
// ============================================

/**
 * COMPLETE REWRITTEN LECTURES - Beginner Friendly
 * ACS2906 Assembly Language - University of Winnipeg
 * Created by OsaZain
 */

// ============================================================================
// LECTURE 1: COMPUTER SYSTEMS OVERVIEW
// ============================================================================
const lecture1Content = {
  title: "Lecture 1: Computer Systems Overview",
  description: "Understanding how computers work from the ground up - bits, numbers, and the compilation process.",
  
  sections: [
    {
      id: "bits-context",
      title: "Information is Bits + Context",
      icon: "üíæ",
      explanation: `Everything in a computer is stored as bits (0s and 1s). But bits alone don't mean anything - they need context to be understood.

Think of it like this: The bits "01000001" could be:
- The number 65 (if interpreted as an integer)
- The letter 'A' (if interpreted as ASCII)
- Part of an image pixel (if interpreted as image data)

The same bits mean different things depending on HOW we read them.`,
      analogy: "It's like the number 12/03/2024 - it could be March 12th (US format) or December 3rd (European format). The digits are the same, but the context (format) changes the meaning.",
      whyItMatters: "Understanding this helps you debug programs when data looks wrong - you might be interpreting it with the wrong context!",
      examples: [
        { bits: "01000001", context: "Integer", meaning: "65" },
        { bits: "01000001", context: "ASCII", meaning: "'A'" },
        { bits: "01000001", context: "Instruction", meaning: "INC ECX" }
      ]
    },
    {
      id: "number-systems",
      title: "Understanding Number Systems",
      icon: "üî¢",
      explanation: `Humans use decimal (base 10) because we have 10 fingers. Computers use binary (base 2) because they have electronic switches that are either ON (1) or OFF (0).

DECIMAL (Base 10): Uses digits 0-9
- 7392 means: 7√ó1000 + 3√ó100 + 9√ó10 + 2√ó1

BINARY (Base 2): Uses digits 0-1
- 1011 means: 1√ó8 + 0√ó4 + 1√ó2 + 1√ó1 = 11 in decimal

HEXADECIMAL (Base 16): Uses digits 0-9 and letters A-F
- Each hex digit represents exactly 4 binary digits (1 nibble)
- FF means: 15√ó16 + 15√ó1 = 255 in decimal`,
      
      whyBinary: `Computers use binary because:
1. Easy to store: Just needs two states (high/low voltage, on/off)
2. Easy to transmit: Two signal levels instead of ten
3. Reliable: Less chance of error than distinguishing 10 levels
4. Simple logic: AND, OR, NOT gates work naturally with binary`,
      
      conversionMethods: {
        decToBinary: {
          title: "Decimal ‚Üí Binary",
          method: "Repeated Division by 2",
          steps: [
            "Divide the number by 2",
            "Write down the remainder (0 or 1)",
            "Divide the quotient by 2",
            "Repeat until quotient is 0",
            "Read the remainders from BOTTOM to TOP"
          ],
          example: `Convert 219 to binary:
219 √∑ 2 = 109 remainder 1
109 √∑ 2 = 54  remainder 1
54  √∑ 2 = 27  remainder 0
27  √∑ 2 = 13  remainder 1
13  √∑ 2 = 6   remainder 1
6   √∑ 2 = 3   remainder 0
3   √∑ 2 = 1   remainder 1
1   √∑ 2 = 0   remainder 1

Reading from bottom: 11011011`,
          result: "219 = 11011011‚ÇÇ"
        },
        
        binaryToHex: {
          title: "Binary ‚Üí Hexadecimal",
          method: "Group by 4 bits",
          steps: [
            "Start from the RIGHT (least significant bit)",
            "Group bits into sets of 4",
            "If needed, pad with leading zeros on the left",
            "Convert each group to its hex digit"
          ],
          example: `Convert 11011011 to hex:
1101 1011 (grouped)

1101 = 8+4+0+1 = 13 = D
1011 = 8+0+2+1 = 11 = B

Result: 0xDB`,
          reference: {
            "0000": "0", "0001": "1", "0010": "2", "0011": "3",
            "0100": "4", "0101": "5", "0110": "6", "0111": "7",
            "1000": "8", "1001": "9", "1010": "A", "1011": "B",
            "1100": "C", "1101": "D", "1110": "E", "1111": "F"
          }
        },
        
        decToHex: {
          title: "Decimal ‚Üí Hexadecimal",
          method: "Repeated Division by 16",
          steps: [
            "Divide the number by 16",
            "Write down the remainder (0-15, where 10=A, 11=B, etc.)",
            "Divide the quotient by 16",
            "Repeat until quotient is 0",
            "Read remainders from BOTTOM to TOP"
          ],
          example: `Convert 219 to hex:
219 √∑ 16 = 13 remainder 11 (B)
13  √∑ 16 = 0  remainder 13 (D)

Reading from bottom: 0xDB`,
          formula: "219 = 13√ó16 + 11 = 0xDB"
        }
      },
      
      commonMistakes: [
        "Reading binary remainders top-to-bottom instead of bottom-to-top",
        "Forgetting that hex digits A-F represent 10-15",
        "Not padding binary groups to 4 bits when converting to hex",
        "Confusing 0x prefix (hex) with 0 prefix (octal in some languages)"
      ],
      
      practiceProblems: [
        { q: "Convert 42 to binary", a: "101010", work: "42√∑2=21r0, 21√∑2=10r1, 10√∑2=5r0, 5√∑2=2r1, 2√∑2=1r0, 1√∑2=0r1 ‚Üí 101010" },
        { q: "Convert 255 to hex", a: "0xFF", work: "255√∑16=15r15(F), 15√∑16=0r15(F) ‚Üí 0xFF" },
        { q: "Convert 1010 1100 to hex", a: "0xAC", work: "1010=A, 1100=C ‚Üí 0xAC" }
      ]
    },
    {
      id: "ascii",
      title: "ASCII - Text Representation",
      icon: "üî§",
      explanation: `ASCII (American Standard Code for Information Interchange) assigns a number to each character.

Key ASCII codes to remember:
- '0'-'9' = 0x30-0x39 (48-57 decimal)
- 'A'-'Z' = 0x41-0x5A (65-90 decimal)  
- 'a'-'z' = 0x61-0x7A (97-122 decimal)
- Space = 0x20 (32 decimal)
- Newline (LF) = 0x0A (10 decimal)
- Carriage Return (CR) = 0x0D (13 decimal)`,
      
      importantForAssembly: `When displaying numbers in DOS:
- You must ADD 30h to convert a digit to its ASCII character
- Example: To display the number 5, load 35h (or 5+30h) into DL`,
      
      examples: [
        { char: "'0'", hex: "0x30", dec: "48", bin: "00110000" },
        { char: "'A'", hex: "0x41", dec: "65", bin: "01000001" },
        { char: "'a'", hex: "0x61", dec: "97", bin: "01100001" }
      ]
    },
    {
      id: "compilation",
      title: "Program Compilation Process",
      icon: "‚öôÔ∏è",
      explanation: `When you write a C program, it goes through several stages before becoming an executable:

1. PREPROCESSOR
   - Handles #include, #define
   - Removes comments
   - Produces expanded source code

2. COMPILER  
   - Translates C code to Assembly
   - Optimizes the code
   - Produces .s file (assembly)

3. ASSEMBLER
   - Translates Assembly to Machine Code
   - Produces .o file (object file)
   - Contains binary instructions

4. LINKER
   - Combines multiple object files
   - Links with libraries
   - Produces final executable`,
      
      visualDiagram: `
Source Code (.c)
      ‚Üì
Preprocessor
      ‚Üì
Expanded Source
      ‚Üì
Compiler
      ‚Üì
Assembly Code (.s)
      ‚Üì
Assembler
      ‚Üì
Object Code (.o)
      ‚Üì
Linker + Libraries
      ‚Üì
Executable (.exe)
      `,
      
      whyItMatters: "Understanding this helps you debug issues. If you get linker errors, the problem is in step 4. If you get compiler errors, the problem is in step 2."
    }
  ]
};

// ============================================================================
// LECTURE 2: DATA REPRESENTATION
// ============================================================================
const lecture2Content = {
  title: "Lecture 2: Data Representation",
  description: "How integers are stored, signed vs unsigned, bit operations, and byte ordering.",
  
  sections: [
    {
      id: "integer-representation",
      title: "Integer Representations",
      icon: "üî¢",
      
      unsignedIntegers: {
        title: "Unsigned Integers (Positive Only)",
        explanation: "Unsigned integers can only represent positive numbers and zero.",
        ranges: {
          "8-bit": "0 to 255 (0 to 2‚Å∏-1)",
          "16-bit": "0 to 65,535 (0 to 2¬π‚Å∂-1)",
          "32-bit": "0 to 4,294,967,295 (0 to 2¬≥¬≤-1)"
        },
        formula: "Range = 0 to 2‚Åø - 1, where n = number of bits"
      },
      
      signedIntegers: {
        title: "Signed Integers (Positive and Negative)",
        explanation: "Signed integers use two's complement to represent both positive and negative numbers.",
        ranges: {
          "8-bit": "-128 to +127 (-2‚Å∑ to 2‚Å∑-1)",
          "16-bit": "-32,768 to +32,767 (-2¬π‚Åµ to 2¬π‚Åµ-1)",
          "32-bit": "-2,147,483,648 to +2,147,483,647 (-2¬≥¬π to 2¬≥¬π-1)"
        },
        formula: "Range = -2‚Åø‚Åª¬π to 2‚Åø‚Åª¬π - 1, where n = number of bits"
      },
      
      whyAsymmetric: "The range is asymmetric because there's one more negative number than positive. Zero takes up one positive slot. Example: 8-bit has -128 but only up to +127."
    },
    {
      id: "twos-complement",
      title: "Two's Complement - Negative Numbers",
      icon: "‚ûñ",
      explanation: `Two's complement is how computers store negative numbers. It's clever because:
1. There's only one representation of zero
2. Addition works the same for positive and negative numbers
3. The sign bit (leftmost) is 1 for negative, 0 for positive`,
      
      formula: {
        title: "The Formula",
        description: "For a negative number N with n bits:",
        steps: [
          "1. Take the absolute value |N|",
          "2. Convert |N| to binary",
          "3. Invert all bits (0‚Üí1, 1‚Üí0) - this is One's Complement",
          "4. Add 1 to the result",
          "5. The result is the Two's Complement representation"
        ],
        shortcut: "Shortcut formula: Two's complement of N = 2‚Åø + N (when N is negative)"
      },
      
      detailedExample: {
        title: "Example: Convert -5 to 8-bit Two's Complement",
        steps: [
          "Step 1: |N| = 5",
          "Step 2: 5 in binary = 00000101",
          "Step 3: Invert bits = 11111010 (One's Complement)",
          "Step 4: Add 1 = 11111011",
          "Step 5: Result: 11111011‚ÇÇ = 0xFB = -5"
        ],
        verification: "Verify: 5 + (-5) should = 0\n  00000101 (5)\n+ 11111011 (-5)\n= 00000000 with carry out (which is discarded) ‚úì"
      },
      
      calculatorFormula: {
        title: "Calculator Implementation Formula",
        code: `function toTwosComplement(value, bits) {
  if (value >= 0) {
    return value;  // Positive numbers unchanged
  }
  // For negative: 2^n + value
  return Math.pow(2, bits) + value;
}

// Example: toTwosComplement(-5, 8)
// = 256 + (-5) = 251 = 0xFB = 11111011‚ÇÇ`
      },
      
      signExtension: {
        title: "Sign Extension",
        explanation: "When converting from smaller to larger bits, copy the sign bit to fill new bits.",
        example: "8-bit 11111011 (-5) ‚Üí 16-bit: 1111111111111011 (-5)",
        instruction: "Use CBW (Convert Byte to Word) or CWD (Convert Word to Double) instructions in assembly."
      }
    },
    {
      id: "bitwise-operations",
      title: "Bitwise Operations",
      icon: "üîß",
      explanation: "Operations that work on individual bits.",
      
      operations: {
        AND: {
          symbol: "&",
          description: "Result bit is 1 ONLY if both bits are 1",
          useCase: "Masking - extract specific bits",
          truthTable: "0&0=0, 0&1=0, 1&0=0, 1&1=1",
          example: "0x0F & 0x3A = 0x0A\n  00001111\n& 00111010\n= 00001010",
          assembly: "AND AL, 0Fh  ; Mask to get low nibble"
        },
        
        OR: {
          symbol: "|",
          description: "Result bit is 1 if EITHER bit is 1",
          useCase: "Setting bits - turn specific bits ON",
          truthTable: "0|0=0, 0|1=1, 1|0=1, 1|1=1",
          example: "0x0F | 0x30 = 0x3F\n  00001111\n| 00110000\n= 00111111",
          assembly: "OR AL, 30h  ; Convert digit to ASCII"
        },
        
        XOR: {
          symbol: "^",
          description: "Result bit is 1 if bits are DIFFERENT",
          useCase: "Toggling bits, zeroing registers",
          truthTable: "0^0=0, 0^1=1, 1^0=1, 1^1=0",
          example: "0xFF ^ 0x0F = 0xF0\n  11111111\n^ 00001111\n= 11110000",
          special: "XOR EAX, EAX  ; Fast way to zero register (faster than MOV EAX, 0)",
          assembly: "XOR EAX, EAX  ; Clear EAX efficiently"
        },
        
        NOT: {
          symbol: "~",
          description: "Invert all bits (0 becomes 1, 1 becomes 0)",
          useCase: "One's complement, bit inversion",
          example: "~0x0F = 0xF0 (in 8-bit)\n  00001111\n~ 11110000",
          assembly: "NOT AL  ; Invert all bits in AL"
        }
      },
      
      commonPatterns: {
        title: "Common Bit Patterns",
        list: [
          { pattern: "AND with 0x0F", effect: "Extract low nibble (4 bits)", example: "0x3A & 0x0F = 0x0A" },
          { pattern: "AND with 0xF0", effect: "Extract high nibble", example: "0x3A & 0xF0 = 0x30" },
          { pattern: "OR with 0x30", effect: "Convert digit to ASCII", example: "0x05 | 0x30 = 0x35 ('5')" },
          { pattern: "XOR with 0x20", effect: "Toggle case (a‚ÜîA)", example: "0x41('A') ^ 0x20 = 0x61('a')" }
        ]
      }
    },
    {
      id: "shift-operations",
      title: "Shift Operations",
      icon: "‚ÜîÔ∏è",
      explanation: "Moving bits left or right. Useful for multiplication/division by powers of 2.",
      
      leftShift: {
        title: "Shift Left (SHL / <<)",
        description: "Move all bits left, fill right with 0",
        formula: "x << n = x √ó 2‚Åø",
        example: `5 << 2 = 20
  00000101 (5)
<< 2
  00010100 (20)

Because: 5 √ó 2¬≤ = 5 √ó 4 = 20`,
        flags: "CF = bit shifted out, ZF, SF, PF updated",
        assembly: "SHL AX, 2  ; Multiply AX by 4"
      },
      
      rightShiftLogical: {
        title: "Shift Right Logical (SHR)",
        description: "Move all bits right, fill left with 0",
        formula: "x >> n = x √∑ 2‚Åø (unsigned)",
        example: `20 >> 2 = 5
  00010100 (20)
>> 2
  00000101 (5)

Because: 20 √∑ 2¬≤ = 20 √∑ 4 = 5`,
        warning: "WARNING: For signed numbers, use SAR instead to preserve sign!",
        assembly: "SHR AX, 1  ; Divide unsigned AX by 2"
      },
      
      rightShiftArithmetic: {
        title: "Shift Right Arithmetic (SAR)",
        description: "Move all bits right, fill left with SIGN BIT (copy MSB)",
        formula: "x SAR n = x √∑ 2‚Åø (signed, rounds toward -‚àû)",
        example: `-20 SAR 2 = -5
  11101100 (-20)
SAR 2
  11111011 (-5)

Notice sign bit (1) is copied to the left`,
        assembly: "SAR AX, 1  ; Divide signed AX by 2"
      },
      
      calculatorFormulas: {
        title: "Calculator Implementation",
        shl: "result = (value << shiftAmount) & mask",
        shr: "result = (value >>> shiftAmount)  // unsigned",
        sar: "result = value >> shiftAmount  // signed (preserves sign in JS)"
      }
    },
    {
      id: "byte-ordering",
      title: "Byte Ordering - Big vs Little Endian",
      icon: "üìä",
      explanation: `When storing multi-byte values (like 16-bit or 32-bit), the order of bytes matters.

BIG ENDIAN (Network Order):
- Most Significant Byte (MSB) stored at lowest address
- Like reading: Left to right, most significant first
- Example: 0x1234 stored as [0x12, 0x34]

LITTLE ENDIAN (x86 Architecture):
- Least Significant Byte (LSB) stored at lowest address  
- Like reading: Backwards, least significant first
- Example: 0x1234 stored as [0x34, 0x12]

x86 uses LITTLE ENDIAN!`,
      
      visualExample: {
        title: "Visual Example: Storing 0x12345678 at address 0x100",
        bigEndian: `
Address:  0x100  0x101  0x102  0x103
Value:     0x12   0x34   0x56   0x78
          (MSB)................(LSB)
        `,
        littleEndian: `
Address:  0x100  0x101  0x102  0x103
Value:     0x78   0x56   0x34   0x12
          (LSB)................(MSB)
        `
      },
      
      whyItMatters: `Network protocols use Big Endian, x86 uses Little Endian. When sending data over network from x86, you must convert!

Assembly example showing little endian:
  MOV word ptr [0x100], 0x1234
Memory at 0x100: 0x34
Memory at 0x101: 0x12`,
      
      examTip: "Exam Tip: For x86, always remember: LOW BYTE at LOW ADDRESS"
    }
  ]
};

// ============================================================================
// LECTURE 3: FLOATING POINT
// ============================================================================
const lecture3Content = {
  title: "Lecture 3: Floating Point Representation",
  description: "How computers store and calculate with decimal numbers using IEEE 754 standard.",
  
  sections: [
    {
      id: "binary-fractions",
      title: "Binary Fractions",
      icon: "üî¢",
      explanation: `Just like decimal has a decimal point, binary has a binary point.

Decimal: 123.45 = 1√ó100 + 2√ó10 + 3√ó1 + 4√ó0.1 + 5√ó0.01
Binary:  101.11 = 1√ó4 + 0√ó2 + 1√ó1 + 1√ó0.5 + 1√ó0.25 = 5.75

Bit positions after the point:
.1 = 1/2 = 0.5
.01 = 1/4 = 0.25
.001 = 1/8 = 0.125
.0001 = 1/16 = 0.0625`,
      
      conversionMethod: {
        title: "Converting Decimal Fraction to Binary",
        steps: [
          "1. Separate integer and fractional parts",
          "2. Convert integer part using division by 2",
          "3. Convert fractional part using multiplication by 2",
          "4. For fraction: multiply by 2, take integer part as next bit, repeat with fraction"
        ],
        example: `Convert 5.625 to binary:

Integer part (5): 101

Fractional part (0.625):
0.625 √ó 2 = 1.25  ‚Üí bit 1, use 0.25
0.25  √ó 2 = 0.5   ‚Üí bit 0, use 0.5
0.5   √ó 2 = 1.0   ‚Üí bit 1, use 0.0 (done!)

Result: 101.101`
      }
    },
    {
      id: "ieee754",
      title: "IEEE 754 Floating Point Standard",
      icon: "üî¨",
      explanation: `IEEE 754 is the standard for floating point representation. It uses scientific notation in binary.

Scientific Notation in Decimal: 6.022 √ó 10¬≤¬≥
Scientific Notation in Binary:  1.101 √ó 2¬≥

The format has three parts:
1. SIGN (1 bit): 0=positive, 1=negative
2. EXPONENT: Stored with a "bias" to make it unsigned
3. MANTISSA (Significand): The fractional part after the leading 1`,
      
      singlePrecision: {
        title: "Single Precision (32-bit)",
        layout: `
[31] [30-23] [22-0]
Sign Exponent Mantissa
  1    8 bits   23 bits
        `,
        formula: `Value = (-1)^S √ó 1.M √ó 2^(E-127)

Where:
- S = sign bit (0 or 1)
- E = exponent (8 bits, biased by 127)
- M = mantissa (23 bits)
- 1. = implicit leading 1 (not stored)`,
        bias: 127,
        exponentRange: "E=1 to 254 (0 and 255 are special)",
        example: `Convert -6.625 to IEEE 754 single precision:

Step 1: Convert to binary
6.625 = 110.101

Step 2: Normalize (move binary point to after first 1)
110.101 = 1.10101 √ó 2¬≤

Step 3: Extract fields
Sign S = 1 (negative)
Exponent E = 2 + 127 = 129 = 10000001
Mantissa M = 10101000000000000000000 (23 bits)

Step 4: Combine
1 10000001 10101000000000000000000

Hex: 0xC0D40000`
      },
      
      doublePrecision: {
        title: "Double Precision (64-bit)",
        layout: `
[63] [62-52] [51-0]
Sign Exponent  Mantissa
  1    11 bits  52 bits
        `,
        formula: `Value = (-1)^S √ó 1.M √ó 2^(E-1023)

Where:
- S = sign bit
- E = exponent (11 bits, biased by 1023)
- M = mantissa (52 bits)`,
        bias: 1023,
        exponentRange: "E=1 to 2046 (0 and 2047 are special)"
      },
      
      specialValues: {
        title: "Special Values",
        zero: "E=0, M=0: Zero (+0 or -0 based on sign)",
        denormalized: "E=0, M‚â†0: Denormalized numbers (very small)",
        infinity: "E=all 1s, M=0: Infinity (+‚àû or -‚àû)",
        nan: "E=all 1s, M‚â†0: Not a Number (NaN)"
      },
      
      calculatorFormulas: {
        title: "Calculator Implementation",
        code: `function floatToIEEE754(value) {
  // Create buffer and view
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setFloat32(0, value);
  const bits = view.getUint32(0);
  
  // Extract fields
  const sign = (bits >> 31) & 1;
  const exponent = (bits >> 23) & 0xFF;
  const mantissa = bits & 0x7FFFFF;
  
  // Calculate actual value
  const actualExponent = exponent - 127;
  const mantissaValue = 1 + (mantissa / Math.pow(2, 23));
  const finalValue = Math.pow(-1, sign) * mantissaValue * Math.pow(2, actualExponent);
  
  return { sign, exponent, actualExponent, mantissa, bits, finalValue };
}`
      }
    }
  ]
};

// ============================================================================
// LECTURE 4: ASSEMBLY BASICS
// ============================================================================
const lecture4Content = {
  title: "Lecture 4: Assembly Language Basics",
  description: "x86 architecture, registers, instructions, and program structure.",
  
  sections: [
    {
      id: "registers",
      title: "CPU Registers",
      icon: "üì¶",
      explanation: "Registers are super-fast storage locations inside the CPU. x86 has several types.",
      
      generalPurpose: {
        title: "General Purpose Registers (32-bit)",
        registers: {
          EAX: {
            name: "Accumulator",
            usage: "Arithmetic operations, function return values",
            parts: "AH (high byte), AL (low byte)"
          },
          EBX: {
            name: "Base",
            usage: "Data pointer, addressing memory",
            parts: "BH, BL"
          },
          ECX: {
            name: "Count",
            usage: "Loop counter, string operations, shift count",
            parts: "CH, CL"
          },
          EDX: {
            name: "Data",
            usage: "I/O operations, multiply/divide high bits",
            parts: "DH, DL"
          }
        }
      },
      
      indexPointer: {
        title: "Index and Pointer Registers",
        registers: {
          ESI: { name: "Source Index", usage: "Source pointer for string/memory operations" },
          EDI: { name: "Destination Index", usage: "Destination pointer for string/memory operations" },
          ESP: { name: "Stack Pointer", usage: "Points to top of stack" },
          EBP: { name: "Base Pointer", usage: "Stack frame base, function parameters" }
        }
      },
      
      segment: {
        title: "Segment Registers (16-bit)",
        registers: {
          CS: { name: "Code Segment", usage: "Where program code is stored" },
          DS: { name: "Data Segment", usage: "Default data segment" },
          SS: { name: "Stack Segment", usage: "Where stack is stored" },
          ES: { name: "Extra Segment", usage: "Additional data segment" }
        }
      },
      
      special: {
        title: "Special Registers",
        registers: {
          EIP: { name: "Instruction Pointer", usage: "Address of next instruction to execute" },
          EFLAGS: { name: "Flags Register", usage: "Status and control flags" }
        }
      },
      
      partialRegisters: {
        title: "Accessing Partial Registers",
        explanation: `EAX (32-bit) can be accessed in parts:
- AX = lower 16 bits of EAX
- AH = upper 8 bits of AX
- AL = lower 8 bits of AX

Example:
MOV EAX, 0x12345678  ; EAX = 0x12345678
MOV AX, 0xABCD       ; EAX = 0x1234ABCD (upper 16 bits unchanged)
MOV AL, 0xFF         ; EAX = 0x1234ABFF (only low byte changed)`
      }
    },
    {
      id: "flags",
      title: "EFLAGS Register",
      icon: "üö©",
      explanation: "The flags register contains status bits that reflect the result of operations.",
      
      importantFlags: {
        CF: {
          name: "Carry Flag",
          description: "Set when unsigned arithmetic overflows",
          example: "255 + 1 = 0 with CF=1"
        },
        ZF: {
          name: "Zero Flag", 
          description: "Set when result is zero",
          example: "SUB EAX, EAX sets ZF=1"
        },
        SF: {
          name: "Sign Flag",
          description: "Set when result is negative (MSB=1)",
          example: "Result 0x80 sets SF=1"
        },
        OF: {
          name: "Overflow Flag",
          description: "Set when signed arithmetic overflows",
          example: "127 + 1 = -128 (overflow), OF=1"
        },
        PF: {
          name: "Parity Flag",
          description: "Set when low byte has even number of 1s",
          example: "0x03 (00000011) has PF=1"
        }
      },
      
      examTip: "Exam Tip: Know the difference! CF is for UNSIGNED overflow, OF is for SIGNED overflow."
    },
    {
      id: "mov-instruction",
      title: "MOV Instruction",
      icon: "üìã",
      explanation: "MOV copies data from source to destination. It does NOT affect flags.",
      
      syntax: "MOV destination, source",
      
      operandTypes: {
        title: "Types of Operands",
        types: [
          { type: "Immediate", example: "MOV EAX, 5", description: "Constant value" },
          { type: "Register", example: "MOV EAX, EBX", description: "From another register" },
          { type: "Memory", example: "MOV EAX, [mem]", description: "From memory location" }
        ]
      },
      
      restrictions: {
        title: "MOV Restrictions",
        list: [
          "‚ùå Cannot move memory to memory directly",
          "‚ùå Cannot move immediate to segment register directly",
          "‚ùå Both operands must be same size",
          "‚úì Can move register to register",
          "‚úì Can move immediate to register",
          "‚úì Can move register to memory",
          "‚úì Can move memory to register"
        ]
      },
      
      examples: [
        { code: "MOV EAX, 100", comment: "EAX = 100 (immediate)" },
        { code: "MOV EBX, EAX", comment: "EBX = EAX (register)" },
        { code: "MOV AL, [data]", comment: "AL = value at memory 'data'" },
        { code: "MOV [result], EAX", comment: "Store EAX to memory 'result'" }
      ]
    },
    {
      id: "arithmetic",
      title: "Arithmetic Instructions",
      icon: "‚ûï",
      
      add: {
        title: "ADD - Addition",
        syntax: "ADD destination, source",
        description: "destination = destination + source",
        flags: "Affects: OF, SF, ZF, AF, PF, CF",
        example: `ADD EAX, 5      ; EAX = EAX + 5
ADD AL, BL      ; AL = AL + BL
ADD [mem], 10   ; mem = mem + 10`
      },
      
      sub: {
        title: "SUB - Subtraction",
        syntax: "SUB destination, source",
        description: "destination = destination - source",
        flags: "Affects: OF, SF, ZF, AF, PF, CF",
        example: `SUB EAX, 10     ; EAX = EAX - 10
SUB AL, BL      ; AL = AL - BL`
      },
      
      incDec: {
        title: "INC and DEC",
        syntax: "INC operand / DEC operand",
        description: "Increment or decrement by 1",
        flags: "Affects: OF, SF, ZF, AF, PF. Does NOT affect CF!",
        example: `INC EAX         ; EAX = EAX + 1
DEC BL          ; BL = BL - 1`
      },
      
      mul: {
        title: "MUL - Unsigned Multiply",
        syntax: "MUL source",
        description: "Multiplies AL/AX/EAX by source",
        resultSizes: [
          "8-bit: AL √ó src ‚Üí AX",
          "16-bit: AX √ó src ‚Üí DX:AX",
          "32-bit: EAX √ó src ‚Üí EDX:EAX"
        ],
        example: `MOV AL, 5
MOV BL, 10
MUL BL          ; AX = 5 √ó 10 = 50`
      },
      
      div: {
        title: "DIV - Unsigned Divide",
        syntax: "DIV source",
        description: "Divides AX/DX:AX/EDX:EAX by source",
        resultSizes: [
          "8-bit: AX √∑ src ‚Üí AL (quotient), AH (remainder)",
          "16-bit: DX:AX √∑ src ‚Üí AX (quotient), DX (remainder)",
          "32-bit: EDX:EAX √∑ src ‚Üí EAX (quotient), EDX (remainder)"
        ],
        example: `MOV AX, 100
MOV BL, 3
DIV BL          ; AL = 33 (quotient), AH = 1 (remainder)`
      }
    }
  ]
};

// ============================================================================
// LECTURE 5: I/O AND ADDRESSING MODES
// ============================================================================
const lecture5Content = {
  title: "Lecture 5: I/O and Addressing Modes",
  description: "DOS interrupts, INT 21h functions, and different ways to access memory.",
  
  sections: [
    {
      id: "interrupts",
      title: "INT 21h - The DOS Interrupt",
      icon: "üìû",
      explanation: `INT 21h is like a phone call to the operating system (DOS). Your program calls INT 21h to ask DOS to do something for you, like:
- Read a character from keyboard
- Display a character on screen
- Read a string of text
- Exit the program

Think of it as calling a service - you prepare what you need (set up registers), then make the call (INT 21h).`,
      
      analogy: "It's like calling a restaurant to order food. You tell them what you want (set AH to function number), provide your details (set other registers), then make the call (INT 21h).",
      
      whyItMatters: "In DOS assembly, INT 21h is the PRIMARY way to do input/output. You MUST know these functions!",
      
      howItWorks: {
        title: "How INT 21h Works",
        steps: [
          "1. Set AH to the function number (what you want DOS to do)",
          "2. Set other registers as needed for that function",
          "3. Execute INT 21h",
          "4. DOS performs the operation",
          "5. Results are returned in registers (usually AL)"
        ]
      },
      
      functions: {
        readChar: {
          fn: "01h",
          name: "Read Character with Echo",
          description: "Waits for a keypress, displays the character, returns ASCII in AL",
          input: "AH = 01h",
          output: "AL = ASCII code of key pressed",
          example: `MOV AH, 01h     ; Function: Read character
INT 21h         ; Wait for keypress
; AL now contains the ASCII code`
        },
        
        writeChar: {
          fn: "02h", 
          name: "Write Character",
          description: "Displays the character in DL on screen",
          input: "AH = 02h, DL = ASCII character to display",
          output: "None (character displayed)",
          example: `MOV AH, 02h     ; Function: Write character
MOV DL, 'A'     ; Character to display
INT 21h         ; Displays 'A' on screen`
        },
        
        writeString: {
          fn: "09h",
          name: "Display String",
          description: "Displays a '$'-terminated string",
          input: "AH = 09h, DS:DX = address of string (must end with '$')",
          output: "None (string displayed)",
          warning: "String MUST end with '$' character!",
          example: `MSG DB 'Hello$'  ; String with terminator

MOV AH, 09h      ; Function: Display string
LEA DX, MSG      ; Load address of message
INT 21h          ; Displays 'Hello'`
        },
        
        readString: {
          fn: "0Ah",
          name: "Buffered Input",
          description: "Reads a string of characters into a buffer",
          input: "AH = 0Ah, DS:DX = address of input buffer",
          output: "Buffer filled with user input",
          bufferStructure: `Input buffer structure:
[offset 0] = maximum characters to read
[offset 1] = actual characters read (filled by DOS)
[offset 2+] = the actual characters`,
          example: `MAXLEN DB 20      ; Max 20 chars
ACTLEN DB ?       ; DOS fills this
BUFFER DB 20 DUP('$')  ; Space for characters
INPUT_BUF DB MAXLEN, ?, 20 DUP('$')

MOV AH, 0Ah       ; Function: Buffered input
LEA DX, INPUT_BUF ; Load buffer address
INT 21h           ; Wait for user input`
        },
        
        exit: {
          fn: "4Ch",
          name: "Exit Program",
          description: "Ends the program and returns to DOS",
          input: "AH = 4Ch, AL = return code (0 = success)",
          output: "Program terminates",
          example: `MOV AH, 4Ch     ; Function: Exit
MOV AL, 00h     ; Return code 0 (success)
INT 21h         ; Program ends`
        }
      }
    },
    {
      id: "addressing-modes",
      title: "Addressing Modes",
      icon: "üéØ",
      explanation: "Addressing modes are different ways to specify where data is located.",
      
      modes: {
        immediate: {
          name: "Immediate Addressing",
          syntax: "MOV AX, 5",
          description: "The operand IS the value (constant)",
          example: "MOV AX, 100    ; AX = 100",
          speed: "Fastest - no memory access needed"
        },
        
        register: {
          name: "Register Addressing",
          syntax: "MOV AX, BX",
          description: "Operand is in a register",
          example: "MOV AX, BX     ; Copy BX to AX",
          speed: "Very fast - register access"
        },
        
        direct: {
          name: "Direct Addressing",
          syntax: "MOV AX, [variable]",
          description: "Operand is at a specific memory address",
          example: `MOV AX, [count]    ; Load from memory 'count'
MOV [result], BX   ; Store to memory 'result'`,
          note: "Uses variable name or explicit address"
        },
        
        registerIndirect: {
          name: "Register Indirect",
          syntax: "MOV AX, [SI]",
          description: "Memory address is in a register",
          validRegisters: "Only BX, SI, DI, BP can be used",
          example: `MOV SI, OFFSET array
MOV AX, [SI]     ; Load from address in SI
INC SI           ; Move to next element`,
          useCase: "Array traversal, pointers"
        },
        
        based: {
          name: "Based Addressing",
          syntax: "MOV AX, [BX + 4]",
          description: "Base register + constant displacement",
          validRegisters: "BX or BP",
          example: `MOV BX, OFFSET array
MOV AX, [BX + 4]  ; 4th element of array`,
          useCase: "Accessing structure fields, array elements"
        },
        
        indexed: {
          name: "Indexed Addressing", 
          syntax: "MOV AX, [SI + 4]",
          description: "Index register + constant displacement",
          validRegisters: "SI or DI",
          example: `MOV SI, 0
MOV AX, [array + SI]  ; array[SI]`
        },
        
        basedIndexed: {
          name: "Based Indexed",
          syntax: "MOV AX, [BX + SI]",
          description: "Base register + Index register",
          example: `MOV BX, OFFSET array
MOV SI, 4
MOV AX, [BX + SI]  ; array[4]`,
          useCase: "Two-dimensional arrays, structures with arrays"
        },
        
        basedIndexedDisp: {
          name: "Based Indexed with Displacement",
          syntax: "MOV AX, [BX + SI + 10]",
          description: "Base + Index + Constant offset",
          example: `MOV BX, OFFSET table
MOV SI, ROW_SIZE
MOV AX, [BX + SI + 5]  ; table[row][5]`
        }
      },
      
      comparisonTable: {
        title: "Quick Reference Table",
        rows: [
          { mode: "Immediate", syntax: "MOV AX, 5", addressing: "Value is in instruction" },
          { mode: "Register", syntax: "MOV AX, BX", addressing: "Value in register" },
          { mode: "Direct", syntax: "MOV AX, [var]", addressing: "Address is in instruction" },
          { mode: "Register Indirect", syntax: "MOV AX, [SI]", addressing: "Address in SI/BX/DI/BP" },
          { mode: "Based", syntax: "MOV AX, [BX+4]", addressing: "BX/BP + displacement" },
          { mode: "Indexed", syntax: "MOV AX, [SI+4]", addressing: "SI/DI + displacement" },
          { mode: "Based Indexed", syntax: "MOV AX, [BX+SI]", addressing: "BX/BP + SI/DI" }
        ]
      }
    },
    {
      id: "ascii-conversions",
      title: "ASCII Conversions",
      icon: "üîÑ",
      explanation: "When working with numbers in DOS, you need to convert between numeric values and ASCII characters.",
      
      digitToASCII: {
        title: "Digit ‚Üí ASCII",
        formula: "ASCII = Digit + 30h",
        explanation: "Add 30h (48 decimal) to convert 0-9 to '0'-'9'",
        examples: [
          { digit: "0", hex: "00h + 30h = 30h", ascii: "'0'" },
          { digit: "5", hex: "05h + 30h = 35h", ascii: "'5'" },
          { digit: "9", hex: "09h + 30h = 39h", ascii: "'9'" }
        ],
        code: `MOV AL, 5       ; Number 5
ADD AL, 30h     ; Convert to ASCII
MOV DL, AL      ; DL = '5'
MOV AH, 02h     ; Display character
INT 21h         ; Shows '5' on screen`
      },
      
      asciiToDigit: {
        title: "ASCII ‚Üí Digit",
        formula: "Digit = ASCII - 30h",
        explanation: "Subtract 30h to convert '0'-'9' to 0-9",
        examples: [
          { ascii: "'0'", hex: "30h - 30h = 00h", digit: "0" },
          { ascii: "'7'", hex: "37h - 30h = 07h", digit: "7" }
        ],
        code: `MOV AL, '7'     ; ASCII '7'
SUB AL, 30h     ; Convert to digit
; AL now contains 7`
      },
      
      twoDigitNumber: {
        title: "Display Two-Digit Number (0-99)",
        explanation: "To display a two-digit number like 42:",
        algorithm: [
          "1. Divide number by 10",
          "2. Quotient = tens digit, Remainder = ones digit",
          "3. Convert both to ASCII (add 30h)",
          "4. Display tens, then ones"
        ],
        code: `MOV AX, 42      ; Number to display
MOV BL, 10
DIV BL          ; AL = 4 (tens), AH = 2 (ones)

MOV BL, AH      ; Save ones digit
ADD AL, 30h     ; Tens to ASCII
MOV DL, AL
MOV AH, 02h
INT 21h         ; Display tens

MOV DL, BL
ADD DL, 30h     ; Ones to ASCII
MOV AH, 02h
INT 21h         ; Display ones`
      }
    },
    {
      id: "complete-programs",
      title: "Complete Program Examples",
      icon: "üìÑ",
      
      helloWorld: {
        title: "Hello World",
        code: `.MODEL SMALL
.STACK 100h

.DATA
    MSG DB 'Hello, World!', 0Dh, 0Ah, '$'

.CODE
MAIN PROC
    MOV AX, @DATA
    MOV DS, AX
    
    MOV AH, 09h
    LEA DX, MSG
    INT 21h
    
    MOV AH, 4Ch
    INT 21h
MAIN ENDP
END MAIN`
      },
      
      echoProgram: {
        title: "Echo Program (Type and see characters)",
        code: `.MODEL SMALL
.STACK 100h

.CODE
MAIN PROC
    MOV AH, 01h     ; Read character
    INT 21h         ; AL has character
    
    MOV DL, AL      ; Copy to DL for output
    MOV AH, 02h     ; Display character
    INT 21h
    
    MOV AH, 4Ch     ; Exit
    INT 21h
MAIN ENDP
END MAIN`
      },
      
      readAndDisplay: {
        title: "Read String and Display",
        code: `.MODEL SMALL
.STACK 100h

.DATA
    BUFFER DB 20        ; Max length
           DB ?         ; Actual length (filled by DOS)
           DB 20 DUP('$') ; Buffer space
    MSG1 DB 'Enter text: $'
    MSG2 DB 0Dh, 0Ah, 'You typed: $'

.CODE
MAIN PROC
    MOV AX, @DATA
    MOV DS, AX
    
    ; Display prompt
    MOV AH, 09h
    LEA DX, MSG1
    INT 21h
    
    ; Read input
    MOV AH, 0Ah
    LEA DX, BUFFER
    INT 21h
    
    ; Add $ terminator after input
    MOV BL, BUFFER+1    ; Get actual length
    XOR BH, BH
    MOV BYTE PTR [BUFFER+2+BX], '$'
    
    ; Display result message
    MOV AH, 09h
    LEA DX, MSG2
    INT 21h
    
    ; Display the input
    MOV AH, 09h
    LEA DX, BUFFER+2
    INT 21h
    
    MOV AH, 4Ch
    INT 21h
MAIN ENDP
END MAIN`
      }
    }
  ]
};

// Export all lectures
const lecturesData = [lecture1Content, lecture2Content, lecture3Content, lecture4Content, lecture5Content];


// Summary statistics
const lectureStats = {
  totalLectures: 5,
  totalPages: 328,
  lectures: [{"num": 1, "title": "Course Introduction and Overview of Computer Systems", "pages": 55}, {"num": 2, "title": "Representing Information", "pages": 100}, {"num": 3, "title": "Integer Arithmetic and Floating Point", "pages": 47}, {"num": 4, "title": "Assembly Language Basics", "pages": 65}, {"num": 5, "title": "I/O, Addressing Modes and Assembly Programming", "pages": 61}]
};






        // ============================================
        // NAVIGATION
        // ============================================
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.section).classList.add('active');
            });
        });

        // ============================================
        // LECTURE SYSTEM
        // ============================================
        let currentLecture = 0;

        function renderLecture(index) {
            const lecture = lecturesData[index];
            if (!lecture) return;

            let html = `
                <div class="card">
                    <div class="card-header">
                        <h3>${lecture.icon || 'üìö'} ${lecture.title}</h3>
                        <span>by OsaZain</span>
                    </div>
                    <div style="padding: 15px; background: rgba(74, 144, 217, 0.1); border-radius: 8px; margin-bottom: 20px;">
                        <p style="margin: 0; color: var(--text-muted);">${lecture.description || ''}</p>
                    </div>
            `;

            // Render sections
            if (lecture.sections) {
                lecture.sections.forEach(section => {
                    html += renderSection(section);
                });
            }

            html += '</div>';
            document.getElementById('lecture-content').innerHTML = html;
        }

        function renderSection(section) {
            let html = `<div class="lecture-section" style="margin-bottom: 30px; border-left: 3px solid var(--primary); padding-left: 20px;">`;
            html += `<h4 style="color: var(--primary); margin-bottom: 15px;">${section.icon || ''} ${section.title}</h4>`;
            
            if (section.explanation) {
                html += `<div class="section-explanation" style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px; white-space: pre-wrap;">${escapeHtml(section.explanation)}</div>`;
            }
            
            if (section.analogy) {
                html += `<div class="analogy-box" style="background: rgba(240, 173, 78, 0.1); border-left: 4px solid var(--accent); padding: 15px; margin: 15px 0; border-radius: 0 8px 8px 0;">
                    <strong style="color: var(--accent);">üí° Analogy:</strong> ${escapeHtml(section.analogy)}
                </div>`;
            }
            
            if (section.whyItMatters) {
                html += `<div class="why-box" style="background: rgba(92, 184, 92, 0.1); border-left: 4px solid var(--secondary); padding: 15px; margin: 15px 0; border-radius: 0 8px 8px 0;">
                    <strong style="color: var(--secondary);">üéØ Why It Matters:</strong> ${escapeHtml(section.whyItMatters)}
                </div>`;
            }
            
            if (section.formula) {
                html += `<div class="formula-box" style="background: rgba(155, 89, 182, 0.1); border: 1px solid rgba(155, 89, 182, 0.3); padding: 15px; margin: 15px 0; border-radius: 8px;">
                    <strong style="color: #9b59b6;">üìê Formula:</strong> <code style="background: var(--card-bg); padding: 2px 6px; border-radius: 4px;">${section.formula}</code>
                </div>`;
            }
            
            if (section.examples) {
                html += `<div class="examples-box" style="margin: 15px 0;"><strong style="color: var(--info);">üìã Examples:</strong>`;
                if (Array.isArray(section.examples)) {
                    html += `<ul style="margin: 10px 0; padding-left: 20px;">`;
                    section.examples.forEach(ex => {
                        html += `<li style="margin: 5px 0;">${JSON.stringify(ex)}</li>`;
                    });
                    html += `</ul>`;
                }
                html += `</div>`;
            }
            
            html += `</div>`;
            return html;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.querySelectorAll('.lecture-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.lecture-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLecture = parseInt(btn.dataset.lecture);
                renderLecture(currentLecture);
            });
        });

        // Initialize first lecture
        renderLecture(0);

        // ============================================
        // CALCULATOR SYSTEM
        // ============================================
        
        // Base Converter
        let currentBase = 'dec';
        document.querySelectorAll('.base-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.base-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentBase = tab.dataset.base;
                convertBase();
            });
        });

        document.getElementById('base-input').addEventListener('input', convertBase);
        document.getElementById('base-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') convertBase();
        });
        document.getElementById('base-calc-btn').addEventListener('click', convertBase);

        function convertBase() {
            const input = document.getElementById('base-input').value.trim();
            if (!input) {
                document.getElementById('out-dec').textContent = '-';
                document.getElementById('out-bin').textContent = '-';
                document.getElementById('out-hex').textContent = '-';
                document.getElementById('out-oct').textContent = '-';
                return;
            }

            let dec;
            try {
                switch(currentBase) {
                    case 'dec': dec = parseInt(input, 10); break;
                    case 'bin': dec = parseInt(input, 2); break;
                    case 'hex': dec = parseInt(input.replace('0x', ''), 16); break;
                    case 'oct': dec = parseInt(input, 8); break;
                }
            } catch(e) { return; }

            if (isNaN(dec)) return;

            document.getElementById('out-dec').textContent = dec.toString(10);
            document.getElementById('out-bin').textContent = dec.toString(2);
            document.getElementById('out-hex').textContent = '0x' + dec.toString(16).toUpperCase();
            document.getElementById('out-oct').textContent = dec.toString(8);

            // Generate formula explanation
            let explanation = `<div style="background: rgba(240, 173, 78, 0.1); padding: 15px; border-radius: 8px;">`;
            explanation += `<strong style="color: var(--accent);">üìê Conversion Formulas:</strong>`;
            explanation += `<div style="font-family: monospace; background: var(--bg); padding: 10px; margin: 10px 0; border-radius: 4px;">`;
            
            if (currentBase === 'dec') {
                // Decimal to other bases
                explanation += `<strong>Decimal ‚Üí Binary:</strong> Repeated division by 2<br>`;
                explanation += `<strong>Decimal ‚Üí Hex:</strong> Repeated division by 16<br>`;
                explanation += `</div><strong>Step-by-step for ${dec}:</strong><br>`;
                
                // Show division steps for binary
                let n = dec, steps = [];
                while (n > 0) {
                    steps.push(`${n} √∑ 2 = ${Math.floor(n/2)} remainder ${n%2}`);
                    n = Math.floor(n/2);
                }
                explanation += `<div style="font-family: monospace; font-size: 12px; margin: 5px 0;">`;
                explanation += steps.slice(0, 8).join('<br>');
                if (steps.length > 8) explanation += `<br>...`;
                explanation += `</div>`;
                explanation += `Read remainders <strong>bottom to top</strong>: ${dec.toString(2)}<br>`;
                
                // Hex conversion
                let hn = dec, hsteps = [];
                while (hn > 0) {
                    let rem = hn % 16;
                    hsteps.push(`${hn} √∑ 16 = ${Math.floor(hn/16)} remainder ${rem.toString(16).toUpperCase()}`);
                    hn = Math.floor(hn/16);
                }
                explanation += `<br><strong>Hex conversion:</strong><br>`;
                explanation += `<div style="font-family: monospace; font-size: 12px; margin: 5px 0;">`;
                explanation += hsteps.slice(0, 4).join('<br>');
                explanation += `</div>`;
                explanation += `Result: 0x${dec.toString(16).toUpperCase()}`;
                
            } else if (currentBase === 'bin') {
                // Binary to others
                const groups = dec.toString(2).match(/.{1,4}/g) || [dec.toString(2)];
                explanation += `<strong>Binary ‚Üí Hex:</strong> Group by 4 bits from right<br>`;
                explanation += `<strong>Binary ‚Üí Dec:</strong> Sum of (bit √ó 2<sup>position</sup>)<br>`;
                explanation += `</div><strong>Hex conversion:</strong> ${groups.join(' ')}<br>`;
                explanation += `Each group = 1 hex digit<br>`;
                explanation += `Result: 0x${dec.toString(16).toUpperCase()}`;
                
            } else if (currentBase === 'hex') {
                // Hex to others
                explanation += `<strong>Hex ‚Üí Binary:</strong> Each digit ‚Üí 4 bits<br>`;
                explanation += `<strong>Hex ‚Üí Dec:</strong> Sum of (digit √ó 16<sup>position</sup>)<br>`;
                explanation += `</div><strong>Decimal calculation:</strong><br>`;
                let calc = input.replace('0x', '');
                let total = 0, calcStr = [];
                for (let i = 0; i < calc.length; i++) {
                    let digit = parseInt(calc[calc.length - 1 - i], 16);
                    let value = digit * Math.pow(16, i);
                    total += value;
                    calcStr.push(`${digit}√ó16^${i}=${value}`);
                }
                explanation += calcStr.join(' + ') + ` = ${total}`;
            } else {
                explanation += `Convert to decimal first, then to other bases.`;
            }
            
            explanation += `</div>`;
            document.getElementById('base-explanation').innerHTML = explanation;
        }

        // IEEE 754 Converter
        function updateIEEE754() {
            const val = parseFloat(document.getElementById('ieee-input').value);
            if (isNaN(val)) return;

            const buffer = new ArrayBuffer(4);
            const floatView = new Float32Array(buffer);
            const intView = new Uint32Array(buffer);
            floatView[0] = val;
            const bits = intView[0];

            const sign = (bits >>> 31) & 0x1;
            const exponent = (bits >>> 23) & 0xFF;
            const mantissa = bits & 0x7FFFFF;

            document.getElementById('ieee-sign').textContent = sign;
            document.getElementById('ieee-exp').textContent = exponent + ' (biased: ' + (exponent - 127) + ')';
            document.getElementById('ieee-mant').textContent = '0x' + mantissa.toString(16).toUpperCase().padStart(6, '0');
            document.getElementById('ieee-hex').textContent = '0x' + bits.toString(16).toUpperCase().padStart(8, '0');
            document.getElementById('ieee-bin').textContent = bits.toString(2).padStart(32, '0').replace(/(\d{1})(\d{8})(\d{23})/, '$1 $2 $3');

            // Generate detailed formula explanation
            const actualExp = exponent === 0 ? "-126 (denormalized)" : (exponent - 127);
            const mantissaValue = 1 + (mantissa / Math.pow(2, 23));
            const calculatedValue = (sign ? -1 : 1) * Math.pow(2, parseInt(actualExp)) * (exponent === 0 ? (mantissa / Math.pow(2, 23)) : mantissaValue);
            
            document.getElementById('ieee-explanation').innerHTML = `
                <div style="background: rgba(74, 144, 217, 0.1); padding: 15px; border-radius: 8px; margin-top: 10px;">
                    <strong style="color: var(--primary);">üìê IEEE 754 Formula:</strong>
                    <div style="font-family: monospace; background: var(--bg); padding: 10px; margin: 10px 0; border-radius: 4px;">
                        Value = (-1)<sup>S</sup> √ó 1.M √ó 2<sup>(E-127)</sup>
                    </div>
                    <strong>Step-by-step:</strong><br>
                    1. <strong>Sign bit (S):</strong> ${sign} ‚Üí ${sign ? 'Negative' : 'Positive'}<br>
                    2. <strong>Exponent (E):</strong> ${exponent} ‚àí 127 = ${actualExp}<br>
                    3. <strong>Mantissa (M):</strong> 1.${mantissa.toString(2).padStart(23, '0')} = ${mantissaValue.toFixed(6)}<br>
                    4. <strong>Calculate:</strong> ${sign ? '-' : ''}1.${mantissa.toString(2).padStart(23, '0')} √ó 2<sup>${actualExp}</sup><br>
                    <strong>Result:</strong> ${calculatedValue.toFixed(6)} ‚âà ${val}
                </div>
            `;
        }
        document.getElementById('ieee-input').addEventListener('input', updateIEEE754);
        document.getElementById('ieee-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateIEEE754();
        });
        document.getElementById('ieee-calc-btn').addEventListener('click', updateIEEE754);

        // Two's Complement
        document.getElementById('twos-input').addEventListener('input', updateTwosComplement);
        document.getElementById('twos-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateTwosComplement();
        });
        document.getElementById('twos-bits').addEventListener('change', updateTwosComplement);
        document.getElementById('twos-calc-btn').addEventListener('click', updateTwosComplement);

        function updateTwosComplement() {
            const val = parseInt(document.getElementById('twos-input').value);
            const bits = parseInt(document.getElementById('twos-bits').value);
            if (isNaN(val)) return;

            const max = Math.pow(2, bits);
            const mask = max - 1;
            let unsigned = val & mask;
            
            document.getElementById('twos-bin').textContent = unsigned.toString(2).padStart(bits, '0');
            document.getElementById('twos-hex').textContent = '0x' + unsigned.toString(16).toUpperCase();
            document.getElementById('twos-dec').textContent = val;

            // Generate formula explanation
            const absVal = Math.abs(val);
            const absBinary = absVal.toString(2).padStart(bits, '0');
            const inverted = (max - 1 - absVal).toString(2).padStart(bits, '0');
            const twosComp = ((~absVal + 1) & mask).toString(2).padStart(bits, '0');
            
            let exp = `<div style="background: rgba(92, 184, 92, 0.1); padding: 15px; border-radius: 8px;">`;
            exp += `<strong style="color: var(--secondary);">üìê Two's Complement Formula:</strong>`;
            exp += `<div style="font-family: monospace; background: var(--bg); padding: 10px; margin: 10px 0; border-radius: 4px;">`;
            exp += `For N < 0: Representation = 2<sup>n</sup> + N<br>`;
            exp += `Range: -2<sup>n-1</sup> to 2<sup>n-1</sup> - 1`;
            exp += `</div>`;
            exp += `<strong>Range (${bits}-bit):</strong> ${-(max/2)} to ${(max/2)-1}<br><br>`;
            
            if (val < 0) {
                exp += `<strong>Step-by-step for ${val}:</strong><br>`;
                exp += `1. Absolute value: |${val}| = ${absVal}<br>`;
                exp += `2. Binary: ${absBinary}<br>`;
                exp += `3. Invert bits: ${inverted}<br>`;
                exp += `4. Add 1: ${twosComp}<br>`;
                exp += `<strong>Formula check:</strong> 2^${bits} + (${val}) = ${max} - ${absVal} = ${unsigned} = 0x${unsigned.toString(16).toUpperCase()}`;
            } else {
                exp += `<strong>Positive number:</strong> Direct binary representation<br>`;
                exp += `${val} = ${unsigned.toString(2).padStart(bits, '0')}`;
            }
            exp += `</div>`;
            document.getElementById('twos-explanation').innerHTML = exp;
        }

        // ASCII Converter
        function updateASCIIFromText() {
            const text = document.getElementById('ascii-text').value;
            if (!text) return;

            const codes = [];
            const hex = [];
            const bin = [];
            
            for (let char of text) {
                const code = char.charCodeAt(0);
                codes.push(code);
                hex.push('0x' + code.toString(16).toUpperCase().padStart(2, '0'));
                bin.push(code.toString(2).padStart(8, '0'));
            }

            document.getElementById('ascii-dec').textContent = codes.join(' ');
            document.getElementById('ascii-hex').textContent = hex.join(' ');
            document.getElementById('ascii-bin').textContent = bin.join(' ');
            document.getElementById('ascii-codes').value = codes.join(' ');
        }

        function updateASCIIFromCodes() {
            const codes = document.getElementById('ascii-codes').value.trim().split(/\s+/).map(c => parseInt(c)).filter(c => !isNaN(c));
            if (codes.length === 0) return;

            const text = String.fromCharCode(...codes);
            const hex = codes.map(c => '0x' + c.toString(16).toUpperCase().padStart(2, '0'));
            const bin = codes.map(c => c.toString(2).padStart(8, '0'));

            document.getElementById('ascii-text').value = text;
            document.getElementById('ascii-dec').textContent = codes.join(' ');
            document.getElementById('ascii-hex').textContent = hex.join(' ');
            document.getElementById('ascii-bin').textContent = bin.join(' ');
        }

        document.getElementById('ascii-text').addEventListener('input', updateASCIIFromText);
        document.getElementById('ascii-text').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateASCIIFromText();
        });
        document.getElementById('ascii-codes').addEventListener('input', updateASCIIFromCodes);
        document.getElementById('ascii-codes').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateASCIIFromCodes();
        });
        document.getElementById('ascii-calc-btn').addEventListener('click', function() {
            updateASCIIFromText();
            updateASCIIFromCodes();
        });

        // Bitwise Operations
        ['bit-a', 'bit-b'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('input', updateBitwise);
            el.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') updateBitwise();
            });
        });
        document.getElementById('bit-calc-btn').addEventListener('click', updateBitwise);

        function updateBitwise() {
            let a = parseInt(document.getElementById('bit-a').value.replace('0x', ''), 16) || 0;
            let b = parseInt(document.getElementById('bit-b').value.replace('0x', ''), 16) || 0;

            const and = (a & b) >>> 0;
            const or = (a | b) >>> 0;
            const xor = (a ^ b) >>> 0;
            const not = (~a) >>> 0;
            const shl = (a << 1) >>> 0;
            const shr = (a >>> 1) >>> 0;

            document.getElementById('bit-and').textContent = '0x' + and.toString(16).toUpperCase();
            document.getElementById('bit-or').textContent = '0x' + or.toString(16).toUpperCase();
            document.getElementById('bit-xor').textContent = '0x' + xor.toString(16).toUpperCase();
            document.getElementById('bit-not').textContent = '0x' + not.toString(16).toUpperCase();
            document.getElementById('bit-shl').textContent = '0x' + shl.toString(16).toUpperCase();
            document.getElementById('bit-shr').textContent = '0x' + shr.toString(16).toUpperCase();
        }

        // Address Calculator
        ['addr-seg', 'addr-off'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('input', updateAddress);
            el.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') updateAddress();
            });
        });
        document.getElementById('addr-calc-btn').addEventListener('click', updateAddress);

        function updateAddress() {
            const seg = parseInt(document.getElementById('addr-seg').value.replace('0x', ''), 16) || 0;
            const off = parseInt(document.getElementById('addr-off').value.replace('0x', ''), 16) || 0;

            const physical = ((seg << 4) + off) & 0xFFFFF;

            document.getElementById('addr-physical').textContent = '0x' + physical.toString(16).toUpperCase().padStart(5, '0');
            document.getElementById('addr-calc').textContent = `${seg} √ó 16 + ${off} = ${physical}`;
        }

        // ============================================
        // SIMULATOR SYSTEM
        // ============================================
        class CPUSimulator {
            constructor() {
                this.registers = {
                    AX: 0x0000, BX: 0x0000, CX: 0x0000, DX: 0x0000,
                    SI: 0x0000, DI: 0x0000, BP: 0x0000, SP: 0xFFFE,
                    CS: 0xF000, DS: 0x0000, SS: 0x0000, ES: 0x0000,
                    IP: 0x0000, FLAGS: 0x0002
                };
                this.selectedReg = null;
                this.history = [];
                this.flagBits = { CF: 0, PF: 2, AF: 4, ZF: 6, SF: 7, TF: 8, IF: 9, DF: 10, OF: 11 };
                this.saveState();
                this.attachListeners();
                this.updateDisplay();
            }

            saveState() {
                this.history.push(JSON.parse(JSON.stringify(this.registers)));
                if (this.history.length > 50) this.history.shift();
            }

            undo() {
                if (this.history.length > 1) {
                    this.history.pop();
                    this.registers = JSON.parse(JSON.stringify(this.history[this.history.length - 1]));
                    this.updateDisplay();
                }
            }

            reset() {
                this.registers = {
                    AX: 0x0000, BX: 0x0000, CX: 0x0000, DX: 0x0000,
                    SI: 0x0000, DI: 0x0000, BP: 0x0000, SP: 0xFFFE,
                    CS: 0xF000, DS: 0x0000, SS: 0x0000, ES: 0x0000,
                    IP: 0x0000, FLAGS: 0x0002
                };
                this.saveState();
                this.updateDisplay();
            }

            getFlag(flag) {
                return (this.registers.FLAGS >> this.flagBits[flag]) & 1;
            }

            setFlag(flag, value) {
                const bit = this.flagBits[flag];
                if (value) {
                    this.registers.FLAGS |= (1 << bit);
                } else {
                    this.registers.FLAGS &= ~(1 << bit);
                }
            }

            getHigh(reg) {
                return (this.registers[reg] >> 8) & 0xFF;
            }

            getLow(reg) {
                return this.registers[reg] & 0xFF;
            }

            setHigh(reg, val) {
                this.registers[reg] = ((val & 0xFF) << 8) | (this.registers[reg] & 0xFF);
            }

            setLow(reg, val) {
                this.registers[reg] = (this.registers[reg] & 0xFF00) | (val & 0xFF);
            }

            updateDisplay() {
                // Update all register displays
                ['AX', 'BX', 'CX', 'DX', 'SI', 'DI', 'BP', 'SP', 'CS', 'DS', 'SS', 'ES', 'IP'].forEach(reg => {
                    const el = document.getElementById(`sim-${reg.toLowerCase()}`);
                    if (el) {
                        el.textContent = this.registers[reg].toString(16).toUpperCase().padStart(4, '0') + 'h';
                    }
                });

                // Update 8-bit displays
                ['A', 'B', 'C', 'D'].forEach(pre => {
                    const high = this.getHigh(pre + 'X');
                    const low = this.getLow(pre + 'X');
                    const highEl = document.getElementById(`sim-${pre.toLowerCase()}h`);
                    const lowEl = document.getElementById(`sim-${pre.toLowerCase()}l`);
                    const binEl = document.getElementById(`sim-${pre.toLowerCase()}x-bin`);
                    
                    if (highEl) highEl.textContent = high.toString(16).toUpperCase().padStart(2, '0') + 'h';
                    if (lowEl) lowEl.textContent = low.toString(16).toUpperCase().padStart(2, '0') + 'h';
                    if (binEl) {
                        const val = this.registers[pre + 'X'];
                        binEl.textContent = val.toString(2).padStart(16, '0').replace(/(.{8})/, '$1 ');
                    }
                });

                // Update flags
                Object.keys(this.flagBits).forEach(flag => {
                    const el = document.getElementById(`flag-${flag.toLowerCase()}`);
                    if (el) {
                        el.classList.toggle('set', this.getFlag(flag) === 1);
                    }
                });

                document.getElementById('sim-flags').textContent = this.registers.FLAGS.toString(16).toUpperCase().padStart(4, '0') + 'h';
                document.getElementById('sim-flags-bin').textContent = this.registers.FLAGS.toString(2).padStart(16, '0').replace(/(.{8})/, '$1 ');
            }

            attachListeners() {
                // Register selection
                document.querySelectorAll('[data-reg]').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.reg-card, .simple-reg').forEach(r => r.classList.remove('selected'));
                        el.classList.add('selected');
                        this.selectedReg = el.dataset.reg;
                        document.getElementById('selected-reg').textContent = this.selectedReg;
                    });
                });

                // Operation buttons
                document.querySelectorAll('.op-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (!this.selectedReg) {
                            alert('Please select a register first');
                            return;
                        }
                        const op = btn.dataset.op;
                        if (op === 'SET') {
                            const val = prompt(`Enter value for ${this.selectedReg} (hex):`);
                            if (val) {
                                this.saveState();
                                this.registers[this.selectedReg] = parseInt(val.replace('h', ''), 16) & 0xFFFF;
                                this.updateDisplay();
                                document.getElementById('last-op').textContent = `Last: MOV ${this.selectedReg}, ${val}`;
                            }
                        } else {
                            this.executeOp(op);
                        }
                    });
                });

                document.getElementById('exec-op').addEventListener('click', () => {
                    const op = document.querySelector('.op-btn[data-op="MOV"]');
                    if (op) op.click();
                });

                document.getElementById('sim-reset').addEventListener('click', () => this.reset());
                document.getElementById('sim-undo').addEventListener('click', () => this.undo());

                document.getElementById('example-select').addEventListener('change', (e) => {
                    this.loadExample(e.target.value);
                });
            }

            executeOp(op) {
                this.saveState();
                const reg = this.selectedReg;
                const is8bit = reg.length === 2 && /[HL]$/.test(reg);
                const baseReg = is8bit ? reg.charAt(0) + 'X' : reg;
                
                let val = is8bit ? (reg.endsWith('H') ? this.getHigh(baseReg) : this.getLow(baseReg)) : this.registers[reg];
                const immVal = parseInt(document.getElementById('imm-value').value.replace('h', ''), 16) || 0;
                
                let result, oldVal = val;
                const max = is8bit ? 0xFF : 0xFFFF;
                const bits = is8bit ? 8 : 16;

                switch(op) {
                    case 'MOV': result = immVal & max; break;
                    case 'ADD': 
                        result = (val + immVal) & max;
                        this.setFlag('CF', (val + immVal) > max);
                        this.updateFlags(result, bits);
                        break;
                    case 'SUB': 
                        result = (val - immVal) & max;
                        this.setFlag('CF', val < immVal);
                        this.updateFlags(result, bits);
                        break;
                    case 'INC': 
                        result = (val + 1) & max;
                        this.updateFlags(result, bits);
                        break;
                    case 'DEC': 
                        result = (val - 1) & max;
                        this.updateFlags(result, bits);
                        break;
                    case 'AND': 
                        result = val & immVal;
                        this.setFlag('CF', 0);
                        this.setFlag('OF', 0);
                        this.updateFlags(result, bits);
                        break;
                    case 'OR': 
                        result = val | immVal;
                        this.setFlag('CF', 0);
                        this.setFlag('OF', 0);
                        this.updateFlags(result, bits);
                        break;
                    case 'XOR': 
                        result = val ^ immVal;
                        this.setFlag('CF', 0);
                        this.setFlag('OF', 0);
                        this.updateFlags(result, bits);
                        break;
                    case 'NOT': 
                        result = (~val) & max;
                        break;
                    case 'SHL': 
                        result = (val << 1) & max;
                        this.setFlag('CF', (val >> (bits - 1)) & 1);
                        this.updateFlags(result, bits);
                        break;
                    case 'SHR': 
                        result = (val >>> 1) & max;
                        this.setFlag('CF', val & 1);
                        this.updateFlags(result, bits);
                        break;
                    default: return;
                }

                if (is8bit) {
                    if (reg.endsWith('H')) this.setHigh(baseReg, result);
                    else this.setLow(baseReg, result);
                } else {
                    this.registers[reg] = result;
                }

                this.updateDisplay();
                document.getElementById('last-op').textContent = `Last: ${op} ${reg}${op !== 'NOT' && op !== 'INC' && op !== 'DEC' ? ', ' + immVal.toString(16).toUpperCase() + 'h' : ''}`;
            }

            updateFlags(result, bits) {
                this.setFlag('ZF', result === 0);
                this.setFlag('SF', (result >> (bits - 1)) & 1);
                this.setFlag('PF', this.calcParity(result & 0xFF));
            }

            calcParity(byte) {
                let count = 0;
                for (let i = 0; i < 8; i++) count += (byte >> i) & 1;
                return count % 2 === 0;
            }

            loadExample(name) {
                this.reset();
                this.saveState();
                
                const examples = {
                    'hello': () => {
                        this.registers.AX = 0x0900;
                        this.registers.DX = 0x0000;
                    },
                    'add': () => {
                        this.registers.AX = 0x0010;
                        this.registers.BX = 0x0020;
                    },
                    'loop': () => {
                        this.registers.CX = 0x000A;
                    },
                    'string': () => {
                        this.registers.SI = 0x0100;
                        this.registers.DI = 0x0200;
                        this.registers.DS = 0x0000;
                        this.registers.ES = 0x0000;
                    },
                    'stack': () => {
                        this.registers.SP = 0x0FFE;
                        this.registers.SS = 0x0000;
                        this.registers.AX = 0x1234;
                    },
                    'flags': () => {
                        this.registers.AX = 0x00FF;
                        this.registers.FLAGS = 0x0000;
                    }
                };

                if (examples[name]) {
                    examples[name]();
                    this.updateDisplay();
                }
            }
        }

        const simulator = new CPUSimulator();



        // ============================================
        // FLASHCARDS SYSTEM
        // ============================================
        const flashcardsData = [
            { category: "Registers", question: "What is the AX register used for?", answer: "AX is the Accumulator register used for arithmetic operations, I/O operations, and interrupt calls. It can be accessed as two 8-bit registers: AH (high) and AL (low)." },
            { category: "Registers", question: "What is the difference between AX and AL?", answer: "AX is a 16-bit register, while AL is the lower 8 bits of AX. AH contains the upper 8 bits. Many operations can work with either the full 16-bit AX or just the 8-bit AL." },
            { category: "Registers", question: "What is the CX register primarily used for?", answer: "CX is the Count register. It's used as a loop counter (LOOP instruction decrements CX), for string operations with REP prefix, and for shift/rotate counts." },
            { category: "Registers", question: "What is the purpose of the BX register?", answer: "BX is the Base register. It's commonly used as a pointer to data in memory, especially for array indexing and addressing calculations." },
            { category: "Registers", question: "What is the DX register used for?", answer: "DX is the Data register. It's used for I/O operations, as an extension of AX for multiply/divide operations (high word), and for port addressing." },
            { category: "Registers", question: "What is the SI register?", answer: "SI (Source Index) is used as a source pointer for string operations. By default, it works with the DS (Data Segment) register." },
            { category: "Registers", question: "What is the DI register?", answer: "DI (Destination Index) is used as a destination pointer for string operations. It works with the ES (Extra Segment) register by default." },
            { category: "Registers", question: "What is the difference between SP and BP?", answer: "SP (Stack Pointer) always points to the top of the stack. BP (Base Pointer) is used to access data on the stack (parameters and local variables) without modifying SP." },
            { category: "Registers", question: "What are segment registers?", answer: "Segment registers (CS, DS, SS, ES) define memory segments. CS=Code Segment, DS=Data Segment, SS=Stack Segment, ES=Extra Segment for string destinations." },
            { category: "Registers", question: "Why can't you MOV an immediate value directly to DS?", answer: "You cannot move an immediate value directly to a segment register. You must use a general-purpose register as an intermediary: MOV AX, @DATA then MOV DS, AX." },
            { category: "Flags", question: "What is the Zero Flag (ZF)?", answer: "ZF is set when the result of an operation is zero. It's used for equality comparisons (JE/JZ jumps if ZF=1)." },
            { category: "Flags", question: "What is the Carry Flag (CF)?", answer: "CF is set when an arithmetic operation generates a carry out of or borrow into the most significant bit. Used for unsigned comparisons." },
            { category: "Flags", question: "What is the Sign Flag (SF)?", answer: "SF is set when the result of an operation is negative (the most significant bit is 1). It reflects the sign bit of the result." },
            { category: "Flags", question: "What is the Overflow Flag (OF)?", answer: "OF is set when a signed arithmetic operation results in overflow (the result is too large or too small for the destination)." },
            { category: "Flags", question: "What is the Parity Flag (PF)?", answer: "PF is set when the result has an even number of 1 bits in the least significant byte. Used for error checking." },
            { category: "Instructions", question: "What does the MOV instruction do?", answer: "MOV copies data from source to destination. It does NOT affect any flags. It can move between registers, memory, and immediate values (with restrictions)." },
            { category: "Instructions", question: "What is the difference between ADD and INC?", answer: "ADD adds any value to a register/memory. INC adds exactly 1. ADD affects CF, but INC does NOT affect the Carry Flag." },
            { category: "Instructions", question: "What does the CMP instruction do?", answer: "CMP compares two operands by subtracting them (without storing the result). It sets flags based on the result for conditional jumps." },
            { category: "Instructions", question: "What does JMP do?", answer: "JMP (Jump) unconditionally transfers control to a different location in the code. It can be short, near, or far." },
            { category: "Instructions", question: "What is the difference between JE and JZ?", answer: "JE (Jump if Equal) and JZ (Jump if Zero) are the same instruction. Both jump if ZF=1 (typically after CMP)." },
            { category: "Instructions", question: "What does the LOOP instruction do?", answer: "LOOP decrements CX and jumps if CX is not zero. It's used for creating counted loops without manually updating the counter." },
            { category: "Instructions", question: "What does INT 21h do?", answer: "INT 21h is the DOS interrupt. The function number goes in AH. Common functions: 01h (input), 02h (output char), 09h (output string), 4Ch (exit)." },
            { category: "Instructions", question: "What does PUSH do?", answer: "PUSH decrements SP by 2 and stores a word on the stack. It's used to save register values or pass parameters." },
            { category: "Instructions", question: "What does POP do?", answer: "POP retrieves a word from the stack (at SP) and increments SP by 2. It restores values saved by PUSH." },
            { category: "Instructions", question: "What does CALL do?", answer: "CALL pushes the return address (next instruction) onto the stack and jumps to a procedure. RET returns by popping the address." },
            { category: "Instructions", question: "What is the difference between SHL and SHR?", answer: "SHL (Shift Left) shifts bits left, filling with zeros. SHR (Shift Right) shifts bits right, filling with zeros. Both shift CF gets the bit shifted out." },
            { category: "Instructions", question: "What does the NOT instruction do?", answer: "NOT inverts all bits (one's complement). It does NOT affect any flags, unlike NEG which affects flags." },
            { category: "Instructions", question: "What is the LEA instruction?", answer: "LEA (Load Effective Address) calculates the address of a memory operand and stores it in a register. It doesn't access memory, just computes the address." },
            { category: "Instructions", question: "What does the TEST instruction do?", answer: "TEST performs a bitwise AND and sets flags (like ZF, SF, PF) but doesn't store the result. Used for checking bits without modifying data." },
            { category: "Memory", question: "How is physical address calculated in real mode?", answer: "Physical Address = Segment √ó 16 + Offset. A segment register is shifted left 4 bits (√ó16) and added to the offset." },
            { category: "Memory", question: "What is little-endian byte ordering?", answer: "In little-endian (used by x86), the least significant byte is stored at the lowest memory address. For 0x1234, 0x34 is stored first." },
            { category: "Memory", question: "What is the stack?", answer: "The stack is a LIFO (Last-In-First-Out) data structure in memory. SS:SP points to the top. It grows downward (toward lower addresses)." },
            { category: "Memory", question: "What is the difference between .DATA and .CODE segments?", answer: ".DATA contains initialized variables and data. .CODE contains executable instructions. The CPU fetches instructions from CS (Code Segment)." },
            { category: "Memory", question: "What is a buffer overflow?", answer: "A buffer overflow occurs when data written to a buffer exceeds its allocated size, potentially overwriting adjacent memory including return addresses." },
            { category: "Data Types", question: "What is the range of an 8-bit signed integer?", answer: "An 8-bit signed integer (using two's complement) ranges from -128 to +127. The MSB is the sign bit." },
            { category: "Data Types", question: "What is the range of a 16-bit unsigned integer?", answer: "A 16-bit unsigned integer ranges from 0 to 65,535 (0 to 2^16 - 1). All bits are used for magnitude." },
            { category: "Data Types", question: "How is -5 represented in 8-bit two's complement?", answer: "-5 in 8-bit two's complement is 0xFB (11111011). Invert 00000101 to get 11111010, then add 1." },
            { category: "Data Types", question: "What is ASCII?", answer: "ASCII (American Standard Code for Information Interchange) is a 7-bit character encoding. 'A' = 65 (0x41), '0' = 48 (0x30)." },
            { category: "Data Types", question: "What is the difference between DB and DW?", answer: "DB (Define Byte) allocates 8-bit data. DW (Define Word) allocates 16-bit data. DD allocates 32-bit (double word) data." },
            { category: "Addressing", question: "What is direct addressing?", answer: "Direct addressing uses a constant address: MOV AX, [1000h]. The value is taken from memory address DS:1000h." },
            { category: "Addressing", question: "What is register indirect addressing?", answer: "Register indirect uses a register as a pointer: MOV AX, [BX]. BX contains the offset address in the data segment." },
            { category: "Addressing", question: "What is based-indexed addressing?", answer: "Based-indexed combines a base register (BX or BP) with an index register (SI or DI): MOV AX, [BX+SI]." },
            { category: "Procedures", question: "What is the purpose of PROC and ENDP?", answer: "PROC marks the beginning of a procedure, ENDP marks the end. They help organize code into reusable subroutines." },
            { category: "Procedures", question: "What registers must be preserved in a procedure?", answer: "According to convention, BP, SP, DS, SI, and DI should be preserved if modified. AX, BX, CX, DX are typically scratch registers." },
            { category: "Procedures", question: "What is the difference between RET and RET n?", answer: "RET pops the return address and returns. RET n (e.g., RET 4) also adds n to SP after popping, used to clean up stack parameters." },
            { category: "Interrupts", question: "What is an interrupt?", answer: "An interrupt is a signal that causes the CPU to pause current execution and execute an interrupt handler, then return to the original code." },
            { category: "Interrupts", question: "What is the difference between hardware and software interrupts?", answer: "Hardware interrupts are triggered by external devices. Software interrupts (like INT 21h) are triggered by the INT instruction in code." },
            { category: "Macros", question: "What is the difference between a macro and a procedure?", answer: "A macro is expanded inline at assembly time (faster, larger code). A procedure is called at runtime (slower, reusable, smaller code)." },
            { category: "I/O", question: "How do you output a character in DOS?", answer: "MOV AH, 02h (function 2), MOV DL, 'A' (character), INT 21h. The character in DL is displayed on screen." },
            { category: "I/O", question: "How do you input a character in DOS?", answer: "MOV AH, 01h, INT 21h. The character is returned in AL, and also echoed to the screen." },
            { category: "I/O", question: "How do you output a string in DOS?", answer: "MOV AH, 09h, MOV DX, offset string, INT 21h. The string must be '$' terminated (not null-terminated)." },
            { category: "Optimization", question: "Why use XOR AX, AX instead of MOV AX, 0?", answer: "XOR AX, AX is faster (fewer bytes, fewer cycles) and clears the register to zero. It's a common optimization technique." }
        ];

        let currentCard = 0;
        let knownCards = 0;
        let reviewCards = 0;
        let cardOrder = [...Array(flashcardsData.length).keys()];

        function updateFlashcard() {
            const card = flashcardsData[cardOrder[currentCard]];
            document.getElementById('fc-category').textContent = card.category;
            document.getElementById('fc-question').textContent = card.question;
            document.getElementById('fc-answer').textContent = card.answer;
            document.getElementById('fc-current').textContent = currentCard + 1;
            document.getElementById('fc-total').textContent = flashcardsData.length;
            document.getElementById('fc-known').textContent = knownCards;
            document.getElementById('fc-review').textContent = reviewCards;
            document.getElementById('flashcard').classList.remove('flipped');
        }

        document.getElementById('flashcard').addEventListener('click', () => {
            document.getElementById('flashcard').classList.toggle('flipped');
        });

        document.getElementById('fc-know').addEventListener('click', () => {
            knownCards++;
            currentCard++;
            if (currentCard >= flashcardsData.length) {
                currentCard = 0;
                alert('Deck complete! Starting over.');
            }
            updateFlashcard();
        });

        document.getElementById('fc-dont').addEventListener('click', () => {
            reviewCards++;
            currentCard++;
            if (currentCard >= flashcardsData.length) {
                currentCard = 0;
                alert('Deck complete! Starting over.');
            }
            updateFlashcard();
        });

        document.getElementById('fc-shuffle').addEventListener('click', () => {
            cardOrder.sort(() => Math.random() - 0.5);
            currentCard = 0;
            knownCards = 0;
            reviewCards = 0;
            updateFlashcard();
        });

        updateFlashcard();

        // ============================================
        // GAMES SYSTEM
        // ============================================
        const games = {
            registerRacer: {
                title: 'üèéÔ∏è Register Racer',
                questions: [
                    { q: 'Store loop counter', a: 'CX', options: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Store string source address', a: 'SI', options: ['SI', 'DI', 'SP', 'BP'] },
                    { q: 'Store string destination address', a: 'DI', options: ['SI', 'DI', 'SP', 'BP'] },
                    { q: 'Accumulator for arithmetic', a: 'AX', options: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Base register for addressing', a: 'BX', options: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Data register for I/O', a: 'DX', options: ['AX', 'BX', 'CX', 'DX'] },
                    { q: 'Stack pointer', a: 'SP', options: ['SI', 'DI', 'SP', 'BP'] },
                    { q: 'Base pointer for stack frames', a: 'BP', options: ['SI', 'DI', 'SP', 'BP'] }
                ]
            },
            hexHunter: {
                title: 'üî¢ Hex Hunter',
                modes: ['decToHex', 'hexToDec', 'binToHex', 'hexToBin']
            }
        };

        let currentGame = null;
        let gameScore = 0;
        let gameTimer = null;
        let gameTime = 60;

        document.querySelectorAll('.game-card').forEach(card => {
            card.addEventListener('click', () => {
                const gameName = card.dataset.game;
                startGame(gameName);
            });
        });

        function startGame(gameName) {
            currentGame = gameName;
            document.getElementById('games-menu').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';

            if (gameName === 'registerRacer') {
                initRegisterRacer();
            } else if (gameName === 'hexHunter') {
                initHexHunter();
            } else {
                // Generic game placeholder
                document.getElementById('game-container').innerHTML = `
                    <div class="game-container">
                        <div class="game-header-compact">
                            <button class="btn-back" onclick="backToGames()">‚Üê Back to Games</button>
                            <h2>${games[gameName]?.title || gameName}</h2>
                        </div>
                        <div style="text-align: center; padding: 50px;">
                            <p>Game implementation for ${gameName}</p>
                            <button class="btn btn-primary" onclick="backToGames()">Back</button>
                        </div>
                    </div>
                `;
            }
        }

        function backToGames() {
            clearInterval(gameTimer);
            document.getElementById('games-menu').style.display = 'block';
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('game-container').innerHTML = '';
        }

        function initRegisterRacer() {
            gameScore = 0;
            gameTime = 60;
            let currentQ = 0;
            let streak = 0;
            
            const questions = [...games.registerRacer.questions].sort(() => Math.random() - 0.5);
            
            document.getElementById('game-container').innerHTML = `
                <div class="game-container register-racer">
                    <div class="game-header-compact">
                        <div class="header-left">
                            <button class="btn-back" onclick="backToGames()">‚Üê Back</button>
                            <h2>üèéÔ∏è Register Racer</h2>
                        </div>
                        <div class="game-stats-bar">
                            <span class="stat-box">‚≠ê <span id="rr-score">0</span></span>
                            <span class="stat-box">üî• <span id="rr-streak">0</span></span>
                        </div>
                    </div>
                    <div class="timer-bar">
                        <div class="timer-progress" id="rr-timer-bar"></div>
                        <span class="timer-text">‚è±Ô∏è <span id="rr-timer">60</span>s</span>
                    </div>
                    <div style="text-align: center; padding: 30px;">
                        <h3 id="rr-question">${questions[0].q}</h3>
                        <div class="answers-grid" id="rr-answers"></div>
                        <div id="rr-feedback" style="margin-top: 20px; font-size: 18px;"></div>
                    </div>
                </div>
            `;

            renderAnswers(questions[0]);
            startGameTimer();

            function renderAnswers(q) {
                const grid = document.getElementById('rr-answers');
                grid.innerHTML = q.options.map(opt => 
                    `<button class="answer-btn" data-ans="${opt}">${opt}</button>`
                ).join('');

                grid.querySelectorAll('.answer-btn').forEach(btn => {
                    btn.addEventListener('click', () => checkAnswer(btn, q));
                });
            }

            function checkAnswer(btn, q) {
                const correct = btn.dataset.ans === q.a;
                const feedback = document.getElementById('rr-feedback');
                
                if (correct) {
                    streak++;
                    const points = 10 + (streak > 3 ? 5 : 0);
                    gameScore += points;
                    feedback.innerHTML = `‚úÖ Correct! +${points} points`;
                    feedback.style.color = 'var(--success)';
                } else {
                    streak = 0;
                    feedback.innerHTML = `‚ùå Wrong! The answer was ${q.a}`;
                    feedback.style.color = 'var(--danger)';
                }

                document.getElementById('rr-score').textContent = gameScore;
                document.getElementById('rr-streak').textContent = streak;

                setTimeout(() => {
                    currentQ++;
                    if (currentQ >= questions.length) currentQ = 0;
                    document.getElementById('rr-question').textContent = questions[currentQ].q;
                    feedback.textContent = '';
                    renderAnswers(questions[currentQ]);
                }, 1500);
            }

            function startGameTimer() {
                gameTimer = setInterval(() => {
                    gameTime--;
                    document.getElementById('rr-timer').textContent = gameTime;
                    document.getElementById('rr-timer-bar').style.width = (gameTime/60*100) + '%';
                    
                    if (gameTime <= 0) {
                        clearInterval(gameTimer);
                        alert(`Game Over! Final Score: ${gameScore}`);
                        backToGames();
                    }
                }, 1000);
            }
        }

        function initHexHunter() {
            gameScore = 0;
            gameTime = 90;
            let inputBuffer = '';
            
            document.getElementById('game-container').innerHTML = `
                <div class="game-container hex-hunter">
                    <div class="game-header-compact">
                        <div class="header-left">
                            <button class="btn-back" onclick="backToGames()">‚Üê Back</button>
                            <h2>üî¢ Hex Hunter</h2>
                        </div>
                        <div class="game-stats-bar">
                            <span class="stat-box">‚≠ê <span id="hh-score">0</span></span>
                        </div>
                    </div>
                    <div class="timer-bar">
                        <div class="timer-progress" id="hh-timer-bar"></div>
                        <span class="timer-text">‚è±Ô∏è <span id="hh-timer">90</span>s</span>
                    </div>
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">Convert:</div>
                        <div style="font-size: 36px; font-weight: bold; color: var(--primary);" id="hh-from">Decimal: 255</div>
                        <div style="font-size: 20px; margin: 20px 0;">‚Üì</div>
                        <div style="font-size: 18px;">to Hexadecimal</div>
                        <div style="font-size: 32px; font-family: monospace; margin: 20px 0; padding: 15px; background: var(--bg); border-radius: 8px;" id="hh-input">_</div>
                        <div id="hh-feedback" style="margin: 10px 0; min-height: 24px;"></div>
                    </div>
                    <div class="keypad">
                        <div class="keypad-row">
                            <button class="key" data-key="1">1</button>
                            <button class="key" data-key="2">2</button>
                            <button class="key" data-key="3">3</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key" data-key="4">4</button>
                            <button class="key" data-key="5">5</button>
                            <button class="key" data-key="6">6</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key" data-key="7">7</button>
                            <button class="key" data-key="8">8</button>
                            <button class="key" data-key="9">9</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key hex" data-key="A">A</button>
                            <button class="key" data-key="0">0</button>
                            <button class="key hex" data-key="B">B</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key hex" data-key="C">C</button>
                            <button class="key hex" data-key="D">D</button>
                            <button class="key hex" data-key="E">E</button>
                            <button class="key hex" data-key="F">F</button>
                        </div>
                        <div class="keypad-row">
                            <button class="key control" data-key="CLR">CLR</button>
                            <button class="key control" data-key="DEL">‚å´</button>
                            <button class="key control enter" data-key="ENT">‚èé</button>
                        </div>
                    </div>
                </div>
            `;

            let fromVal = Math.floor(Math.random() * 256);
            document.getElementById('hh-from').textContent = `Decimal: ${fromVal}`;

            document.querySelectorAll('.key').forEach(key => {
                key.addEventListener('click', () => {
                    const k = key.dataset.key;
                    if (k === 'CLR') {
                        inputBuffer = '';
                    } else if (k === 'DEL') {
                        inputBuffer = inputBuffer.slice(0, -1);
                    } else if (k === 'ENT') {
                        checkHexAnswer();
                    } else if (inputBuffer.length < 4) {
                        inputBuffer += k;
                    }
                    document.getElementById('hh-input').textContent = inputBuffer || '_';
                });
            });

            function checkHexAnswer() {
                const correct = fromVal.toString(16).toUpperCase();
                const feedback = document.getElementById('hh-feedback');
                
                if (inputBuffer === correct) {
                    gameScore += 15;
                    feedback.innerHTML = '‚úÖ Correct!';
                    feedback.style.color = 'var(--success)';
                } else {
                    feedback.innerHTML = `‚ùå Wrong! ${fromVal} = 0x${correct}`;
                    feedback.style.color = 'var(--danger)';
                }
                
                document.getElementById('hh-score').textContent = gameScore;
                
                setTimeout(() => {
                    fromVal = Math.floor(Math.random() * 256);
                    document.getElementById('hh-from').textContent = `Decimal: ${fromVal}`;
                    inputBuffer = '';
                    document.getElementById('hh-input').textContent = '_';
                    feedback.textContent = '';
                }, 1500);
            }

            gameTimer = setInterval(() => {
                gameTime--;
                document.getElementById('hh-timer').textContent = gameTime;
                document.getElementById('hh-timer-bar').style.width = (gameTime/90*100) + '%';
                
                if (gameTime <= 0) {
                    clearInterval(gameTimer);
                    alert(`Game Over! Final Score: ${gameScore}`);
                    backToGames();
                }
            }, 1000);
        }



        // ============================================
        // TEST SYSTEM
        // ============================================
        const testQuestions = [
            {
                question: "Which register is traditionally used as the accumulator for arithmetic operations in x86 assembly?",
                options: ["BX", "CX", "DX", "AX"],
                correct: 3,
                explanation: "AX is the Accumulator register. It's optimized for arithmetic operations like MUL, DIV, and is used for I/O operations and interrupt calls. It can be accessed as 8-bit halves (AH and AL)."
            },
            {
                question: "What is the purpose of the CX register in x86 assembly?",
                options: ["Accumulator", "Base pointer", "Counter for loops", "Data register"],
                correct: 2,
                explanation: "CX is the Count register. It's used as a loop counter (the LOOP instruction automatically decrements CX), for string operations with REP prefix, and for shift/rotate counts."
            },
            {
                question: "Which flag is set when the result of an arithmetic operation is zero?",
                options: ["Carry Flag (CF)", "Zero Flag (ZF)", "Sign Flag (SF)", "Overflow Flag (OF)"],
                correct: 1,
                explanation: "The Zero Flag (ZF) is set when the result of an operation is zero. It's commonly used after CMP to test for equality (JE/JZ jumps if ZF=1)."
            },
            {
                question: "What is the correct formula for calculating physical address in x86 real mode?",
                options: ["Segment + Offset", "Segment √ó 16 + Offset", "Segment √ó 256 + Offset", "Segment << 8 + Offset"],
                correct: 1,
                explanation: "Physical Address = Segment √ó 16 + Offset. The segment register is shifted left 4 bits (equivalent to multiplying by 16) and added to the offset to form the 20-bit physical address."
            },
            {
                question: "Which instruction is used to compare two values without storing the result?",
                options: ["SUB", "CMP", "TEST", "XOR"],
                correct: 1,
                explanation: "CMP (Compare) subtracts the second operand from the first and sets flags based on the result, but does not store the result. It's used before conditional jumps to make decisions."
            },
            {
                question: "What is the range of values for an 8-bit signed integer using two's complement?",
                options: ["0 to 255", "-127 to 127", "-128 to 127", "-256 to 255"],
                correct: 2,
                explanation: "An 8-bit signed integer ranges from -128 to +127. The MSB is the sign bit (0=positive, 1=negative), allowing 128 negative numbers and 128 non-negative numbers (0-127)."
            },
            {
                question: "What does the instruction 'MOV AX, @DATA' followed by 'MOV DS, AX' accomplish?",
                options: ["Clears the data segment", "Initializes DS with the data segment address", "Saves AX to memory", "Loads AX with the stack pointer"],
                correct: 1,
                explanation: "You cannot move an immediate value directly to a segment register like DS. This sequence uses AX as an intermediary to initialize the Data Segment register with the address of the data segment."
            },
            {
                question: "Which x86 flag indicates a signed arithmetic overflow?",
                options: ["Carry Flag (CF)", "Parity Flag (PF)", "Overflow Flag (OF)", "Auxiliary Flag (AF)"],
                correct: 2,
                explanation: "The Overflow Flag (OF) is set when a signed arithmetic operation produces a result too large or too small to fit in the destination. CF indicates unsigned overflow."
            },
            {
                question: "What is the difference between SHL and SHR instructions?",
                options: ["SHL is faster", "SHL shifts left, SHR shifts right", "SHL affects CF, SHR does not", "SHL is for 8-bit, SHR is for 16-bit"],
                correct: 1,
                explanation: "SHL (Shift Left) shifts bits to the left, filling with zeros. SHR (Shift Right) shifts bits to the right, filling with zeros. Both affect the Carry Flag with the bit shifted out."
            },
            {
                question: "What is the purpose of the LOOP instruction?",
                options: ["Jump to a subroutine", "Decrement CX and jump if not zero", "Compare two strings", "Load a register with an address"],
                correct: 1,
                explanation: "LOOP decrements CX and jumps to the specified label if CX is not zero. It provides a convenient way to create counted loops without manually decrementing and testing the counter."
            },
            {
                question: "In little-endian byte ordering, how is the 16-bit value 0x1234 stored in memory?",
                options: ["12 34", "34 12", "00 12 34", "12 34 00"],
                correct: 1,
                explanation: "In little-endian (used by x86), the least significant byte is stored first. So 0x1234 is stored as 0x34 at the lower address, followed by 0x12 at the higher address."
            },
            {
                question: "Which interrupt is used for DOS system calls?",
                options: ["INT 10h", "INT 16h", "INT 21h", "INT 33h"],
                correct: 2,
                explanation: "INT 21h is the DOS interrupt. The function number is placed in AH. Common functions: 01h (input), 02h (output char), 09h (output string), 4Ch (exit program)."
            },
            {
                question: "What does the PUSH instruction do?",
                options: ["Increments SP and stores a value", "Decrements SP and stores a value", "Stores a value without changing SP", "Loads a value from the stack"],
                correct: 1,
                explanation: "PUSH decrements SP by 2 (for a word) and stores the value at the new stack location. The stack grows downward in memory, toward lower addresses."
            },
            {
                question: "What is the result of XOR AX, AX?",
                options: ["AX = 0xFFFF", "AX = 0", "AX unchanged", "AX = AX + AX"],
                correct: 1,
                explanation: "XORing a value with itself produces zero. XOR AX, AX is a common optimization to clear a register to zero - it's faster and uses fewer bytes than MOV AX, 0."
            },
            {
                question: "Which register pair is used for string operations with the MOVSB instruction?",
                options: ["AX:BX", "CS:IP", "DS:SI and ES:DI", "SS:SP"],
                correct: 2,
                explanation: "MOVSB copies a byte from DS:SI to ES:DI. DS:SI points to the source, ES:DI points to the destination. SI and DI are automatically incremented or decremented based on DF."
            },
            {
                question: "What does the TEST instruction do?",
                options: ["Adds two values", "Performs AND and sets flags without storing result", "Compares strings", "Tests if a bit is set"],
                correct: 1,
                explanation: "TEST performs a bitwise AND operation and sets flags (ZF, SF, PF) based on the result, but does not store the result. It's used to check bits without modifying data."
            },
            {
                question: "What is the ASCII code for the character 'A'?",
                options: ["64 (0x40)", "65 (0x41)", "97 (0x61)", "48 (0x30)"],
                correct: 1,
                explanation: "The ASCII code for uppercase 'A' is 65 (0x41). Lowercase 'a' is 97 (0x61). Digit '0' is 48 (0x30). These offsets are useful for converting between characters and numbers."
            },
            {
                question: "What is a buffer overflow?",
                options: ["Running out of memory", "Writing past the end of a buffer", "Reading from invalid memory", "Stack underflow"],
                correct: 1,
                explanation: "A buffer overflow occurs when data written to a buffer exceeds its allocated size, potentially overwriting adjacent memory including return addresses, leading to security vulnerabilities."
            },
            {
                question: "Which addressing mode uses a register as a pointer to memory?",
                options: ["Immediate", "Direct", "Register indirect", "Based-indexed"],
                correct: 2,
                explanation: "Register indirect addressing uses a register (BX, SI, DI, BP) as a pointer to memory. Example: MOV AX, [BX] loads AX from the address in BX."
            },
            {
                question: "What is the purpose of the PROC and ENDP directives?",
                options: ["Define data variables", "Mark the beginning and end of a procedure", "Include external files", "Set memory segments"],
                correct: 1,
                explanation: "PROC marks the beginning of a procedure (subroutine), and ENDP marks its end. They help organize code into reusable blocks that can be called with CALL and returned from with RET."
            }
        ];

        let currentQuestion = 0;
        let testAnswers = [];
        let userAnswers = [];

        document.getElementById('start-test').addEventListener('click', () => {
            document.getElementById('test-start').style.display = 'none';
            document.getElementById('test-active').style.display = 'block';
            currentQuestion = 0;
            userAnswers = new Array(testQuestions.length).fill(null);
            renderQuestion();
        });

        function renderQuestion() {
            const q = testQuestions[currentQuestion];
            document.getElementById('test-progress').style.width = ((currentQuestion + 1) / testQuestions.length * 100) + '%';
            document.getElementById('test-question').innerHTML = `<strong>Question ${currentQuestion + 1} of ${testQuestions.length}:</strong><br>${q.question}`;
            
            const optionsHtml = q.options.map((opt, i) => 
                `<button class="option-btn ${userAnswers[currentQuestion] === i ? 'selected' : ''}" data-idx="${i}">${String.fromCharCode(65 + i)}. ${opt}</button>`
            ).join('');
            document.getElementById('test-options').innerHTML = optionsHtml;

            // Show explanation if already answered
            const explanation = document.getElementById('test-explanation');
            if (userAnswers[currentQuestion] !== null) {
                explanation.innerHTML = `<strong>Explanation:</strong><br>${q.explanation}`;
                explanation.style.display = 'block';
                
                // Mark correct/incorrect
                document.querySelectorAll('.option-btn').forEach((btn, i) => {
                    if (i === q.correct) btn.classList.add('correct');
                    else if (i === userAnswers[currentQuestion]) btn.classList.add('incorrect');
                });
            } else {
                explanation.style.display = 'none';
            }

            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.addEventListener('click', () => selectAnswer(parseInt(btn.dataset.idx)));
            });

            document.getElementById('test-prev').disabled = currentQuestion === 0;
            document.getElementById('test-next').textContent = currentQuestion === testQuestions.length - 1 ? 'Finish' : 'Next Question';
        }

        function selectAnswer(idx) {
            userAnswers[currentQuestion] = idx;
            renderQuestion();
        }

        document.getElementById('test-prev').addEventListener('click', () => {
            if (currentQuestion > 0) {
                currentQuestion--;
                renderQuestion();
            }
        });

        document.getElementById('test-next').addEventListener('click', () => {
            if (currentQuestion < testQuestions.length - 1) {
                currentQuestion++;
                renderQuestion();
            } else {
                showResults();
            }
        });

        function showResults() {
            document.getElementById('test-active').style.display = 'none';
            document.getElementById('test-results').style.display = 'block';

            let correct = 0;
            userAnswers.forEach((ans, i) => {
                if (ans === testQuestions[i].correct) correct++;
            });

            const score = Math.round(correct / testQuestions.length * 100);
            document.getElementById('test-score').textContent = score + '%';

            let message = '';
            if (score >= 90) message = 'üéâ Excellent! You have mastered assembly language!';
            else if (score >= 70) message = 'üëç Good job! You understand most concepts.';
            else if (score >= 50) message = 'üìö Keep studying! Review the lectures and try again.';
            else message = 'üí™ Don\'t give up! Practice makes perfect.';

            document.getElementById('test-message').innerHTML = `${message}<br>You got ${correct} out of ${testQuestions.length} questions correct.`;
        }

        document.getElementById('retake-test').addEventListener('click', () => {
            document.getElementById('test-results').style.display = 'none';
            document.getElementById('test-start').style.display = 'block';
        });

        document.getElementById('review-answers').addEventListener('click', () => {
            document.getElementById('test-results').style.display = 'none';
            document.getElementById('test-active').style.display = 'block';
            currentQuestion = 0;
            renderQuestion();
        });

    </script>
</body>
</html>
